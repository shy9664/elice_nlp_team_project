import { KEY_ALIGN } from '@udecode/plate-alignment';
import { MARK_BOLD, MARK_ITALIC } from '@udecode/plate-basic-marks';
import { ELEMENT_CODE_BLOCK, deserializeHtmlCodeBlock } from '@udecode/plate-code-block';
import { isHtmlElement, isHtmlComment, parseHtmlElement, isHtmlText, createPluginFactory, KEY_DESERIALIZE_HTML } from '@udecode/plate-core';
import { ELEMENT_H1, ELEMENT_H2, ELEMENT_H3 } from '@udecode/plate-heading';
import { ELEMENT_IMAGE } from '@udecode/plate-image';
import { KEY_INDENT } from '@udecode/plate-indent';
import { ListStyleType, KEY_LIST_STYLE_TYPE } from '@udecode/plate-indent-list';
import { ELEMENT_PARAGRAPH } from '@udecode/plate-paragraph';

/**
 * Is the element a block element?
 */
const isHtmlBlockElement = element => {
  const blockRegex = /^(address|blockquote|body|center|dir|div|dl|fieldset|form|h[1-6]|hr|isindex|menu|noframes|noscript|ol|p|pre|table|ul|dd|dt|frameset|li|tbody|td|tfoot|th|thead|tr|html)$/i;
  return blockRegex.test(element.nodeName);
};

/**
 * Depth-first pre-order tree traverse the given HTML node and calls the given callback for each node.
 * see: https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)
 *
 * @param callback returns a boolean indicating whether traversal should be continued
 */
const traverseHtmlNode = (node, callback) => {
  const keepTraversing = callback(node);

  if (!keepTraversing) {
    return;
  }

  let child = node.firstChild;

  while (child) {
    const currentChild = child;
    const previousChild = child.previousSibling;
    child = child.nextSibling;
    traverseHtmlNode(currentChild, callback);

    if ( // An unwrap was made. Need to compute the next child again.
    !currentChild.previousSibling && !currentChild.nextSibling && !currentChild.parentNode && child && previousChild !== child.previousSibling && child.parentNode) {
      if (previousChild) {
        child = previousChild.nextSibling;
      } else {
        child = node.firstChild;
      }
    } else if ( // A list was created. Need to compute the next child again.
    !currentChild.previousSibling && !currentChild.nextSibling && !currentChild.parentNode && child && !child.previousSibling && !child.nextSibling && !child.parentNode) {
      if (previousChild) {
        if (previousChild.nextSibling) {
          child = previousChild.nextSibling.nextSibling;
        } else {
          child = null;
        }
      } else if (node.firstChild) {
        child = node.firstChild.nextSibling;
      }
    }
  }
};

/**
 * Traverse the HTML elements of the given HTML node.
 * @param rootNode The root HTML node to traverse.
 * @param callback The callback to call for each HTML element.
 */
const traverseHtmlElements = (rootNode, callback) => {
  traverseHtmlNode(rootNode, node => {
    if (!isHtmlElement(node)) {
      return true;
    }

    return callback(node);
  });
};

/**
 * Set HTML blocks mark styles to a new child span element if any.
 * This allows Plate to use block marks.
 */

const copyBlockMarksToSpanChild = rootNode => {
  traverseHtmlElements(rootNode, element => {
    const el = element;
    const styleAttribute = element.getAttribute('style');
    if (!styleAttribute) return true;

    if (isHtmlBlockElement(el)) {
      const {
        style: {
          backgroundColor,
          color,
          fontFamily,
          fontSize,
          fontStyle,
          fontWeight,
          textDecoration
        }
      } = el;

      if (backgroundColor || color || fontFamily || fontSize || fontStyle || fontWeight || textDecoration) {
        const span = document.createElement('span');

        if (!['initial', 'inherit'].includes(color)) {
          span.style.color = color;
        }

        span.style.fontFamily = fontFamily;
        span.style.fontSize = fontSize;

        if (!['normal', 'initial', 'inherit'].includes(color)) {
          span.style.fontStyle = fontStyle;
        }

        if (!['normal', 400].includes(fontWeight)) {
          span.style.fontWeight = fontWeight;
        }

        span.style.textDecoration = textDecoration;
        span.innerHTML = el.innerHTML;
        element.innerHTML = span.outerHTML;
      }
    }

    return true;
  });
};

/**
 * Traverse HTML comments.
 */
const traverseHtmlComments = (rootNode, callback) => {
  traverseHtmlNode(rootNode, node => {
    if (!isHtmlComment(node)) {
      return true;
    }

    return callback(node);
  });
};

/**
 * Removes HTML nodes between HTML comments.
 */

const removeHtmlNodesBetweenComments = (rootNode, start, end) => {
  const isClosingComment = node => isHtmlComment(node) && node.data === end;

  traverseHtmlComments(rootNode, comment => {
    if (comment.data === start) {
      let node = comment.nextSibling;
      comment.remove();

      while (node && !isClosingComment(node)) {
        const {
          nextSibling
        } = node;
        node.remove();
        node = nextSibling;
      }

      if (node && isClosingComment(node)) {
        node.remove();
      }
    }

    return true;
  });
};

/**
 * Remove HTML nodes between comments in the next sibling after BR.
 */

const cleanDocxBrComments = rootNode => {
  traverseHtmlElements(rootNode, element => {
    if (element.tagName !== 'BR') {
      return true;
    }

    if (element.nextSibling && isHtmlComment(element.nextSibling) && element.nextSibling.data === '[if !supportLineBreakNewLine]') {
      removeHtmlNodesBetweenComments(element.nextSibling, '[if !supportLineBreakNewLine]', '[endif]');
    }

    return false;
  });
};

const CARRIAGE_RETURN = '\u000D';
const LINE_FEED = '\u000A';
const NO_BREAK_SPACE = '\u00A0';
const SPACE = '\u0020';
const TAB = '\u0009';
const ZERO_WIDTH_SPACE = '\u200B';

const isHtmlOpEmpty = element => element.nodeName === 'O:P' && element.textContent === NO_BREAK_SPACE;

const isHtmlElementEmpty = element => element.children.length === 1 && element.firstElementChild !== null && (isHtmlOpEmpty(element.firstElementChild) || isHtmlElementEmpty(element.firstElementChild));
/**
 * Remove paragraph innerHTML if its child is 'O:P' with NO_BREAK_SPACE.
 */


const cleanDocxEmptyParagraphs = rootNode => {
  traverseHtmlElements(rootNode, element => {
    if (element.tagName === 'P' && isHtmlElementEmpty(element)) {
      element.innerHTML = '';
    }

    return true;
  });
};

/**
 * Is element a docx footnote.
 */
const isDocxFootnote = element => {
  return element.tagName === 'SPAN' && element.classList.contains('MsoFootnoteReference');
};

/**
 * Gets "4" from "[4]", "A" from "[A]", etc.
 */

const extractFootnoteNumber = footnote => {
  return (footnote.textContent || '').trim().replace(/[[\]]/g, '');
};
/**
 * Replace docx footnotes with sup element.
 */


const cleanDocxFootnotes = rootNode => {
  traverseHtmlElements(rootNode, element => {
    if (isDocxFootnote(element)) {
      const footnoteReplacement = document.createElement('sup');
      footnoteReplacement.textContent = extractFootnoteNumber(element);

      if (element.parentElement) {
        element.parentElement.replaceChild(footnoteReplacement, element);
      }

      return true;
    }

    return true;
  });
};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var assertString_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assertString;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function assertString(input) {
  var isString = typeof input === 'string' || input instanceof String;

  if (!isString) {
    var invalidType = _typeof(input);

    if (input === null) invalidType = 'null';else if (invalidType === 'object') invalidType = input.constructor.name;
    throw new TypeError("Expected a string but received a ".concat(invalidType));
  }
}

module.exports = exports.default;
module.exports.default = exports.default;
});

unwrapExports(assertString_1);

var merge_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = merge;

function merge() {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var defaults = arguments.length > 1 ? arguments[1] : undefined;

  for (var key in defaults) {
    if (typeof obj[key] === 'undefined') {
      obj[key] = defaults[key];
    }
  }

  return obj;
}

module.exports = exports.default;
module.exports.default = exports.default;
});

unwrapExports(merge_1);

var isFQDN_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isFQDN;

var _assertString = _interopRequireDefault(assertString_1);

var _merge = _interopRequireDefault(merge_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_fqdn_options = {
  require_tld: true,
  allow_underscores: false,
  allow_trailing_dot: false,
  allow_numeric_tld: false,
  allow_wildcard: false
};

function isFQDN(str, options) {
  (0, _assertString.default)(str);
  options = (0, _merge.default)(options, default_fqdn_options);
  /* Remove the optional trailing dot before checking validity */

  if (options.allow_trailing_dot && str[str.length - 1] === '.') {
    str = str.substring(0, str.length - 1);
  }
  /* Remove the optional wildcard before checking validity */


  if (options.allow_wildcard === true && str.indexOf('*.') === 0) {
    str = str.substring(2);
  }

  var parts = str.split('.');
  var tld = parts[parts.length - 1];

  if (options.require_tld) {
    // disallow fqdns without tld
    if (parts.length < 2) {
      return false;
    }

    if (!/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
      return false;
    } // disallow spaces


    if (/\s/.test(tld)) {
      return false;
    }
  } // reject numeric TLDs


  if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
    return false;
  }

  return parts.every(function (part) {
    if (part.length > 63) {
      return false;
    }

    if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
      return false;
    } // disallow full-width chars


    if (/[\uff01-\uff5e]/.test(part)) {
      return false;
    } // disallow parts starting or ending with hyphen


    if (/^-|-$/.test(part)) {
      return false;
    }

    if (!options.allow_underscores && /_/.test(part)) {
      return false;
    }

    return true;
  });
}

module.exports = exports.default;
module.exports.default = exports.default;
});

unwrapExports(isFQDN_1);

var isIP_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isIP;

var _assertString = _interopRequireDefault(assertString_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
11.3.  Examples

   The following addresses

             fe80::1234 (on the 1st link of the node)
             ff02::5678 (on the 5th link of the node)
             ff08::9abc (on the 10th organization of the node)

   would be represented as follows:

             fe80::1234%1
             ff02::5678%5
             ff08::9abc%10

   (Here we assume a natural translation from a zone index to the
   <zone_id> part, where the Nth zone of any scope is translated into
   "N".)

   If we use interface names as <zone_id>, those addresses could also be
   represented as follows:

            fe80::1234%ne0
            ff02::5678%pvc1.3
            ff08::9abc%interface10

   where the interface "ne0" belongs to the 1st link, "pvc1.3" belongs
   to the 5th link, and "interface10" belongs to the 10th organization.
 * * */
var IPv4SegmentFormat = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';
var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
var IPv6SegmentFormat = '(?:[0-9a-fA-F]{1,4})';
var IPv6AddressRegExp = new RegExp('^(' + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ')(%[0-9a-zA-Z-.:]{1,})?$');

function isIP(str) {
  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  (0, _assertString.default)(str);
  version = String(version);

  if (!version) {
    return isIP(str, 4) || isIP(str, 6);
  }

  if (version === '4') {
    if (!IPv4AddressRegExp.test(str)) {
      return false;
    }

    var parts = str.split('.').sort(function (a, b) {
      return a - b;
    });
    return parts[3] <= 255;
  }

  if (version === '6') {
    return !!IPv6AddressRegExp.test(str);
  }

  return false;
}

module.exports = exports.default;
module.exports.default = exports.default;
});

unwrapExports(isIP_1);

var isURL_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isURL;

var _assertString = _interopRequireDefault(assertString_1);

var _isFQDN = _interopRequireDefault(isFQDN_1);

var _isIP = _interopRequireDefault(isIP_1);

var _merge = _interopRequireDefault(merge_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/*
options for isURL method

require_protocol - if set as true isURL will return false if protocol is not present in the URL
require_valid_protocol - isURL will check if the URL's protocol is present in the protocols option
protocols - valid protocols can be modified with this option
require_host - if set as false isURL will not check if host is present in the URL
require_port - if set as true isURL will check if port is present in the URL
allow_protocol_relative_urls - if set as true protocol relative URLs will be allowed
validate_length - if set as false isURL will skip string length validation (IE maximum is 2083)

*/
var default_url_options = {
  protocols: ['http', 'https', 'ftp'],
  require_tld: true,
  require_protocol: false,
  require_host: true,
  require_port: false,
  require_valid_protocol: true,
  allow_underscores: false,
  allow_trailing_dot: false,
  allow_protocol_relative_urls: false,
  allow_fragments: true,
  allow_query_components: true,
  validate_length: true
};
var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;

function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === '[object RegExp]';
}

function checkHost(host, matches) {
  for (var i = 0; i < matches.length; i++) {
    var match = matches[i];

    if (host === match || isRegExp(match) && match.test(host)) {
      return true;
    }
  }

  return false;
}

function isURL(url, options) {
  (0, _assertString.default)(url);

  if (!url || /[\s<>]/.test(url)) {
    return false;
  }

  if (url.indexOf('mailto:') === 0) {
    return false;
  }

  options = (0, _merge.default)(options, default_url_options);

  if (options.validate_length && url.length >= 2083) {
    return false;
  }

  if (!options.allow_fragments && url.includes('#')) {
    return false;
  }

  if (!options.allow_query_components && (url.includes('?') || url.includes('&'))) {
    return false;
  }

  var protocol, auth, host, hostname, port, port_str, split, ipv6;
  split = url.split('#');
  url = split.shift();
  split = url.split('?');
  url = split.shift();
  split = url.split('://');

  if (split.length > 1) {
    protocol = split.shift().toLowerCase();

    if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
      return false;
    }
  } else if (options.require_protocol) {
    return false;
  } else if (url.substr(0, 2) === '//') {
    if (!options.allow_protocol_relative_urls) {
      return false;
    }

    split[0] = url.substr(2);
  }

  url = split.join('://');

  if (url === '') {
    return false;
  }

  split = url.split('/');
  url = split.shift();

  if (url === '' && !options.require_host) {
    return true;
  }

  split = url.split('@');

  if (split.length > 1) {
    if (options.disallow_auth) {
      return false;
    }

    if (split[0] === '') {
      return false;
    }

    auth = split.shift();

    if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
      return false;
    }

    var _auth$split = auth.split(':'),
        _auth$split2 = _slicedToArray(_auth$split, 2),
        user = _auth$split2[0],
        password = _auth$split2[1];

    if (user === '' && password === '') {
      return false;
    }
  }

  hostname = split.join('@');
  port_str = null;
  ipv6 = null;
  var ipv6_match = hostname.match(wrapped_ipv6);

  if (ipv6_match) {
    host = '';
    ipv6 = ipv6_match[1];
    port_str = ipv6_match[2] || null;
  } else {
    split = hostname.split(':');
    host = split.shift();

    if (split.length) {
      port_str = split.join(':');
    }
  }

  if (port_str !== null && port_str.length > 0) {
    port = parseInt(port_str, 10);

    if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
      return false;
    }
  } else if (options.require_port) {
    return false;
  }

  if (options.host_whitelist) {
    return checkHost(host, options.host_whitelist);
  }

  if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
    return false;
  }

  host = host || ipv6;

  if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
    return false;
  }

  return true;
}

module.exports = exports.default;
module.exports.default = exports.default;
});

var isURL = unwrapExports(isURL_1);

const getRtfImageHex = imageData => {
  const [, bliptagData = ''] = imageData.split('bliptag');
  const bracketSplit = bliptagData.split('}');

  if (bracketSplit.length < 2) {
    return null;
  }

  const [beforeBracket, afterBracket] = bracketSplit;

  if (bracketSplit.length > 2 && beforeBracket.includes('blipuid')) {
    return afterBracket.split(SPACE).join('');
  }

  const spaceSplit = beforeBracket.split(SPACE);

  if (spaceSplit.length < 2) {
    return null;
  }

  return spaceSplit.slice(1).join('');
};

const getRtfImageMimeType = imageData => {
  const [bliptagMeta] = imageData.split('bliptag');

  if (bliptagMeta.includes('pngblip')) {
    return 'image/png';
  }

  if (bliptagMeta.includes('jpegblip')) {
    return 'image/jpeg';
  }

  return null;
};

const END_OF_ID_SEQUENCE_CHARACTERS = ['\\', '{', CARRIAGE_RETURN, LINE_FEED, SPACE];
const getRtfImageSpid = (imageData, spidPrefix) => {
  const indexes = END_OF_ID_SEQUENCE_CHARACTERS.map(character => imageData.indexOf(character));
  const foundIndexes = indexes.filter(index => index !== -1);
  const idLength = Math.min(imageData.length, ...foundIndexes);
  const id = imageData.substring(0, idLength);
  return id ? `${spidPrefix}${id}` : null;
};

const getRtfImagesByType = (rtf, spidPrefix, type) => {
  const [, ...images] = rtf.split(type);
  return images.reduce((rtfImages, image) => {
    const [, imageData = ''] = image.split('shplid');
    const spid = getRtfImageSpid(imageData, spidPrefix);
    const mimeType = getRtfImageMimeType(imageData);
    const hex = getRtfImageHex(imageData);

    if (spid && mimeType && hex) {
      rtfImages.push({
        hex,
        mimeType,
        spid
      });
    }

    return rtfImages;
  }, []);
};

const getRtfImagesMap = rtf => {
  const rtfImagesMap = {};
  const shppictRtfImages = getRtfImagesByType(rtf, 'i', '\\shppict');

  for (const shppictRtfImage of shppictRtfImages) {
    rtfImagesMap[shppictRtfImage.spid] = shppictRtfImage;
  }

  const shpRtfImages = getRtfImagesByType(rtf, 's', '\\shp');

  for (const shpRtfImage of shpRtfImages) {
    rtfImagesMap[shpRtfImage.spid] = shpRtfImage;
  }

  return rtfImagesMap;
};

const acceptNode = () => NodeFilter.FILTER_ACCEPT;

const getHtmlComments = node => {
  const comments = [];
  const iterator = document.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {
    acceptNode
  });
  let currentNode = iterator.nextNode();

  while (currentNode) {
    if (currentNode.nodeValue) {
      comments.push(currentNode.nodeValue);
    }

    currentNode = iterator.nextNode();
  }

  return comments;
};

const getVShapes = document => {
  const comments = getHtmlComments(document);
  return comments.reduce((vShapesMap, comment) => {
    try {
      const xmlDocument = new DOMParser().parseFromString(comment, 'text/html');
      const vShapes = Array.from(xmlDocument.getElementsByTagName('V:SHAPE'));
      vShapes.forEach(vShape => {
        const {
          id
        } = vShape;
        const spid = vShape.getAttribute('o:spid');

        if (typeof id === 'string' && typeof spid === 'string') {
          vShapesMap[id] = spid;
        }
      });
    } catch (error) {// Cannot parse as XML, we're not interested in this comment
    }

    return vShapesMap;
  }, {});
};

const normalizeSpid = spid => {
  const [,, id] = spid.split('_');
  return id;
};

const getVShapeSpid = (document, element) => {
  if (element.tagName === 'IMG') {
    const vShapeId = element.getAttribute('v:shapes');
    const vShapes = getVShapes(document);

    if (!vShapeId) {
      return null;
    }

    const vShapeSpid = vShapes[vShapeId];

    if (vShapeSpid) {
      return normalizeSpid(vShapeSpid);
    }

    if (element.parentElement && element.parentElement.parentElement && element.parentElement.parentElement.innerHTML.indexOf('msEquation') >= 0) {
      return null;
    }

    return normalizeSpid(vShapeId);
  }

  if (!element.parentElement) {
    return null;
  }

  const spid = element.parentElement.getAttribute('o:spid');

  if (spid) {
    return normalizeSpid(spid);
  }

  return spid;
};

const hexToBase64 = hex => {
  const hexPairs = hex.match(/\w{2}/g) || [];
  const binary = hexPairs.map(hexPair => String.fromCharCode(parseInt(hexPair, 16)));
  return btoa(binary.join(''));
};

/**
 * Clean docx image elements.
 */

const cleanDocxImageElements = (document, rtf, rootNode) => {
  if (!rtf) {
    return;
  }

  traverseHtmlElements(rootNode, element => {
    if (!['IMG', 'V:IMAGEDATA'].includes(element.tagName)) {
      return true;
    }

    if (element.tagName === 'IMG') {
      const src = element.getAttribute('src');

      if (!src || !src.startsWith('file://')) {
        return true;
      }

      const alt = element.getAttribute('alt');

      if (typeof alt === 'string' && isURL(alt, {
        require_protocol: true
      })) {
        element.setAttribute('src', alt);
        return true;
      }
    }

    const vShapeSpid = getVShapeSpid(document, element);

    if (!vShapeSpid) {
      return true;
    }

    const rtfImagesMap = getRtfImagesMap(rtf);
    const rtfImage = rtfImagesMap[vShapeSpid];

    if (!rtfImage) {
      // We fould some kind of vshape (perhaps a drawing) that we don't know
      // how to recover from RTF. So we just skip it.
      element.remove();
      return true;
    }

    const dataUri = `data:${rtfImage.mimeType};base64,${hexToBase64(rtfImage.hex)}`;

    if (element.tagName === 'IMG') {
      element.setAttribute('src', dataUri);
    } else if (element.parentNode && element.parentNode.parentNode) {
      const imageElement = document.createElement('img');
      imageElement.setAttribute('src', dataUri);
      element.parentNode.parentNode.replaceChild(imageElement, element.parentNode);
    }

    return true;
  });
};

/**
 * Clean elements style mso-list to mso-list:Ignore
 */

const cleanDocxListElements = rootNode => {
  traverseHtmlElements(rootNode, element => {
    const styleAttribute = element.getAttribute('style');

    if (styleAttribute) {
      element.setAttribute('style', styleAttribute.replace(/mso-list:\s*Ignore/gim, 'mso-list:Ignore'));
    }

    return true;
  });
};

const getDocxListContentHtml = rootElement => {
  const clonedElement = rootElement.cloneNode(true);
  removeHtmlNodesBetweenComments(clonedElement, '[if !supportLists]', '[endif]');
  traverseHtmlElements(clonedElement, element => {
    const styleAttribute = element.getAttribute('style');

    if (styleAttribute === 'mso-list:Ignore') {
      element.remove();
    }

    return true;
  });
  return clonedElement.innerHTML;
};

const getDocxListIndent = element => {
  const styleAttribute = element.getAttribute('style') || '';
  const matches = styleAttribute.match(/level(\d+)/im);

  if (matches && matches.length >= 1) {
    const [, level] = matches;
    return parseInt(level, 10);
  }

  return 1;
};

const isDocxBookmark = element => {
  const styleAttribute = element.getAttribute('style');
  return (styleAttribute || '').startsWith('mso-bookmark') && !element.textContent;
};

const isDocxList = element => {
  const styleAttribute = element.getAttribute('style');

  if (!styleAttribute) {
    return false;
  }

  const hasMsoListInStyle = /mso-list:\s*l/gim.test(styleAttribute);

  if (!hasMsoListInStyle) {
    return false;
  }

  const hasMsoListIgnoreChild = Boolean(element.querySelector('[style="mso-list:Ignore"]'));

  if (hasMsoListIgnoreChild) {
    return true;
  }

  return element.outerHTML.includes('<!--[if !supportLists]-->');
};

const getDocxListNode = element => {
  return element.querySelector('[style="mso-list:Ignore"]') || element.querySelector('span[lang]');
};

const isOlSymbol = symbol => {
  return /[0-9a-np-z]\S/g.test(symbol.toLowerCase());
};

const isDocxOl = element => {
  const listNode = getDocxListNode(element);

  if (!listNode) {
    return false;
  }

  return isOlSymbol(listNode.textContent || '');
};

const docxListToList = element => {
  const listLevel = getDocxListIndent(element);
  let listHtml = '';
  let nextSibling = element;

  while (nextSibling) {
    if (isDocxBookmark(nextSibling)) {
      nextSibling = nextSibling.nextElementSibling;
      continue;
    }

    if (!isDocxList(nextSibling)) {
      break;
    }

    const nextListLevel = getDocxListIndent(nextSibling);

    if (nextListLevel < listLevel) {
      // Lower level found. Current list is done.
      break;
    }

    if (nextListLevel > listLevel) {
      const nestedList = docxListToList(nextSibling);

      if (nestedList.list) {
        listHtml += nestedList.list.outerHTML;
      }

      nextSibling = nestedList.nextSibling;
      continue;
    }

    listHtml += `<li>${getDocxListContentHtml(nextSibling)}</li>`;
    const currentElement = nextSibling;
    nextSibling = currentElement.nextElementSibling;
    currentElement.remove();
  }

  const listTagName = isDocxOl(element) ? 'ol' : 'ul';
  const list = parseHtmlElement(`<${listTagName}>${listHtml}</${listTagName}>`);
  return {
    list,
    nextSibling
  };
};

const cleanDocxListElementsToList = rootNode => {
  traverseHtmlElements(rootNode, element => {
    const styleAttribute = element.getAttribute('style');

    if (styleAttribute) {
      element.setAttribute('style', styleAttribute.replace(/mso-list:\s*Ignore/gim, 'mso-list:Ignore'));
    }

    return true;
  });
  traverseHtmlElements(rootNode, element => {
    if (!isDocxList(element)) {
      return true;
    }

    const {
      parentElement,
      previousSibling
    } = element;

    if (!parentElement) {
      return true;
    }

    const {
      list
    } = docxListToList(element);

    if (!list) {
      return true;
    }

    const beforeElement = previousSibling ? previousSibling.nextSibling : parentElement.firstChild;

    if (beforeElement) {
      parentElement.insertBefore(list, beforeElement);
    } else {
      parentElement.appendChild(list);
    }

    return false;
  });
};

/**
 * Replace `element` tag name by `tagName`.
 * Attributes, innerHTML and parent relationship is kept.
 */
const replaceTagName = (element, tagName) => {
  const newElement = document.createElement(tagName);
  newElement.innerHTML = element.innerHTML;

  for (const {
    name
  } of element.attributes) {
    const value = element.getAttribute(name);

    if (value) {
      newElement.setAttribute(name, value);
    }
  }

  if (element.parentNode) {
    element.parentNode.replaceChild(newElement, element);
  }

  return newElement;
};

/**
 * Replace p.MsoQuote elements with blockquote.
 */

const cleanDocxQuotes = rootNode => {
  traverseHtmlElements(rootNode, element => {
    if (element.parentNode && element.tagName === 'P' && element.classList.contains('MsoQuote')) {
      replaceTagName(element, 'blockquote');
    }

    return true;
  });
};

const generateSpaces = count => Array.from({
  length: count
}, () => SPACE).join('');
const generateTabs = count => Array.from({
  length: count
}, () => TAB).join('');

/**
 * Replace the element with spaces if its style includes 'mso-spacerun: yes'.
 */

const cleanDocxSpacerun = element => {
  const styleAttribute = element.getAttribute('style');

  if (!(styleAttribute && ['mso-spacerun:yes', 'mso-spacerun: yes'].includes(styleAttribute))) {
    return;
  }

  const spacesCount = (element.textContent || '').length;
  const replacementNode = document.createTextNode(generateSpaces(spacesCount));

  if (element.parentNode) {
    element.parentNode.replaceChild(replacementNode, element);
  }
};

/**
 * Replace element with tabs if its style starts with 'mso-tab-count'.
 */

const cleanDocxTabCount = element => {
  const styleAttribute = element.getAttribute('style') || '';

  if (!styleAttribute.startsWith('mso-tab-count:')) {
    return;
  }

  const [, countString] = styleAttribute.split(':');
  const count = parseInt(countString, 10);
  const replacementNode = document.createTextNode(generateTabs(count));

  if (element.parentNode) {
    element.parentNode.replaceChild(replacementNode, element);
  }
};

/**
 * Clean docx spaceruns and tab counts.
 */

const cleanDocxSpans = rootNode => {
  traverseHtmlElements(rootNode, element => {
    if (element.nodeName !== 'SPAN') {
      return true;
    }

    cleanDocxSpacerun(element);
    cleanDocxTabCount(element);
    return true;
  });
};

/**
 * Replace BR elements with line feeds.
 */

const cleanHtmlBrElements = rootNode => {
  traverseHtmlElements(rootNode, element => {
    if (element.tagName !== 'BR') {
      return true;
    }

    const replacementTextNode = document.createTextNode(LINE_FEED);

    if (element.parentElement) {
      element.parentElement.replaceChild(replacementTextNode, element);
    }

    return false;
  });
};

/**
 * Replace \r\n and \r with \n
 */
const cleanHtmlCrLf = html => {
  return html.replace(/(\r\n|\r)/gm, '\n');
};

const ALLOWED_EMPTY_ELEMENTS = ['BR', 'IMG'];

const isEmpty = element => {
  return !ALLOWED_EMPTY_ELEMENTS.includes(element.nodeName) && !element.innerHTML.trim();
};

const removeIfEmpty = element => {
  if (isEmpty(element)) {
    const {
      parentElement
    } = element;
    element.remove();

    if (parentElement) {
      removeIfEmpty(parentElement);
    }
  }
};
/**
 * Remove empty elements from rootNode.
 * Allowed empty elements: BR, IMG.
 */


const cleanHtmlEmptyElements = rootNode => {
  traverseHtmlElements(rootNode, element => {
    removeIfEmpty(element);
    return true;
  });
};

/**
 * Replace FONT elements with SPAN elements if there is textContent (remove otherwise).
 */

const cleanHtmlFontElements = rootNode => {
  traverseHtmlElements(rootNode, element => {
    if (element.tagName === 'FONT') {
      if (element.textContent) {
        replaceTagName(element, 'span');
      } else {
        element.remove();
      }
    }

    return true;
  });
};

/**
 * If href starts with '#'.
 */
const isHtmlFragmentHref = href => href.startsWith('#');

/**
 * Unwrap the given HTML element.
 */
const unwrapHtmlElement = element => {
  element.outerHTML = element.innerHTML;
};

/**
 * Remove fragment hrefs and spans without inner text.
 */

const cleanHtmlLinkElements = rootNode => {
  traverseHtmlElements(rootNode, element => {
    if (element.tagName !== 'A') {
      return true;
    }

    const href = element.getAttribute('href');

    if (!href || isHtmlFragmentHref(href)) {
      unwrapHtmlElement(element);
    }

    if (href && element.querySelector('img')) {
      for (const span of element.querySelectorAll('span')) {
        if (!span.innerText) {
          unwrapHtmlElement(span);
        }
      }
    }

    return true;
  });
};

const traverseHtmlTexts = (rootNode, callback) => {
  traverseHtmlNode(rootNode, node => {
    if (!isHtmlText(node)) {
      return true;
    }

    return callback(node);
  });
};

const cleanHtmlTextNodes = rootNode => {
  traverseHtmlTexts(rootNode, textNode => {
    if (/^\n\s*$/.test(textNode.data) && (textNode.previousElementSibling || textNode.nextElementSibling)) {
      textNode.remove();
      return true;
    }

    textNode.data = textNode.data.replace(/\n\s*/g, '\n');

    if (textNode.data.includes(CARRIAGE_RETURN) || textNode.data.includes(LINE_FEED) || textNode.data.includes(NO_BREAK_SPACE)) {
      const hasSpace = textNode.data.includes(SPACE);
      const hasNonWhitespace = /\S/.test(textNode.data);
      const hasLineFeed = textNode.data.includes(LINE_FEED);

      if (!(hasSpace || hasNonWhitespace) && !hasLineFeed) {
        if (textNode.data === NO_BREAK_SPACE) {
          textNode.data = SPACE;
          return true;
        }

        textNode.remove();
        return true;
      }

      if (textNode.previousSibling && textNode.previousSibling.nodeName === 'BR' && textNode.parentElement) {
        textNode.parentElement.removeChild(textNode.previousSibling);
        const matches = textNode.data.match(/^[\r\n]+/);
        const offset = matches ? matches[0].length : 0;
        textNode.data = textNode.data.substring(offset).replace(new RegExp(LINE_FEED, 'g'), SPACE).replace(new RegExp(CARRIAGE_RETURN, 'g'), SPACE);
        textNode.data = `\n${textNode.data}`;
      } else {
        textNode.data = textNode.data.replace(new RegExp(LINE_FEED, 'g'), SPACE).replace(new RegExp(CARRIAGE_RETURN, 'g'), SPACE);
      }
    }

    return true;
  });
};

const DOCX_INDENT_STEP = 32;
const getDocxIndent = (element, indentStep = DOCX_INDENT_STEP) => {
  const el = element;
  const {
    marginLeft
  } = el.style;
  const marginLeftNumber = parseInt(marginLeft, 10);
  if (!marginLeftNumber) return 0;
  return Math.round(marginLeftNumber / indentStep);
};

const getTextListStyleType = text => {
  var _text$match, _text$match2;

  // text.match(/^\d+\s*[-\\.)]?\s+/)?.[0];
  if ((_text$match = text.match(/^\d+[\\.]/)) !== null && _text$match !== void 0 && _text$match[0]) {
    return ListStyleType.Decimal;
  }

  if ((_text$match2 = text.match(/^[a-z]+\./)) !== null && _text$match2 !== void 0 && _text$match2[0]) {
    return ListStyleType.LowerAlpha;
  }
};

/**
 * Check if the element contains docx content.
 * True if one element has:
 * - style including 'mso-'
 * - className including 'Mso'
 */

const isDocxContent = body => {
  let result = false;
  traverseHtmlElements(body, element => {
    const styleAttribute = element.getAttribute('style') || '';
    const classList = Array.from(element.classList);
    const isMsoElement = styleAttribute.includes('mso-') || classList.some(className => className.startsWith('Mso'));
    result = result || isMsoElement;
    return !result;
  });
  return result;
};

/**
 * Trim the html and remove zero width spaces,
 * then wrap it with a body element.
 */

const postCleanHtml = html => {
  const cleanHtml = html.trim().replace(new RegExp(ZERO_WIDTH_SPACE, 'g'), '');
  return `<body>${cleanHtml}</body>`;
};

/**
 * Remove string before <html
 */
const removeBeforeHtml = html => {
  const index = html.indexOf('<html');

  if (index === -1) {
    return html;
  }

  return html.substring(index);
};
/**
 * Remove string after </html>
 */


const removeAfterHtml = html => {
  const index = html.lastIndexOf('</html>');

  if (index === -1) {
    return html;
  }

  return html.substring(0, index + '</html>'.length);
};
/**
 * Remove string before <html and after </html>
 */


const removeHtmlSurroundings = html => {
  return removeBeforeHtml(removeAfterHtml(html));
};

const cleaners = [removeHtmlSurroundings, cleanHtmlCrLf];
/**
 * Remove HTML surroundings and clean HTML from CR/LF
 */

const preCleanHtml = html => {
  return cleaners.reduce((result, clean) => clean(result), html);
};

const cleanDocx = (html, rtf) => {
  const document = new DOMParser().parseFromString(preCleanHtml(html), 'text/html');
  const {
    body
  } = document;

  if (!rtf && !isDocxContent(body)) {
    return html;
  }

  cleanDocxFootnotes(body);
  cleanDocxImageElements(document, rtf, body);
  cleanHtmlEmptyElements(body);
  cleanDocxEmptyParagraphs(body);
  cleanDocxQuotes(body);
  cleanDocxSpans(body);
  cleanHtmlTextNodes(body);
  cleanDocxBrComments(body);
  cleanHtmlBrElements(body);
  cleanHtmlLinkElements(body);
  cleanHtmlFontElements(body);
  cleanDocxListElements(body);
  copyBlockMarksToSpanChild(body);
  return postCleanHtml(body.innerHTML);
};

const KEY_DESERIALIZE_DOCX = 'deserializeDocx';

const getListNode = type => element => {
  const node = {
    type
  };

  if (element.style.textAlign) {
    node[KEY_ALIGN] = element.style.textAlign;
  }

  if (element.style.lineHeight) {
    node.lineHeight = element.style.lineHeight;
  }

  if (isDocxList(element)) {
    var _element$textContent, _getTextListStyleType;

    node[KEY_INDENT] = getDocxListIndent(element);
    const text = (_element$textContent = element.textContent) !== null && _element$textContent !== void 0 ? _element$textContent : '';
    node[KEY_LIST_STYLE_TYPE] = (_getTextListStyleType = getTextListStyleType(text)) !== null && _getTextListStyleType !== void 0 ? _getTextListStyleType : ListStyleType.Disc;
    element.innerHTML = getDocxListContentHtml(element);
  } else {
    const indent = getDocxIndent(element);

    if (indent) {
      node[KEY_INDENT] = indent;
    }
  }

  return node;
};

const createDeserializeDocxPlugin = createPluginFactory({
  key: KEY_DESERIALIZE_DOCX,
  inject: {
    pluginsByKey: {
      [KEY_DESERIALIZE_HTML]: {
        editor: {
          insertData: {
            transformData: (data, {
              dataTransfer
            }) => {
              const rtf = dataTransfer.getData('text/rtf');
              return cleanDocx(data, rtf);
            }
          }
        }
      }
    }
  },
  overrideByKey: {
    [ELEMENT_PARAGRAPH]: {
      then: (editor, {
        type
      }) => ({
        deserializeHtml: {
          query: el => {
            return !el.classList.contains('SourceCode');
          },
          getNode: getListNode(type)
        }
      })
    },
    [ELEMENT_H1]: {
      then: (editor, {
        type
      }) => ({
        deserializeHtml: {
          getNode: getListNode(type)
        }
      })
    },
    [ELEMENT_H2]: {
      then: (editor, {
        type
      }) => ({
        deserializeHtml: {
          getNode: getListNode(type)
        }
      })
    },
    [ELEMENT_H3]: {
      then: (editor, {
        type
      }) => ({
        deserializeHtml: {
          getNode: getListNode(type)
        }
      })
    },
    [ELEMENT_CODE_BLOCK]: {
      deserializeHtml: [{
        validNodeName: 'PRE',
        ...deserializeHtmlCodeBlock
      }, {
        validClassName: 'SourceCode',
        ...deserializeHtmlCodeBlock
      }]
    },
    // [ELEMENT_TABLE]: {
    //   deserializeHtml:
    // },
    [ELEMENT_IMAGE]: {
      editor: {
        insertData: {
          query: ({
            dataTransfer
          }) => {
            const data = dataTransfer.getData('text/html');
            const {
              body
            } = new DOMParser().parseFromString(data, 'text/html');
            return !isDocxContent(body);
          }
        }
      }
    },
    [MARK_BOLD]: {
      deserializeHtml: [{
        validNodeName: ['STRONG', 'B'],
        query: el => {
          var _el$children$;

          return !(((_el$children$ = el.children[0]) === null || _el$children$ === void 0 ? void 0 : _el$children$.style.fontWeight) === 'normal');
        }
      }, {
        validStyle: {
          fontWeight: ['600', '700', 'bold']
        }
      }]
    },
    [MARK_ITALIC]: {
      deserializeHtml: [{
        validNodeName: ['EM', 'I'],
        query: el => {
          var _el$children$2;

          return !(el.nodeName === 'EM' && ((_el$children$2 = el.children[0]) === null || _el$children$2 === void 0 ? void 0 : _el$children$2.style.fontStyle) === 'normal');
        }
      }, {
        validStyle: {
          fontStyle: 'italic'
        }
      }]
    }
  }
});

export { CARRIAGE_RETURN, KEY_DESERIALIZE_DOCX, LINE_FEED, NO_BREAK_SPACE, SPACE, TAB, ZERO_WIDTH_SPACE, cleanDocx, cleanDocxBrComments, cleanDocxEmptyParagraphs, cleanDocxFootnotes, cleanDocxImageElements, cleanDocxListElements, cleanDocxListElementsToList, cleanDocxQuotes, cleanDocxSpacerun, cleanDocxSpans, cleanDocxTabCount, cleanHtmlBrElements, cleanHtmlCrLf, cleanHtmlEmptyElements, cleanHtmlFontElements, cleanHtmlLinkElements, cleanHtmlTextNodes, copyBlockMarksToSpanChild, createDeserializeDocxPlugin, docxListToList, generateSpaces, generateTabs, getDocxIndent, getDocxListContentHtml, getDocxListIndent, getDocxListNode, getHtmlComments, getRtfImageHex, getRtfImageMimeType, getRtfImageSpid, getRtfImagesByType, getRtfImagesMap, getTextListStyleType, getVShapeSpid, getVShapes, hexToBase64, isDocxBookmark, isDocxContent, isDocxFootnote, isDocxList, isDocxOl, isHtmlBlockElement, isHtmlFragmentHref, isOlSymbol, postCleanHtml, preCleanHtml, removeHtmlNodesBetweenComments, removeHtmlSurroundings, replaceTagName, traverseHtmlComments, traverseHtmlElements, traverseHtmlNode, traverseHtmlTexts, unwrapHtmlElement };
//# sourceMappingURL=index.es.js.map
