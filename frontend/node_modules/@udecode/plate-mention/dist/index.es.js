import { findNode, getPluginType, getPlugin, insertNodes, createPluginFactory, getBlockAbove } from '@udecode/plate-core';
import { Range, Transforms, Editor, Node } from 'slate';
import { comboboxStore } from '@udecode/plate-combobox';
import { HistoryEditor } from 'slate-history';

const moveSelectionByOffset = (editor, {
  query = () => true
}) => event => {
  const {
    selection
  } = editor;

  if (!selection || Range.isExpanded(selection) || !query(editor)) {
    return false;
  }

  if (event.key === 'ArrowLeft') {
    event.preventDefault();
    Transforms.move(editor, {
      unit: 'offset',
      reverse: true
    });
    return true;
  }

  if (event.key === 'ArrowRight') {
    event.preventDefault();
    Transforms.move(editor, {
      unit: 'offset'
    });
    return true;
  }
};

const findMentionInput = (editor, options) => findNode(editor, { ...options,
  match: {
    type: getPluginType(editor, ELEMENT_MENTION_INPUT)
  }
});

const isNodeMentionInput = (editor, node) => {
  return node.type === getPluginType(editor, ELEMENT_MENTION_INPUT);
};

const isSelectionInMentionInput = editor => findMentionInput(editor) !== undefined;

const removeMentionInput = (editor, path) => Editor.withoutNormalizing(editor, () => {
  const {
    trigger
  } = Node.get(editor, path);
  Transforms.insertText(editor, trigger, {
    at: {
      path: [...path, 0],
      offset: 0
    }
  });
  Transforms.unwrapNodes(editor, {
    at: path
  });
});

const withMention = (editor, {
  options: {
    id,
    trigger
  }
}) => {
  const {
    type
  } = getPlugin(editor, ELEMENT_MENTION_INPUT);
  const {
    apply,
    insertText,
    deleteBackward
  } = editor;

  editor.deleteBackward = unit => {
    const currentMentionInput = findMentionInput(editor);

    if (currentMentionInput && Node.string(currentMentionInput[0]) === '') {
      return removeMentionInput(editor, currentMentionInput[1]);
    }

    deleteBackward(unit);
  };

  editor.insertText = text => {
    if (isSelectionInMentionInput(editor)) {
      return Transforms.insertText(editor, text);
    }

    if (!editor.selection || text !== trigger) {
      return insertText(text);
    } // Make sure a mention input is created at the beginning of line or after a whitespace


    const previousCharLocation = Editor.before(editor, editor.selection);

    if (previousCharLocation) {
      const previousChar = Editor.string(editor, Editor.range(editor, editor.selection, previousCharLocation));

      if (previousChar !== '' && previousChar !== ' ') {
        return insertText(text);
      }
    }

    insertNodes(editor, {
      type,
      children: [{
        text: ''
      }],
      trigger
    });
  };

  editor.apply = operation => {
    if (HistoryEditor.isHistoryEditor(editor) && findMentionInput(editor)) {
      HistoryEditor.withoutSaving(editor, () => apply(operation));
    } else {
      apply(operation);
    }

    if (operation.type === 'insert_text' || operation.type === 'remove_text') {
      const currentMentionInput = findMentionInput(editor);

      if (currentMentionInput) {
        comboboxStore.set.text(Node.string(currentMentionInput[0]));
      }
    } else if (operation.type === 'set_selection') {
      var _findMentionInput, _findMentionInput2;

      const previousMentionInputPath = Range.isRange(operation.properties) ? (_findMentionInput = findMentionInput(editor, {
        at: operation.properties
      })) === null || _findMentionInput === void 0 ? void 0 : _findMentionInput[1] : undefined;
      const currentMentionInputPath = Range.isRange(operation.newProperties) ? (_findMentionInput2 = findMentionInput(editor, {
        at: operation.newProperties
      })) === null || _findMentionInput2 === void 0 ? void 0 : _findMentionInput2[1] : undefined;

      if (previousMentionInputPath && !currentMentionInputPath) {
        removeMentionInput(editor, previousMentionInputPath);
      }

      if (currentMentionInputPath) {
        comboboxStore.set.targetRange(editor.selection);
      }
    } else if (operation.type === 'insert_node' && isNodeMentionInput(editor, operation.node)) {
      if (operation.node.trigger !== trigger) {
        return;
      }

      comboboxStore.set.open({
        activeId: id,
        text: '',
        targetRange: editor.selection
      });
    } else if (operation.type === 'remove_node' && isNodeMentionInput(editor, operation.node)) {
      if (operation.node.trigger !== trigger) {
        return;
      }

      comboboxStore.set.reset();
    }
  };

  return editor;
};

const ELEMENT_MENTION = 'mention';
const ELEMENT_MENTION_INPUT = 'mention_input';
/**
 * Enables support for autocompleting @mentions.
 */

const createMentionPlugin = createPluginFactory({
  key: ELEMENT_MENTION,
  isElement: true,
  isInline: true,
  isVoid: true,
  handlers: {
    onKeyDown: editor => moveSelectionByOffset(editor, {
      query: isSelectionInMentionInput
    })
  },
  withOverrides: withMention,
  options: {
    trigger: '@',
    createMentionNode: item => ({
      value: item.text
    })
  },
  plugins: [{
    key: ELEMENT_MENTION_INPUT,
    isElement: true,
    isInline: true
  }],
  then: (editor, {
    key
  }) => ({
    options: {
      id: key
    }
  })
});

const getMentionOnSelectItem = ({
  key = ELEMENT_MENTION
} = {}) => (editor, item) => {
  var _getBlockAbove;

  const targetRange = comboboxStore.get.targetRange();
  if (!targetRange) return;
  const {
    type,
    options: {
      insertSpaceAfterMention,
      createMentionNode
    }
  } = getPlugin(editor, key);
  const pathAbove = (_getBlockAbove = getBlockAbove(editor)) === null || _getBlockAbove === void 0 ? void 0 : _getBlockAbove[1];
  const isBlockEnd = editor.selection && pathAbove && Editor.isEnd(editor, editor.selection.anchor, pathAbove);
  Editor.withoutNormalizing(editor, () => {
    // insert a space to fix the bug
    if (isBlockEnd) {
      Transforms.insertText(editor, ' ');
    } // select the text and insert the element


    Transforms.select(editor, targetRange);
    Transforms.removeNodes(editor, {
      // TODO: replace any
      match: node => node.type === ELEMENT_MENTION_INPUT
    });
    insertNodes(editor, {
      type: type,
      children: [{
        text: ''
      }],
      ...createMentionNode(item)
    }); // move the selection after the element

    Transforms.move(editor); // delete the inserted space

    if (isBlockEnd && !insertSpaceAfterMention) {
      Transforms.delete(editor);
    }
  });
  return comboboxStore.set.reset();
};

export { ELEMENT_MENTION, ELEMENT_MENTION_INPUT, createMentionPlugin, findMentionInput, getMentionOnSelectItem, isNodeMentionInput, isSelectionInMentionInput, moveSelectionByOffset, removeMentionInput, withMention };
//# sourceMappingURL=index.es.js.map
