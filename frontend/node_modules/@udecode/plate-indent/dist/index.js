'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var plateCore = require('@udecode/plate-core');
var slate = require('slate');

/**
 * Add offset to the indentation of the selected blocks.
 */
const setIndent = (editor, {
  offset = 1,
  getNodesOptions,
  setNodesProps,
  unsetNodesProps = []
}) => {
  const {
    nodeKey
  } = plateCore.getPluginInjectProps(editor, KEY_INDENT);
  const nodes = Array.from(plateCore.getNodes(editor, {
    block: true,
    ...getNodesOptions
  }));
  nodes.forEach(([node, path]) => {
    var _node, _setNodesProps;

    const blockIndent = (_node = node[nodeKey]) !== null && _node !== void 0 ? _node : 0;
    const newIndent = blockIndent + offset;
    const props = (_setNodesProps = setNodesProps === null || setNodesProps === void 0 ? void 0 : setNodesProps({
      indent: newIndent
    })) !== null && _setNodesProps !== void 0 ? _setNodesProps : {};

    if (newIndent <= 0) {
      slate.Transforms.unsetNodes(editor, [nodeKey, ...unsetNodesProps], {
        at: path
      });
    } else {
      plateCore.setNodes(editor, {
        [nodeKey]: newIndent,
        ...props
      }, {
        at: path
      });
    }
  });
};

/**
 * Increase the indentation of the selected blocks.
 */

const indent = (editor, options) => {
  setIndent(editor, {
    offset: 1,
    ...options
  });
};

/**
 * Decrease the indentation of the selected blocks.
 */

const outdent = (editor, options) => {
  setIndent(editor, {
    offset: -1,
    ...options
  });
};

const onKeyDownIndent = editor => e => {
  if (e.key === 'Tab' && !e.altKey && !e.ctrlKey && !e.metaKey) {
    e.preventDefault();
    e.shiftKey ? outdent(editor) : indent(editor);
  }
};

/**
 * - `node.indent` can not exceed `indentMax`
 * - `node.indent` is unset if `node.type` is not in `types`
 */
const withIndent = (editor, {
  inject: {
    props: {
      validTypes
    } = {}
  },
  options: {
    indentMax
  }
}) => {
  const {
    normalizeNode
  } = editor;

  editor.normalizeNode = ([node, path]) => {
    const element = node;
    const {
      type
    } = element;

    if (type) {
      if (validTypes.includes(type)) {
        if (indentMax && element.indent && element.indent > indentMax) {
          plateCore.setNodes(editor, {
            indent: indentMax
          }, {
            at: path
          });
          return;
        }
      } else if (element.indent) {
        slate.Transforms.unsetNodes(editor, 'indent', {
          at: path
        });
        return;
      }
    }

    return normalizeNode([node, path]);
  };

  return editor;
};

const KEY_INDENT = 'indent';
const createIndentPlugin = plateCore.createPluginFactory({
  key: KEY_INDENT,
  withOverrides: withIndent,
  handlers: {
    onKeyDown: onKeyDownIndent
  },
  options: {
    offset: 24,
    unit: 'px'
  },
  then: (editor, {
    options: {
      offset,
      unit
    } = {}
  }) => ({
    inject: {
      props: {
        nodeKey: KEY_INDENT,
        styleKey: 'marginLeft',
        validTypes: [plateCore.getPluginType(editor, plateCore.ELEMENT_DEFAULT)],
        transformNodeValue: ({
          nodeValue
        }) => {
          return nodeValue * offset + unit;
        }
      }
    }
  })
});

exports.KEY_INDENT = KEY_INDENT;
exports.createIndentPlugin = createIndentPlugin;
exports.indent = indent;
exports.onKeyDownIndent = onKeyDownIndent;
exports.outdent = outdent;
exports.setIndent = setIndent;
exports.withIndent = withIndent;
//# sourceMappingURL=index.js.map
