{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compile = void 0;\n\nvar boolbase_1 = require(\"boolbase\");\n/**\r\n * Returns a function that checks if an elements index matches the given rule\r\n * highly optimized to return the fastest solution.\r\n *\r\n * @param parsed A tuple [a, b], as returned by `parse`.\r\n * @returns A highly optimized function that returns whether an index matches the nth-check.\r\n * @example\r\n * const check = nthCheck.compile([2, 3]);\r\n *\r\n * check(0); // `false`\r\n * check(1); // `false`\r\n * check(2); // `true`\r\n * check(3); // `false`\r\n * check(4); // `true`\r\n * check(5); // `false`\r\n * check(6); // `true`\r\n */\n\n\nfunction compile(parsed) {\n  var a = parsed[0]; // Subtract 1 from `b`, to convert from one- to zero-indexed.\n\n  var b = parsed[1] - 1;\n  /*\r\n   * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.\r\n   * Besides, the specification states that no elements are\r\n   * matched when `a` and `b` are 0.\r\n   *\r\n   * `b < 0` here as we subtracted 1 from `b` above.\r\n   */\n\n  if (b < 0 && a <= 0) return boolbase_1.falseFunc; // When `a` is in the range -1..1, it matches any element (so only `b` is checked).\n\n  if (a === -1) return function (index) {\n    return index <= b;\n  };\n  if (a === 0) return function (index) {\n    return index === b;\n  }; // When `b <= 0` and `a === 1`, they match any element.\n\n  if (a === 1) return b < 0 ? boolbase_1.trueFunc : function (index) {\n    return index >= b;\n  };\n  /*\r\n   * Otherwise, modulo can be used to check if there is a match.\r\n   *\r\n   * Modulo doesn't care about the sign, so let's use `a`s absolute value.\r\n   */\n\n  var absA = Math.abs(a); // Get `b mod a`, + a if this is negative.\n\n  var bMod = (b % absA + absA) % absA;\n  return a > 1 ? function (index) {\n    return index >= b && index % absA === bMod;\n  } : function (index) {\n    return index <= b && index % absA === bMod;\n  };\n}\n\nexports.compile = compile;","map":{"version":3,"sources":["C:/Users/ghdus/OneDrive/바탕 화면/team-project/nlp-project-team2/frontend/node_modules/cheerio-select/node_modules/nth-check/lib/compile.js"],"names":["Object","defineProperty","exports","value","compile","boolbase_1","require","parsed","a","b","falseFunc","index","trueFunc","absA","Math","abs","bMod"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AACA,IAAIC,UAAU,GAAGC,OAAO,CAAC,UAAD,CAAxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,OAAT,CAAiBG,MAAjB,EAAyB;AACrB,MAAIC,CAAC,GAAGD,MAAM,CAAC,CAAD,CAAd,CADqB,CAErB;;AACA,MAAIE,CAAC,GAAGF,MAAM,CAAC,CAAD,CAAN,GAAY,CAApB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI,MAAIE,CAAC,GAAG,CAAJ,IAASD,CAAC,IAAI,CAAlB,EACI,OAAOH,UAAU,CAACK,SAAlB,CAZiB,CAarB;;AACA,MAAIF,CAAC,KAAK,CAAC,CAAX,EACI,OAAO,UAAUG,KAAV,EAAiB;AAAE,WAAOA,KAAK,IAAIF,CAAhB;AAAoB,GAA9C;AACJ,MAAID,CAAC,KAAK,CAAV,EACI,OAAO,UAAUG,KAAV,EAAiB;AAAE,WAAOA,KAAK,KAAKF,CAAjB;AAAqB,GAA/C,CAjBiB,CAkBrB;;AACA,MAAID,CAAC,KAAK,CAAV,EACI,OAAOC,CAAC,GAAG,CAAJ,GAAQJ,UAAU,CAACO,QAAnB,GAA8B,UAAUD,KAAV,EAAiB;AAAE,WAAOA,KAAK,IAAIF,CAAhB;AAAoB,GAA5E;AACJ;AACJ;AACA;AACA;AACA;;AACI,MAAII,IAAI,GAAGC,IAAI,CAACC,GAAL,CAASP,CAAT,CAAX,CA1BqB,CA2BrB;;AACA,MAAIQ,IAAI,GAAG,CAAEP,CAAC,GAAGI,IAAL,GAAaA,IAAd,IAAsBA,IAAjC;AACA,SAAOL,CAAC,GAAG,CAAJ,GACD,UAAUG,KAAV,EAAiB;AAAE,WAAOA,KAAK,IAAIF,CAAT,IAAcE,KAAK,GAAGE,IAAR,KAAiBG,IAAtC;AAA6C,GAD/D,GAED,UAAUL,KAAV,EAAiB;AAAE,WAAOA,KAAK,IAAIF,CAAT,IAAcE,KAAK,GAAGE,IAAR,KAAiBG,IAAtC;AAA6C,GAFtE;AAGH;;AACDd,OAAO,CAACE,OAAR,GAAkBA,OAAlB","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.compile = void 0;\r\nvar boolbase_1 = require(\"boolbase\");\r\n/**\r\n * Returns a function that checks if an elements index matches the given rule\r\n * highly optimized to return the fastest solution.\r\n *\r\n * @param parsed A tuple [a, b], as returned by `parse`.\r\n * @returns A highly optimized function that returns whether an index matches the nth-check.\r\n * @example\r\n * const check = nthCheck.compile([2, 3]);\r\n *\r\n * check(0); // `false`\r\n * check(1); // `false`\r\n * check(2); // `true`\r\n * check(3); // `false`\r\n * check(4); // `true`\r\n * check(5); // `false`\r\n * check(6); // `true`\r\n */\r\nfunction compile(parsed) {\r\n    var a = parsed[0];\r\n    // Subtract 1 from `b`, to convert from one- to zero-indexed.\r\n    var b = parsed[1] - 1;\r\n    /*\r\n     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.\r\n     * Besides, the specification states that no elements are\r\n     * matched when `a` and `b` are 0.\r\n     *\r\n     * `b < 0` here as we subtracted 1 from `b` above.\r\n     */\r\n    if (b < 0 && a <= 0)\r\n        return boolbase_1.falseFunc;\r\n    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).\r\n    if (a === -1)\r\n        return function (index) { return index <= b; };\r\n    if (a === 0)\r\n        return function (index) { return index === b; };\r\n    // When `b <= 0` and `a === 1`, they match any element.\r\n    if (a === 1)\r\n        return b < 0 ? boolbase_1.trueFunc : function (index) { return index >= b; };\r\n    /*\r\n     * Otherwise, modulo can be used to check if there is a match.\r\n     *\r\n     * Modulo doesn't care about the sign, so let's use `a`s absolute value.\r\n     */\r\n    var absA = Math.abs(a);\r\n    // Get `b mod a`, + a if this is negative.\r\n    var bMod = ((b % absA) + absA) % absA;\r\n    return a > 1\r\n        ? function (index) { return index >= b && index % absA === bMod; }\r\n        : function (index) { return index <= b && index % absA === bMod; };\r\n}\r\nexports.compile = compile;\r\n"]},"metadata":{},"sourceType":"script"}