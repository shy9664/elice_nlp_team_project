{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = void 0;\n/*\r\n * Pseudo selectors\r\n *\r\n * Pseudo selectors are available in three forms:\r\n *\r\n * 1. Filters are called when the selector is compiled and return a function\r\n *  that has to return either false, or the results of `next()`.\r\n * 2. Pseudos are called on execution. They have to return a boolean.\r\n * 3. Subselects work like filters, but have an embedded selector that will be run separately.\r\n *\r\n * Filters are great if you want to do some pre-processing, or change the call order\r\n * of `next()` and your code.\r\n * Pseudos should be used to implement simple checks.\r\n */\n\nvar boolbase_1 = require(\"boolbase\");\n\nvar css_what_1 = require(\"css-what\");\n\nvar filters_1 = require(\"./filters\");\n\nObject.defineProperty(exports, \"filters\", {\n  enumerable: true,\n  get: function () {\n    return filters_1.filters;\n  }\n});\n\nvar pseudos_1 = require(\"./pseudos\");\n\nObject.defineProperty(exports, \"pseudos\", {\n  enumerable: true,\n  get: function () {\n    return pseudos_1.pseudos;\n  }\n});\n\nvar aliases_1 = require(\"./aliases\");\n\nObject.defineProperty(exports, \"aliases\", {\n  enumerable: true,\n  get: function () {\n    return aliases_1.aliases;\n  }\n});\n\nvar subselects_1 = require(\"./subselects\");\n\nfunction compilePseudoSelector(next, selector, options, context, compileToken) {\n  var name = selector.name,\n      data = selector.data;\n\n  if (Array.isArray(data)) {\n    return subselects_1.subselects[name](next, data, options, context, compileToken);\n  }\n\n  if (name in aliases_1.aliases) {\n    if (data != null) {\n      throw new Error(\"Pseudo \" + name + \" doesn't have any arguments\");\n    } // The alias has to be parsed here, to make sure options are respected.\n\n\n    var alias = css_what_1.parse(aliases_1.aliases[name], options);\n    return subselects_1.subselects.is(next, alias, options, context, compileToken);\n  }\n\n  if (name in filters_1.filters) {\n    return filters_1.filters[name](next, data, options, context);\n  }\n\n  if (name in pseudos_1.pseudos) {\n    var pseudo_1 = pseudos_1.pseudos[name];\n    pseudos_1.verifyPseudoArgs(pseudo_1, name, data);\n    return pseudo_1 === boolbase_1.falseFunc ? boolbase_1.falseFunc : next === boolbase_1.trueFunc ? function (elem) {\n      return pseudo_1(elem, options, data);\n    } : function (elem) {\n      return pseudo_1(elem, options, data) && next(elem);\n    };\n  }\n\n  throw new Error(\"unmatched pseudo-class :\" + name);\n}\n\nexports.compilePseudoSelector = compilePseudoSelector;","map":{"version":3,"sources":["C:/Users/ghdus/OneDrive/바탕 화면/team-project/nlp-project-team2/frontend/node_modules/cheerio-select/node_modules/css-select/lib/pseudo-selectors/index.js"],"names":["Object","defineProperty","exports","value","compilePseudoSelector","aliases","pseudos","filters","boolbase_1","require","css_what_1","filters_1","enumerable","get","pseudos_1","aliases_1","subselects_1","next","selector","options","context","compileToken","name","data","Array","isArray","subselects","Error","alias","parse","is","pseudo_1","verifyPseudoArgs","falseFunc","trueFunc","elem"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = void 0;\r\n/*\r\n * Pseudo selectors\r\n *\r\n * Pseudo selectors are available in three forms:\r\n *\r\n * 1. Filters are called when the selector is compiled and return a function\r\n *  that has to return either false, or the results of `next()`.\r\n * 2. Pseudos are called on execution. They have to return a boolean.\r\n * 3. Subselects work like filters, but have an embedded selector that will be run separately.\r\n *\r\n * Filters are great if you want to do some pre-processing, or change the call order\r\n * of `next()` and your code.\r\n * Pseudos should be used to implement simple checks.\r\n */\r\nvar boolbase_1 = require(\"boolbase\");\r\nvar css_what_1 = require(\"css-what\");\r\nvar filters_1 = require(\"./filters\");\r\nObject.defineProperty(exports, \"filters\", { enumerable: true, get: function () { return filters_1.filters; } });\r\nvar pseudos_1 = require(\"./pseudos\");\r\nObject.defineProperty(exports, \"pseudos\", { enumerable: true, get: function () { return pseudos_1.pseudos; } });\r\nvar aliases_1 = require(\"./aliases\");\r\nObject.defineProperty(exports, \"aliases\", { enumerable: true, get: function () { return aliases_1.aliases; } });\r\nvar subselects_1 = require(\"./subselects\");\r\nfunction compilePseudoSelector(next, selector, options, context, compileToken) {\r\n    var name = selector.name, data = selector.data;\r\n    if (Array.isArray(data)) {\r\n        return subselects_1.subselects[name](next, data, options, context, compileToken);\r\n    }\r\n    if (name in aliases_1.aliases) {\r\n        if (data != null) {\r\n            throw new Error(\"Pseudo \" + name + \" doesn't have any arguments\");\r\n        }\r\n        // The alias has to be parsed here, to make sure options are respected.\r\n        var alias = css_what_1.parse(aliases_1.aliases[name], options);\r\n        return subselects_1.subselects.is(next, alias, options, context, compileToken);\r\n    }\r\n    if (name in filters_1.filters) {\r\n        return filters_1.filters[name](next, data, options, context);\r\n    }\r\n    if (name in pseudos_1.pseudos) {\r\n        var pseudo_1 = pseudos_1.pseudos[name];\r\n        pseudos_1.verifyPseudoArgs(pseudo_1, name, data);\r\n        return pseudo_1 === boolbase_1.falseFunc\r\n            ? boolbase_1.falseFunc\r\n            : next === boolbase_1.trueFunc\r\n                ? function (elem) { return pseudo_1(elem, options, data); }\r\n                : function (elem) { return pseudo_1(elem, options, data) && next(elem); };\r\n    }\r\n    throw new Error(\"unmatched pseudo-class :\" + name);\r\n}\r\nexports.compilePseudoSelector = compilePseudoSelector;\r\n"]},"metadata":{},"sourceType":"script"}