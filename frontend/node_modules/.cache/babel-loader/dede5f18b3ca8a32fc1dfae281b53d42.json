{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar react = require('react');\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar hasInitialValue = function hasInitialValue(atom) {\n  return 'init' in atom;\n};\n\nvar IS_EQUAL_PROMISE = Symbol();\nvar INTERRUPT_PROMISE = Symbol();\n\nvar isInterruptablePromise = function isInterruptablePromise(promise) {\n  return !!promise[IS_EQUAL_PROMISE];\n};\n\nvar createInterruptablePromise = function createInterruptablePromise(promise) {\n  var interrupt;\n  var interruptablePromise = new Promise(function (resolve, reject) {\n    interrupt = function interrupt() {\n      interruptablePromise[INTERRUPT_PROMISE] = undefined;\n      resolve();\n    };\n\n    promise.then(interrupt, reject);\n  });\n\n  interruptablePromise[IS_EQUAL_PROMISE] = function (p) {\n    return interruptablePromise === p || promise === p || isInterruptablePromise(promise) && promise[IS_EQUAL_PROMISE](p);\n  };\n\n  interruptablePromise[INTERRUPT_PROMISE] = interrupt;\n  return interruptablePromise;\n};\n\nvar READ_ATOM = 'r';\nvar WRITE_ATOM = 'w';\nvar COMMIT_ATOM = 'c';\nvar SUBSCRIBE_ATOM = 's';\nvar RESTORE_ATOMS = 'h';\nvar DEV_SUBSCRIBE_STATE = 'n';\nvar DEV_GET_MOUNTED_ATOMS = 'l';\nvar DEV_GET_ATOM_STATE = 'a';\nvar DEV_GET_MOUNTED = 'm';\n\nvar createStore = function createStore(initialValues) {\n  var _ref4;\n\n  var atomStateMap = new WeakMap();\n  var mountedMap = new WeakMap();\n  var pendingMap = new Map();\n  var stateListeners;\n  var mountedAtoms;\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    stateListeners = new Set();\n    mountedAtoms = new Set();\n  }\n\n  if (initialValues) {\n    for (var _iterator = _createForOfIteratorHelperLoose(initialValues), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n          atom = _step$value[0],\n          value = _step$value[1];\n      var atomState = {\n        v: value,\n        r: 0,\n        d: new Map()\n      };\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        Object.freeze(atomState);\n\n        if (!hasInitialValue(atom)) {\n          console.warn('Found initial value for derived atom which can cause unexpected behavior', atom);\n        }\n      }\n\n      atomStateMap.set(atom, atomState);\n    }\n  }\n\n  var getAtomState = function getAtomState(atom) {\n    return atomStateMap.get(atom);\n  };\n\n  var setAtomState = function setAtomState(atom, atomState) {\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      Object.freeze(atomState);\n    }\n\n    var prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n  };\n\n  var prepareNextAtomState = function prepareNextAtomState(atom, dependencies) {\n    var atomState = getAtomState(atom);\n\n    var nextAtomState = _extends({\n      r: 0\n    }, atomState, {\n      d: dependencies ? new Map(Array.from(dependencies).map(function (a) {\n        var _getAtomState$r, _getAtomState;\n\n        return [a, (_getAtomState$r = (_getAtomState = getAtomState(a)) == null ? void 0 : _getAtomState.r) != null ? _getAtomState$r : 0];\n      })) : (atomState == null ? void 0 : atomState.d) || new Map()\n    });\n\n    return nextAtomState;\n  };\n\n  var setAtomValue = function setAtomValue(atom, value, dependencies, promise) {\n    var _atomState$p;\n\n    var atomState = prepareNextAtomState(atom, dependencies);\n\n    if (promise && !((_atomState$p = atomState.p) != null && _atomState$p[IS_EQUAL_PROMISE](promise))) {\n      return;\n    }\n\n    atomState.c == null ? void 0 : atomState.c();\n\n    if ('e' in atomState || atomState.p || !('v' in atomState) || !Object.is(atomState.v, value)) {\n      ++atomState.r;\n\n      if (atomState.d.has(atom)) {\n        atomState.d.set(atom, atomState.r);\n      }\n    }\n\n    atomState.v = value;\n    delete atomState.e;\n    delete atomState.p;\n    delete atomState.c;\n    delete atomState.i;\n    setAtomState(atom, atomState);\n  };\n\n  var setAtomReadError = function setAtomReadError(atom, error, dependencies, promise) {\n    var _atomState$p2;\n\n    var atomState = prepareNextAtomState(atom, dependencies);\n\n    if (promise && !((_atomState$p2 = atomState.p) != null && _atomState$p2[IS_EQUAL_PROMISE](promise))) {\n      return;\n    }\n\n    atomState.c == null ? void 0 : atomState.c();\n    delete atomState.p;\n    delete atomState.c;\n    delete atomState.i;\n    atomState.e = error;\n    setAtomState(atom, atomState);\n  };\n\n  var setAtomReadPromise = function setAtomReadPromise(atom, promise, dependencies) {\n    var _atomState$p3;\n\n    var atomState = prepareNextAtomState(atom, dependencies);\n\n    if ((_atomState$p3 = atomState.p) != null && _atomState$p3[IS_EQUAL_PROMISE](promise)) {\n      return;\n    }\n\n    atomState.c == null ? void 0 : atomState.c();\n    delete atomState.e;\n    var interruptablePromise = createInterruptablePromise(promise);\n    atomState.p = interruptablePromise;\n    atomState.c = interruptablePromise[INTERRUPT_PROMISE];\n    delete atomState.i;\n    setAtomState(atom, atomState);\n  };\n\n  var setAtomInvalidated = function setAtomInvalidated(atom) {\n    var atomState = prepareNextAtomState(atom);\n    atomState.i = atomState.r;\n    setAtomState(atom, atomState);\n  };\n\n  var readAtomState = function readAtomState(atom, force) {\n    if (!force) {\n      var _atomState = getAtomState(atom);\n\n      if (_atomState) {\n        _atomState.d.forEach(function (_, a) {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(a);\n            } else {\n              var aState = getAtomState(a);\n\n              if (aState && aState.r === aState.i) {\n                readAtomState(a, true);\n              }\n            }\n          }\n        });\n\n        if (Array.from(_atomState.d.entries()).every(function (_ref) {\n          var a = _ref[0],\n              r = _ref[1];\n          var aState = getAtomState(a);\n          return aState && !('e' in aState) && !aState.p && aState.r !== aState.i && aState.r === r;\n        })) {\n          return _atomState;\n        }\n      }\n    }\n\n    var error;\n    var promise;\n    var value;\n    var dependencies = new Set();\n\n    try {\n      var promiseOrValue = atom.read(function (a) {\n        dependencies.add(a);\n        var aState = a === atom ? getAtomState(a) : readAtomState(a);\n\n        if (aState) {\n          if ('e' in aState) {\n            throw aState.e;\n          }\n\n          if (aState.p) {\n            throw aState.p;\n          }\n\n          return aState.v;\n        }\n\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n\n        throw new Error('no atom init');\n      });\n\n      if (promiseOrValue instanceof Promise) {\n        promise = promiseOrValue.then(function (value) {\n          setAtomValue(atom, value, dependencies, promise);\n          flushPending();\n        }).catch(function (e) {\n          if (e instanceof Promise) {\n            if (!isInterruptablePromise(e) || !e[INTERRUPT_PROMISE]) {\n              e.finally(function () {\n                return readAtomState(atom, true);\n              });\n            }\n\n            return e;\n          }\n\n          setAtomReadError(atom, e, dependencies, promise);\n          flushPending();\n        });\n      } else {\n        value = promiseOrValue;\n      }\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        promise = errorOrPromise;\n      } else {\n        error = errorOrPromise;\n      }\n    }\n\n    if (error) {\n      setAtomReadError(atom, error, dependencies);\n    } else if (promise) {\n      setAtomReadPromise(atom, promise, dependencies);\n    } else {\n      setAtomValue(atom, value, dependencies);\n    }\n\n    return getAtomState(atom);\n  };\n\n  var readAtom = function readAtom(readingAtom) {\n    var atomState = readAtomState(readingAtom);\n    return atomState;\n  };\n\n  var addAtom = function addAtom(addingAtom) {\n    var mounted = mountedMap.get(addingAtom);\n\n    if (!mounted) {\n      mounted = mountAtom(addingAtom);\n    }\n\n    return mounted;\n  };\n\n  var canUnmountAtom = function canUnmountAtom(atom, mounted) {\n    return !mounted.l.size && (!mounted.d.size || mounted.d.size === 1 && mounted.d.has(atom));\n  };\n\n  var delAtom = function delAtom(deletingAtom) {\n    var mounted = mountedMap.get(deletingAtom);\n\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(deletingAtom);\n    }\n  };\n\n  var invalidateDependents = function invalidateDependents(atom) {\n    var mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.d.forEach(function (dependent) {\n      if (dependent === atom) {\n        return;\n      }\n\n      setAtomInvalidated(dependent);\n      invalidateDependents(dependent);\n    });\n  };\n\n  var writeAtomState = function writeAtomState(atom, update) {\n    var writeGetter = function writeGetter(a, options) {\n      if (typeof options === 'boolean') {\n        console.warn('[DEPRECATED] Please use { unstable_promise: true }');\n        options = {\n          unstable_promise: options\n        };\n      }\n\n      var aState = readAtomState(a);\n\n      if ('e' in aState) {\n        throw aState.e;\n      }\n\n      if (aState.p) {\n        var _options;\n\n        if ((_options = options) != null && _options.unstable_promise) {\n          return aState.p.then(function () {\n            return writeGetter(a, options);\n          });\n        }\n\n        if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n          console.info('Reading pending atom state in write operation. We throw a promise for now.', a);\n        }\n\n        throw aState.p;\n      }\n\n      if ('v' in aState) {\n        return aState.v;\n      }\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        console.warn('[Bug] no value found while reading atom in write operation. This is probably a bug.', a);\n      }\n\n      throw new Error('no value found');\n    };\n\n    var setter = function setter(a, v) {\n      var promiseOrVoid;\n\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error('atom not writable');\n        }\n\n        if (v instanceof Promise) {\n          promiseOrVoid = v.then(function (resolvedValue) {\n            setAtomValue(a, resolvedValue);\n            invalidateDependents(a);\n            flushPending();\n          }).catch(function (e) {\n            setAtomReadError(atom, e);\n            flushPending();\n          });\n          setAtomReadPromise(atom, promiseOrVoid);\n        } else {\n          setAtomValue(a, v);\n        }\n\n        invalidateDependents(a);\n        flushPending();\n      } else {\n        promiseOrVoid = writeAtomState(a, v);\n      }\n\n      return promiseOrVoid;\n    };\n\n    var promiseOrVoid = atom.write(writeGetter, setter, update);\n    flushPending();\n    return promiseOrVoid;\n  };\n\n  var writeAtom = function writeAtom(writingAtom, update) {\n    var promiseOrVoid = writeAtomState(writingAtom, update);\n    return promiseOrVoid;\n  };\n\n  var isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\n    return !!atom.write;\n  };\n\n  var mountAtom = function mountAtom(atom, initialDependent) {\n    var mounted = {\n      d: new Set(initialDependent && [initialDependent]),\n      l: new Set()\n    };\n    mountedMap.set(atom, mounted);\n\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      mountedAtoms.add(atom);\n    }\n\n    var atomState = readAtomState(atom);\n    atomState.d.forEach(function (_, a) {\n      if (a !== atom) {\n        var aMounted = mountedMap.get(a);\n\n        if (aMounted) {\n          aMounted.d.add(atom);\n        } else {\n          mountAtom(a, atom);\n        }\n      }\n    });\n\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      var setAtom = function setAtom(update) {\n        return writeAtom(atom, update);\n      };\n\n      var onUnmount = atom.onMount(setAtom);\n\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n\n    return mounted;\n  };\n\n  var unmountAtom = function unmountAtom(atom) {\n    var _mountedMap$get;\n\n    var onUnmount = (_mountedMap$get = mountedMap.get(atom)) == null ? void 0 : _mountedMap$get.u;\n\n    if (onUnmount) {\n      onUnmount();\n    }\n\n    mountedMap.delete(atom);\n\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      mountedAtoms.delete(atom);\n    }\n\n    var atomState = getAtomState(atom);\n\n    if (atomState) {\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom) {\n          var mounted = mountedMap.get(a);\n\n          if (mounted) {\n            mounted.d.delete(atom);\n\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      console.warn('[Bug] could not find atom state to unmount', atom);\n    }\n  };\n\n  var mountDependencies = function mountDependencies(atom, atomState, prevReadDependencies) {\n    var dependencies = new Set(atomState.d.keys());\n    prevReadDependencies.forEach(function (_, a) {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n\n      var mounted = mountedMap.get(a);\n\n      if (mounted) {\n        mounted.d.delete(atom);\n\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    dependencies.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n\n      if (mounted) {\n        mounted.d.add(atom);\n      } else {\n        mountAtom(a, atom);\n      }\n    });\n  };\n\n  var flushPending = function flushPending() {\n    var pending = Array.from(pendingMap);\n    pendingMap.clear();\n    pending.forEach(function (_ref2) {\n      var atom = _ref2[0],\n          prevAtomState = _ref2[1];\n      var atomState = getAtomState(atom);\n\n      if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n        mountDependencies(atom, atomState, (prevAtomState == null ? void 0 : prevAtomState.d) || new Map());\n      }\n\n      var mounted = mountedMap.get(atom);\n      mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n        return listener();\n      });\n\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n        stateListeners.forEach(function (l) {\n          return l(atom, !prevAtomState);\n        });\n      }\n    });\n  };\n\n  var commitAtom = function commitAtom(_atom) {\n    flushPending();\n  };\n\n  var subscribeAtom = function subscribeAtom(atom, callback) {\n    var mounted = addAtom(atom);\n    var listeners = mounted.l;\n    listeners.add(callback);\n    return function () {\n      listeners.delete(callback);\n      delAtom(atom);\n    };\n  };\n\n  var restoreAtoms = function restoreAtoms(values) {\n    for (var _iterator2 = _createForOfIteratorHelperLoose(values), _step2; !(_step2 = _iterator2()).done;) {\n      var _step2$value = _step2.value,\n          _atom2 = _step2$value[0],\n          _value = _step2$value[1];\n\n      if (hasInitialValue(_atom2)) {\n        setAtomValue(_atom2, _value);\n        invalidateDependents(_atom2);\n      }\n    }\n\n    flushPending();\n  };\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n    var _ref3;\n\n    return _ref3 = {}, _ref3[READ_ATOM] = readAtom, _ref3[WRITE_ATOM] = writeAtom, _ref3[COMMIT_ATOM] = commitAtom, _ref3[SUBSCRIBE_ATOM] = subscribeAtom, _ref3[RESTORE_ATOMS] = restoreAtoms, _ref3[DEV_SUBSCRIBE_STATE] = function (l) {\n      stateListeners.add(l);\n      return function () {\n        stateListeners.delete(l);\n      };\n    }, _ref3[DEV_GET_MOUNTED_ATOMS] = function () {\n      return mountedAtoms.values();\n    }, _ref3[DEV_GET_ATOM_STATE] = function (a) {\n      return atomStateMap.get(a);\n    }, _ref3[DEV_GET_MOUNTED] = function (a) {\n      return mountedMap.get(a);\n    }, _ref3;\n  }\n\n  return _ref4 = {}, _ref4[READ_ATOM] = readAtom, _ref4[WRITE_ATOM] = writeAtom, _ref4[COMMIT_ATOM] = commitAtom, _ref4[SUBSCRIBE_ATOM] = subscribeAtom, _ref4[RESTORE_ATOMS] = restoreAtoms, _ref4;\n};\n\nvar createScopeContainer = function createScopeContainer(initialValues) {\n  var store = createStore(initialValues);\n  return {\n    s: store\n  };\n};\n\nvar ScopeContextMap = new Map();\n\nvar getScopeContext = function getScopeContext(scope) {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, react.createContext(createScopeContainer()));\n  }\n\n  return ScopeContextMap.get(scope);\n};\n\nvar Provider = function Provider(_ref) {\n  var initialValues = _ref.initialValues,\n      scope = _ref.scope,\n      children = _ref.children;\n  var scopeContainerRef = react.useRef();\n\n  if (!scopeContainerRef.current) {\n    scopeContainerRef.current = createScopeContainer(initialValues);\n  }\n\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test') {\n    useDebugState(scopeContainerRef.current);\n  }\n\n  var ScopeContainerContext = getScopeContext(scope);\n  return react.createElement(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\n\nvar atomToPrintable = function atomToPrintable(atom) {\n  return atom.debugLabel || atom.toString();\n};\n\nvar stateToPrintable = function stateToPrintable(_ref2) {\n  var store = _ref2[0],\n      atoms = _ref2[1];\n  return Object.fromEntries(atoms.flatMap(function (atom) {\n    var _store$DEV_GET_MOUNTE, _store$DEV_GET_ATOM_S;\n\n    var mounted = (_store$DEV_GET_MOUNTE = store[DEV_GET_MOUNTED]) == null ? void 0 : _store$DEV_GET_MOUNTE.call(store, atom);\n\n    if (!mounted) {\n      return [];\n    }\n\n    var dependents = mounted.d;\n    var atomState = ((_store$DEV_GET_ATOM_S = store[DEV_GET_ATOM_STATE]) == null ? void 0 : _store$DEV_GET_ATOM_S.call(store, atom)) || {};\n    return [[atomToPrintable(atom), {\n      value: atomState.e || atomState.p || atomState.v,\n      dependents: Array.from(dependents).map(atomToPrintable)\n    }]];\n  }));\n};\n\nvar useDebugState = function useDebugState(scopeContainer) {\n  var store = scopeContainer.s;\n\n  var _useState = react.useState([]),\n      atoms = _useState[0],\n      setAtoms = _useState[1];\n\n  react.useEffect(function () {\n    var _store$DEV_SUBSCRIBE_;\n\n    var callback = function callback() {\n      var _store$DEV_GET_MOUNTE2;\n\n      setAtoms(Array.from(((_store$DEV_GET_MOUNTE2 = store[DEV_GET_MOUNTED_ATOMS]) == null ? void 0 : _store$DEV_GET_MOUNTE2.call(store)) || []));\n    };\n\n    var unsubscribe = (_store$DEV_SUBSCRIBE_ = store[DEV_SUBSCRIBE_STATE]) == null ? void 0 : _store$DEV_SUBSCRIBE_.call(store, callback);\n    callback();\n    return unsubscribe;\n  }, [store]);\n  react.useDebugValue([store, atoms], stateToPrintable);\n};\n\nvar keyCount = 0;\n\nfunction atom(read, write) {\n  var key = \"atom\" + ++keyCount;\n  var config = {\n    toString: function toString() {\n      return key;\n    }\n  };\n\n  if (typeof read === 'function') {\n    config.read = read;\n  } else {\n    config.init = read;\n\n    config.read = function (get) {\n      return get(config);\n    };\n\n    config.write = function (get, set, update) {\n      return set(config, typeof update === 'function' ? update(get(config)) : update);\n    };\n  }\n\n  if (write) {\n    config.write = write;\n  }\n\n  return config;\n}\n\nvar isWritable = function isWritable(atom) {\n  return !!atom.write;\n};\n\nfunction useAtom(atom, scope) {\n  if ('scope' in atom) {\n    console.warn('atom.scope is deprecated. Please do useAtom(atom, scope) instead.');\n    scope = atom.scope;\n  }\n\n  var ScopeContext = getScopeContext(scope);\n  var store = react.useContext(ScopeContext).s;\n  var getAtomValue = react.useCallback(function () {\n    var atomState = store[READ_ATOM](atom);\n\n    if ('e' in atomState) {\n      throw atomState.e;\n    }\n\n    if (atomState.p) {\n      throw atomState.p;\n    }\n\n    if ('v' in atomState) {\n      return atomState.v;\n    }\n\n    throw new Error('no atom value');\n  }, [store, atom]);\n\n  var _useReducer = react.useReducer(react.useCallback(function (prev) {\n    var nextValue = getAtomValue();\n\n    if (Object.is(prev[0], nextValue) && prev[1] === atom) {\n      return prev;\n    }\n\n    return [nextValue, atom];\n  }, [getAtomValue, atom]), undefined, function () {\n    var initialValue = getAtomValue();\n    return [initialValue, atom];\n  }),\n      _useReducer$ = _useReducer[0],\n      value = _useReducer$[0],\n      atomFromUseReducer = _useReducer$[1],\n      forceUpdate = _useReducer[1];\n\n  if (atomFromUseReducer !== atom) {\n    forceUpdate();\n  }\n\n  react.useEffect(function () {\n    var unsubscribe = store[SUBSCRIBE_ATOM](atom, forceUpdate);\n    forceUpdate();\n    return unsubscribe;\n  }, [store, atom]);\n  react.useEffect(function () {\n    store[COMMIT_ATOM](atom);\n  });\n  var setAtom = react.useCallback(function (update) {\n    if (isWritable(atom)) {\n      return store[WRITE_ATOM](atom, update);\n    } else {\n      throw new Error('not writable atom');\n    }\n  }, [store, atom]);\n  react.useDebugValue(value);\n  return [value, setAtom];\n}\n\nexports.Provider = Provider;\nexports.SECRET_INTERNAL_getScopeContext = getScopeContext;\nexports.atom = atom;\nexports.useAtom = useAtom;","map":{"version":3,"sources":["C:/Users/ghdus/OneDrive/바탕 화면/team-project/nlp-project-team2/frontend/node_modules/jotai/index.js"],"names":["Object","defineProperty","exports","value","react","require","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_unsupportedIterableToArray","o","minLen","_arrayLikeToArray","n","toString","slice","constructor","name","Array","from","test","arr","len","arr2","_createForOfIteratorHelperLoose","allowArrayLike","it","Symbol","iterator","next","bind","isArray","done","TypeError","hasInitialValue","atom","IS_EQUAL_PROMISE","INTERRUPT_PROMISE","isInterruptablePromise","promise","createInterruptablePromise","interrupt","interruptablePromise","Promise","resolve","reject","undefined","then","p","READ_ATOM","WRITE_ATOM","COMMIT_ATOM","SUBSCRIBE_ATOM","RESTORE_ATOMS","DEV_SUBSCRIBE_STATE","DEV_GET_MOUNTED_ATOMS","DEV_GET_ATOM_STATE","DEV_GET_MOUNTED","createStore","initialValues","_ref4","atomStateMap","WeakMap","mountedMap","pendingMap","Map","stateListeners","mountedAtoms","process","env","NODE_ENV","Set","_iterator","_step","_step$value","atomState","v","r","d","freeze","console","warn","set","getAtomState","get","setAtomState","prevAtomState","has","prepareNextAtomState","dependencies","nextAtomState","map","a","_getAtomState$r","_getAtomState","setAtomValue","_atomState$p","c","is","e","setAtomReadError","error","_atomState$p2","setAtomReadPromise","_atomState$p3","setAtomInvalidated","readAtomState","force","_atomState","forEach","_","aState","entries","every","_ref","promiseOrValue","read","add","init","Error","flushPending","catch","finally","errorOrPromise","readAtom","readingAtom","addAtom","addingAtom","mounted","mountAtom","canUnmountAtom","l","size","delAtom","deletingAtom","unmountAtom","invalidateDependents","dependent","writeAtomState","update","writeGetter","options","unstable_promise","_options","info","setter","promiseOrVoid","resolvedValue","write","writeAtom","writingAtom","isActuallyWritableAtom","initialDependent","aMounted","onMount","setAtom","onUnmount","u","_mountedMap$get","delete","mountDependencies","prevReadDependencies","keys","pending","clear","_ref2","listener","commitAtom","_atom","subscribeAtom","callback","listeners","restoreAtoms","values","_iterator2","_step2","_step2$value","_atom2","_value","_ref3","createScopeContainer","store","s","ScopeContextMap","getScopeContext","scope","createContext","Provider","children","scopeContainerRef","useRef","current","useDebugState","ScopeContainerContext","createElement","atomToPrintable","debugLabel","stateToPrintable","atoms","fromEntries","flatMap","_store$DEV_GET_MOUNTE","_store$DEV_GET_ATOM_S","dependents","scopeContainer","_useState","useState","setAtoms","useEffect","_store$DEV_SUBSCRIBE_","_store$DEV_GET_MOUNTE2","unsubscribe","useDebugValue","keyCount","config","isWritable","useAtom","ScopeContext","useContext","getAtomValue","useCallback","_useReducer","useReducer","prev","nextValue","initialValue","_useReducer$","atomFromUseReducer","forceUpdate","SECRET_INTERNAL_getScopeContext"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nObject.defineProperty(exports, '__esModule', { value: true });\r\n\r\nvar react = require('react');\r\n\r\nfunction _extends() {\r\n  _extends = Object.assign || function (target) {\r\n    for (var i = 1; i < arguments.length; i++) {\r\n      var source = arguments[i];\r\n\r\n      for (var key in source) {\r\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n          target[key] = source[key];\r\n        }\r\n      }\r\n    }\r\n\r\n    return target;\r\n  };\r\n\r\n  return _extends.apply(this, arguments);\r\n}\r\n\r\nfunction _unsupportedIterableToArray(o, minLen) {\r\n  if (!o) return;\r\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\r\n  var n = Object.prototype.toString.call(o).slice(8, -1);\r\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\r\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\r\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\r\n}\r\n\r\nfunction _arrayLikeToArray(arr, len) {\r\n  if (len == null || len > arr.length) len = arr.length;\r\n\r\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\r\n\r\n  return arr2;\r\n}\r\n\r\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\r\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\r\n  if (it) return (it = it.call(o)).next.bind(it);\r\n\r\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\r\n    if (it) o = it;\r\n    var i = 0;\r\n    return function () {\r\n      if (i >= o.length) return {\r\n        done: true\r\n      };\r\n      return {\r\n        done: false,\r\n        value: o[i++]\r\n      };\r\n    };\r\n  }\r\n\r\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\r\n}\r\n\r\nvar hasInitialValue = function hasInitialValue(atom) {\r\n  return 'init' in atom;\r\n};\r\n\r\nvar IS_EQUAL_PROMISE = Symbol();\r\nvar INTERRUPT_PROMISE = Symbol();\r\n\r\nvar isInterruptablePromise = function isInterruptablePromise(promise) {\r\n  return !!promise[IS_EQUAL_PROMISE];\r\n};\r\n\r\nvar createInterruptablePromise = function createInterruptablePromise(promise) {\r\n  var interrupt;\r\n  var interruptablePromise = new Promise(function (resolve, reject) {\r\n    interrupt = function interrupt() {\r\n      interruptablePromise[INTERRUPT_PROMISE] = undefined;\r\n      resolve();\r\n    };\r\n\r\n    promise.then(interrupt, reject);\r\n  });\r\n\r\n  interruptablePromise[IS_EQUAL_PROMISE] = function (p) {\r\n    return interruptablePromise === p || promise === p || isInterruptablePromise(promise) && promise[IS_EQUAL_PROMISE](p);\r\n  };\r\n\r\n  interruptablePromise[INTERRUPT_PROMISE] = interrupt;\r\n  return interruptablePromise;\r\n};\r\n\r\nvar READ_ATOM = 'r';\r\nvar WRITE_ATOM = 'w';\r\nvar COMMIT_ATOM = 'c';\r\nvar SUBSCRIBE_ATOM = 's';\r\nvar RESTORE_ATOMS = 'h';\r\nvar DEV_SUBSCRIBE_STATE = 'n';\r\nvar DEV_GET_MOUNTED_ATOMS = 'l';\r\nvar DEV_GET_ATOM_STATE = 'a';\r\nvar DEV_GET_MOUNTED = 'm';\r\nvar createStore = function createStore(initialValues) {\r\n  var _ref4;\r\n\r\n  var atomStateMap = new WeakMap();\r\n  var mountedMap = new WeakMap();\r\n  var pendingMap = new Map();\r\n  var stateListeners;\r\n  var mountedAtoms;\r\n\r\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\r\n    stateListeners = new Set();\r\n    mountedAtoms = new Set();\r\n  }\r\n\r\n  if (initialValues) {\r\n    for (var _iterator = _createForOfIteratorHelperLoose(initialValues), _step; !(_step = _iterator()).done;) {\r\n      var _step$value = _step.value,\r\n          atom = _step$value[0],\r\n          value = _step$value[1];\r\n      var atomState = {\r\n        v: value,\r\n        r: 0,\r\n        d: new Map()\r\n      };\r\n\r\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\r\n        Object.freeze(atomState);\r\n\r\n        if (!hasInitialValue(atom)) {\r\n          console.warn('Found initial value for derived atom which can cause unexpected behavior', atom);\r\n        }\r\n      }\r\n\r\n      atomStateMap.set(atom, atomState);\r\n    }\r\n  }\r\n\r\n  var getAtomState = function getAtomState(atom) {\r\n    return atomStateMap.get(atom);\r\n  };\r\n\r\n  var setAtomState = function setAtomState(atom, atomState) {\r\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\r\n      Object.freeze(atomState);\r\n    }\r\n\r\n    var prevAtomState = atomStateMap.get(atom);\r\n    atomStateMap.set(atom, atomState);\r\n\r\n    if (!pendingMap.has(atom)) {\r\n      pendingMap.set(atom, prevAtomState);\r\n    }\r\n  };\r\n\r\n  var prepareNextAtomState = function prepareNextAtomState(atom, dependencies) {\r\n    var atomState = getAtomState(atom);\r\n\r\n    var nextAtomState = _extends({\r\n      r: 0\r\n    }, atomState, {\r\n      d: dependencies ? new Map(Array.from(dependencies).map(function (a) {\r\n        var _getAtomState$r, _getAtomState;\r\n\r\n        return [a, (_getAtomState$r = (_getAtomState = getAtomState(a)) == null ? void 0 : _getAtomState.r) != null ? _getAtomState$r : 0];\r\n      })) : (atomState == null ? void 0 : atomState.d) || new Map()\r\n    });\r\n\r\n    return nextAtomState;\r\n  };\r\n\r\n  var setAtomValue = function setAtomValue(atom, value, dependencies, promise) {\r\n    var _atomState$p;\r\n\r\n    var atomState = prepareNextAtomState(atom, dependencies);\r\n\r\n    if (promise && !((_atomState$p = atomState.p) != null && _atomState$p[IS_EQUAL_PROMISE](promise))) {\r\n      return;\r\n    }\r\n\r\n    atomState.c == null ? void 0 : atomState.c();\r\n\r\n    if ('e' in atomState || atomState.p || !('v' in atomState) || !Object.is(atomState.v, value)) {\r\n      ++atomState.r;\r\n\r\n      if (atomState.d.has(atom)) {\r\n        atomState.d.set(atom, atomState.r);\r\n      }\r\n    }\r\n\r\n    atomState.v = value;\r\n    delete atomState.e;\r\n    delete atomState.p;\r\n    delete atomState.c;\r\n    delete atomState.i;\r\n    setAtomState(atom, atomState);\r\n  };\r\n\r\n  var setAtomReadError = function setAtomReadError(atom, error, dependencies, promise) {\r\n    var _atomState$p2;\r\n\r\n    var atomState = prepareNextAtomState(atom, dependencies);\r\n\r\n    if (promise && !((_atomState$p2 = atomState.p) != null && _atomState$p2[IS_EQUAL_PROMISE](promise))) {\r\n      return;\r\n    }\r\n\r\n    atomState.c == null ? void 0 : atomState.c();\r\n    delete atomState.p;\r\n    delete atomState.c;\r\n    delete atomState.i;\r\n    atomState.e = error;\r\n    setAtomState(atom, atomState);\r\n  };\r\n\r\n  var setAtomReadPromise = function setAtomReadPromise(atom, promise, dependencies) {\r\n    var _atomState$p3;\r\n\r\n    var atomState = prepareNextAtomState(atom, dependencies);\r\n\r\n    if ((_atomState$p3 = atomState.p) != null && _atomState$p3[IS_EQUAL_PROMISE](promise)) {\r\n      return;\r\n    }\r\n\r\n    atomState.c == null ? void 0 : atomState.c();\r\n    delete atomState.e;\r\n    var interruptablePromise = createInterruptablePromise(promise);\r\n    atomState.p = interruptablePromise;\r\n    atomState.c = interruptablePromise[INTERRUPT_PROMISE];\r\n    delete atomState.i;\r\n    setAtomState(atom, atomState);\r\n  };\r\n\r\n  var setAtomInvalidated = function setAtomInvalidated(atom) {\r\n    var atomState = prepareNextAtomState(atom);\r\n    atomState.i = atomState.r;\r\n    setAtomState(atom, atomState);\r\n  };\r\n\r\n  var readAtomState = function readAtomState(atom, force) {\r\n    if (!force) {\r\n      var _atomState = getAtomState(atom);\r\n\r\n      if (_atomState) {\r\n        _atomState.d.forEach(function (_, a) {\r\n          if (a !== atom) {\r\n            if (!mountedMap.has(a)) {\r\n              readAtomState(a);\r\n            } else {\r\n              var aState = getAtomState(a);\r\n\r\n              if (aState && aState.r === aState.i) {\r\n                readAtomState(a, true);\r\n              }\r\n            }\r\n          }\r\n        });\r\n\r\n        if (Array.from(_atomState.d.entries()).every(function (_ref) {\r\n          var a = _ref[0],\r\n              r = _ref[1];\r\n          var aState = getAtomState(a);\r\n          return aState && !('e' in aState) && !aState.p && aState.r !== aState.i && aState.r === r;\r\n        })) {\r\n          return _atomState;\r\n        }\r\n      }\r\n    }\r\n\r\n    var error;\r\n    var promise;\r\n    var value;\r\n    var dependencies = new Set();\r\n\r\n    try {\r\n      var promiseOrValue = atom.read(function (a) {\r\n        dependencies.add(a);\r\n        var aState = a === atom ? getAtomState(a) : readAtomState(a);\r\n\r\n        if (aState) {\r\n          if ('e' in aState) {\r\n            throw aState.e;\r\n          }\r\n\r\n          if (aState.p) {\r\n            throw aState.p;\r\n          }\r\n\r\n          return aState.v;\r\n        }\r\n\r\n        if (hasInitialValue(a)) {\r\n          return a.init;\r\n        }\r\n\r\n        throw new Error('no atom init');\r\n      });\r\n\r\n      if (promiseOrValue instanceof Promise) {\r\n        promise = promiseOrValue.then(function (value) {\r\n          setAtomValue(atom, value, dependencies, promise);\r\n          flushPending();\r\n        }).catch(function (e) {\r\n          if (e instanceof Promise) {\r\n            if (!isInterruptablePromise(e) || !e[INTERRUPT_PROMISE]) {\r\n              e.finally(function () {\r\n                return readAtomState(atom, true);\r\n              });\r\n            }\r\n\r\n            return e;\r\n          }\r\n\r\n          setAtomReadError(atom, e, dependencies, promise);\r\n          flushPending();\r\n        });\r\n      } else {\r\n        value = promiseOrValue;\r\n      }\r\n    } catch (errorOrPromise) {\r\n      if (errorOrPromise instanceof Promise) {\r\n        promise = errorOrPromise;\r\n      } else {\r\n        error = errorOrPromise;\r\n      }\r\n    }\r\n\r\n    if (error) {\r\n      setAtomReadError(atom, error, dependencies);\r\n    } else if (promise) {\r\n      setAtomReadPromise(atom, promise, dependencies);\r\n    } else {\r\n      setAtomValue(atom, value, dependencies);\r\n    }\r\n\r\n    return getAtomState(atom);\r\n  };\r\n\r\n  var readAtom = function readAtom(readingAtom) {\r\n    var atomState = readAtomState(readingAtom);\r\n    return atomState;\r\n  };\r\n\r\n  var addAtom = function addAtom(addingAtom) {\r\n    var mounted = mountedMap.get(addingAtom);\r\n\r\n    if (!mounted) {\r\n      mounted = mountAtom(addingAtom);\r\n    }\r\n\r\n    return mounted;\r\n  };\r\n\r\n  var canUnmountAtom = function canUnmountAtom(atom, mounted) {\r\n    return !mounted.l.size && (!mounted.d.size || mounted.d.size === 1 && mounted.d.has(atom));\r\n  };\r\n\r\n  var delAtom = function delAtom(deletingAtom) {\r\n    var mounted = mountedMap.get(deletingAtom);\r\n\r\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\r\n      unmountAtom(deletingAtom);\r\n    }\r\n  };\r\n\r\n  var invalidateDependents = function invalidateDependents(atom) {\r\n    var mounted = mountedMap.get(atom);\r\n    mounted == null ? void 0 : mounted.d.forEach(function (dependent) {\r\n      if (dependent === atom) {\r\n        return;\r\n      }\r\n\r\n      setAtomInvalidated(dependent);\r\n      invalidateDependents(dependent);\r\n    });\r\n  };\r\n\r\n  var writeAtomState = function writeAtomState(atom, update) {\r\n    var writeGetter = function writeGetter(a, options) {\r\n      if (typeof options === 'boolean') {\r\n        console.warn('[DEPRECATED] Please use { unstable_promise: true }');\r\n        options = {\r\n          unstable_promise: options\r\n        };\r\n      }\r\n\r\n      var aState = readAtomState(a);\r\n\r\n      if ('e' in aState) {\r\n        throw aState.e;\r\n      }\r\n\r\n      if (aState.p) {\r\n        var _options;\r\n\r\n        if ((_options = options) != null && _options.unstable_promise) {\r\n          return aState.p.then(function () {\r\n            return writeGetter(a, options);\r\n          });\r\n        }\r\n\r\n        if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\r\n          console.info('Reading pending atom state in write operation. We throw a promise for now.', a);\r\n        }\r\n\r\n        throw aState.p;\r\n      }\r\n\r\n      if ('v' in aState) {\r\n        return aState.v;\r\n      }\r\n\r\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\r\n        console.warn('[Bug] no value found while reading atom in write operation. This is probably a bug.', a);\r\n      }\r\n\r\n      throw new Error('no value found');\r\n    };\r\n\r\n    var setter = function setter(a, v) {\r\n      var promiseOrVoid;\r\n\r\n      if (a === atom) {\r\n        if (!hasInitialValue(a)) {\r\n          throw new Error('atom not writable');\r\n        }\r\n\r\n        if (v instanceof Promise) {\r\n          promiseOrVoid = v.then(function (resolvedValue) {\r\n            setAtomValue(a, resolvedValue);\r\n            invalidateDependents(a);\r\n            flushPending();\r\n          }).catch(function (e) {\r\n            setAtomReadError(atom, e);\r\n            flushPending();\r\n          });\r\n          setAtomReadPromise(atom, promiseOrVoid);\r\n        } else {\r\n          setAtomValue(a, v);\r\n        }\r\n\r\n        invalidateDependents(a);\r\n        flushPending();\r\n      } else {\r\n        promiseOrVoid = writeAtomState(a, v);\r\n      }\r\n\r\n      return promiseOrVoid;\r\n    };\r\n\r\n    var promiseOrVoid = atom.write(writeGetter, setter, update);\r\n    flushPending();\r\n    return promiseOrVoid;\r\n  };\r\n\r\n  var writeAtom = function writeAtom(writingAtom, update) {\r\n    var promiseOrVoid = writeAtomState(writingAtom, update);\r\n    return promiseOrVoid;\r\n  };\r\n\r\n  var isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\r\n    return !!atom.write;\r\n  };\r\n\r\n  var mountAtom = function mountAtom(atom, initialDependent) {\r\n    var mounted = {\r\n      d: new Set(initialDependent && [initialDependent]),\r\n      l: new Set()\r\n    };\r\n    mountedMap.set(atom, mounted);\r\n\r\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\r\n      mountedAtoms.add(atom);\r\n    }\r\n\r\n    var atomState = readAtomState(atom);\r\n    atomState.d.forEach(function (_, a) {\r\n      if (a !== atom) {\r\n        var aMounted = mountedMap.get(a);\r\n\r\n        if (aMounted) {\r\n          aMounted.d.add(atom);\r\n        } else {\r\n          mountAtom(a, atom);\r\n        }\r\n      }\r\n    });\r\n\r\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\r\n      var setAtom = function setAtom(update) {\r\n        return writeAtom(atom, update);\r\n      };\r\n\r\n      var onUnmount = atom.onMount(setAtom);\r\n\r\n      if (onUnmount) {\r\n        mounted.u = onUnmount;\r\n      }\r\n    }\r\n\r\n    return mounted;\r\n  };\r\n\r\n  var unmountAtom = function unmountAtom(atom) {\r\n    var _mountedMap$get;\r\n\r\n    var onUnmount = (_mountedMap$get = mountedMap.get(atom)) == null ? void 0 : _mountedMap$get.u;\r\n\r\n    if (onUnmount) {\r\n      onUnmount();\r\n    }\r\n\r\n    mountedMap.delete(atom);\r\n\r\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\r\n      mountedAtoms.delete(atom);\r\n    }\r\n\r\n    var atomState = getAtomState(atom);\r\n\r\n    if (atomState) {\r\n      atomState.d.forEach(function (_, a) {\r\n        if (a !== atom) {\r\n          var mounted = mountedMap.get(a);\r\n\r\n          if (mounted) {\r\n            mounted.d.delete(atom);\r\n\r\n            if (canUnmountAtom(a, mounted)) {\r\n              unmountAtom(a);\r\n            }\r\n          }\r\n        }\r\n      });\r\n    } else if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\r\n      console.warn('[Bug] could not find atom state to unmount', atom);\r\n    }\r\n  };\r\n\r\n  var mountDependencies = function mountDependencies(atom, atomState, prevReadDependencies) {\r\n    var dependencies = new Set(atomState.d.keys());\r\n    prevReadDependencies.forEach(function (_, a) {\r\n      if (dependencies.has(a)) {\r\n        dependencies.delete(a);\r\n        return;\r\n      }\r\n\r\n      var mounted = mountedMap.get(a);\r\n\r\n      if (mounted) {\r\n        mounted.d.delete(atom);\r\n\r\n        if (canUnmountAtom(a, mounted)) {\r\n          unmountAtom(a);\r\n        }\r\n      }\r\n    });\r\n    dependencies.forEach(function (a) {\r\n      var mounted = mountedMap.get(a);\r\n\r\n      if (mounted) {\r\n        mounted.d.add(atom);\r\n      } else {\r\n        mountAtom(a, atom);\r\n      }\r\n    });\r\n  };\r\n\r\n  var flushPending = function flushPending() {\r\n    var pending = Array.from(pendingMap);\r\n    pendingMap.clear();\r\n    pending.forEach(function (_ref2) {\r\n      var atom = _ref2[0],\r\n          prevAtomState = _ref2[1];\r\n      var atomState = getAtomState(atom);\r\n\r\n      if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\r\n        mountDependencies(atom, atomState, (prevAtomState == null ? void 0 : prevAtomState.d) || new Map());\r\n      }\r\n\r\n      var mounted = mountedMap.get(atom);\r\n      mounted == null ? void 0 : mounted.l.forEach(function (listener) {\r\n        return listener();\r\n      });\r\n\r\n      if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\r\n        stateListeners.forEach(function (l) {\r\n          return l(atom, !prevAtomState);\r\n        });\r\n      }\r\n    });\r\n  };\r\n\r\n  var commitAtom = function commitAtom(_atom) {\r\n    flushPending();\r\n  };\r\n\r\n  var subscribeAtom = function subscribeAtom(atom, callback) {\r\n    var mounted = addAtom(atom);\r\n    var listeners = mounted.l;\r\n    listeners.add(callback);\r\n    return function () {\r\n      listeners.delete(callback);\r\n      delAtom(atom);\r\n    };\r\n  };\r\n\r\n  var restoreAtoms = function restoreAtoms(values) {\r\n    for (var _iterator2 = _createForOfIteratorHelperLoose(values), _step2; !(_step2 = _iterator2()).done;) {\r\n      var _step2$value = _step2.value,\r\n          _atom2 = _step2$value[0],\r\n          _value = _step2$value[1];\r\n\r\n      if (hasInitialValue(_atom2)) {\r\n        setAtomValue(_atom2, _value);\r\n        invalidateDependents(_atom2);\r\n      }\r\n    }\r\n\r\n    flushPending();\r\n  };\r\n\r\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\r\n    var _ref3;\r\n\r\n    return _ref3 = {}, _ref3[READ_ATOM] = readAtom, _ref3[WRITE_ATOM] = writeAtom, _ref3[COMMIT_ATOM] = commitAtom, _ref3[SUBSCRIBE_ATOM] = subscribeAtom, _ref3[RESTORE_ATOMS] = restoreAtoms, _ref3[DEV_SUBSCRIBE_STATE] = function (l) {\r\n      stateListeners.add(l);\r\n      return function () {\r\n        stateListeners.delete(l);\r\n      };\r\n    }, _ref3[DEV_GET_MOUNTED_ATOMS] = function () {\r\n      return mountedAtoms.values();\r\n    }, _ref3[DEV_GET_ATOM_STATE] = function (a) {\r\n      return atomStateMap.get(a);\r\n    }, _ref3[DEV_GET_MOUNTED] = function (a) {\r\n      return mountedMap.get(a);\r\n    }, _ref3;\r\n  }\r\n\r\n  return _ref4 = {}, _ref4[READ_ATOM] = readAtom, _ref4[WRITE_ATOM] = writeAtom, _ref4[COMMIT_ATOM] = commitAtom, _ref4[SUBSCRIBE_ATOM] = subscribeAtom, _ref4[RESTORE_ATOMS] = restoreAtoms, _ref4;\r\n};\r\n\r\nvar createScopeContainer = function createScopeContainer(initialValues) {\r\n  var store = createStore(initialValues);\r\n  return {\r\n    s: store\r\n  };\r\n};\r\nvar ScopeContextMap = new Map();\r\nvar getScopeContext = function getScopeContext(scope) {\r\n  if (!ScopeContextMap.has(scope)) {\r\n    ScopeContextMap.set(scope, react.createContext(createScopeContainer()));\r\n  }\r\n\r\n  return ScopeContextMap.get(scope);\r\n};\r\n\r\nvar Provider = function Provider(_ref) {\r\n  var initialValues = _ref.initialValues,\r\n      scope = _ref.scope,\r\n      children = _ref.children;\r\n  var scopeContainerRef = react.useRef();\r\n\r\n  if (!scopeContainerRef.current) {\r\n    scopeContainerRef.current = createScopeContainer(initialValues);\r\n  }\r\n\r\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test') {\r\n    useDebugState(scopeContainerRef.current);\r\n  }\r\n\r\n  var ScopeContainerContext = getScopeContext(scope);\r\n  return react.createElement(ScopeContainerContext.Provider, {\r\n    value: scopeContainerRef.current\r\n  }, children);\r\n};\r\n\r\nvar atomToPrintable = function atomToPrintable(atom) {\r\n  return atom.debugLabel || atom.toString();\r\n};\r\n\r\nvar stateToPrintable = function stateToPrintable(_ref2) {\r\n  var store = _ref2[0],\r\n      atoms = _ref2[1];\r\n  return Object.fromEntries(atoms.flatMap(function (atom) {\r\n    var _store$DEV_GET_MOUNTE, _store$DEV_GET_ATOM_S;\r\n\r\n    var mounted = (_store$DEV_GET_MOUNTE = store[DEV_GET_MOUNTED]) == null ? void 0 : _store$DEV_GET_MOUNTE.call(store, atom);\r\n\r\n    if (!mounted) {\r\n      return [];\r\n    }\r\n\r\n    var dependents = mounted.d;\r\n    var atomState = ((_store$DEV_GET_ATOM_S = store[DEV_GET_ATOM_STATE]) == null ? void 0 : _store$DEV_GET_ATOM_S.call(store, atom)) || {};\r\n    return [[atomToPrintable(atom), {\r\n      value: atomState.e || atomState.p || atomState.v,\r\n      dependents: Array.from(dependents).map(atomToPrintable)\r\n    }]];\r\n  }));\r\n};\r\n\r\nvar useDebugState = function useDebugState(scopeContainer) {\r\n  var store = scopeContainer.s;\r\n\r\n  var _useState = react.useState([]),\r\n      atoms = _useState[0],\r\n      setAtoms = _useState[1];\r\n\r\n  react.useEffect(function () {\r\n    var _store$DEV_SUBSCRIBE_;\r\n\r\n    var callback = function callback() {\r\n      var _store$DEV_GET_MOUNTE2;\r\n\r\n      setAtoms(Array.from(((_store$DEV_GET_MOUNTE2 = store[DEV_GET_MOUNTED_ATOMS]) == null ? void 0 : _store$DEV_GET_MOUNTE2.call(store)) || []));\r\n    };\r\n\r\n    var unsubscribe = (_store$DEV_SUBSCRIBE_ = store[DEV_SUBSCRIBE_STATE]) == null ? void 0 : _store$DEV_SUBSCRIBE_.call(store, callback);\r\n    callback();\r\n    return unsubscribe;\r\n  }, [store]);\r\n  react.useDebugValue([store, atoms], stateToPrintable);\r\n};\r\n\r\nvar keyCount = 0;\r\nfunction atom(read, write) {\r\n  var key = \"atom\" + ++keyCount;\r\n  var config = {\r\n    toString: function toString() {\r\n      return key;\r\n    }\r\n  };\r\n\r\n  if (typeof read === 'function') {\r\n    config.read = read;\r\n  } else {\r\n    config.init = read;\r\n\r\n    config.read = function (get) {\r\n      return get(config);\r\n    };\r\n\r\n    config.write = function (get, set, update) {\r\n      return set(config, typeof update === 'function' ? update(get(config)) : update);\r\n    };\r\n  }\r\n\r\n  if (write) {\r\n    config.write = write;\r\n  }\r\n\r\n  return config;\r\n}\r\n\r\nvar isWritable = function isWritable(atom) {\r\n  return !!atom.write;\r\n};\r\n\r\nfunction useAtom(atom, scope) {\r\n  if ('scope' in atom) {\r\n    console.warn('atom.scope is deprecated. Please do useAtom(atom, scope) instead.');\r\n    scope = atom.scope;\r\n  }\r\n\r\n  var ScopeContext = getScopeContext(scope);\r\n  var store = react.useContext(ScopeContext).s;\r\n  var getAtomValue = react.useCallback(function () {\r\n    var atomState = store[READ_ATOM](atom);\r\n\r\n    if ('e' in atomState) {\r\n      throw atomState.e;\r\n    }\r\n\r\n    if (atomState.p) {\r\n      throw atomState.p;\r\n    }\r\n\r\n    if ('v' in atomState) {\r\n      return atomState.v;\r\n    }\r\n\r\n    throw new Error('no atom value');\r\n  }, [store, atom]);\r\n\r\n  var _useReducer = react.useReducer(react.useCallback(function (prev) {\r\n    var nextValue = getAtomValue();\r\n\r\n    if (Object.is(prev[0], nextValue) && prev[1] === atom) {\r\n      return prev;\r\n    }\r\n\r\n    return [nextValue, atom];\r\n  }, [getAtomValue, atom]), undefined, function () {\r\n    var initialValue = getAtomValue();\r\n    return [initialValue, atom];\r\n  }),\r\n      _useReducer$ = _useReducer[0],\r\n      value = _useReducer$[0],\r\n      atomFromUseReducer = _useReducer$[1],\r\n      forceUpdate = _useReducer[1];\r\n\r\n  if (atomFromUseReducer !== atom) {\r\n    forceUpdate();\r\n  }\r\n\r\n  react.useEffect(function () {\r\n    var unsubscribe = store[SUBSCRIBE_ATOM](atom, forceUpdate);\r\n    forceUpdate();\r\n    return unsubscribe;\r\n  }, [store, atom]);\r\n  react.useEffect(function () {\r\n    store[COMMIT_ATOM](atom);\r\n  });\r\n  var setAtom = react.useCallback(function (update) {\r\n    if (isWritable(atom)) {\r\n      return store[WRITE_ATOM](atom, update);\r\n    } else {\r\n      throw new Error('not writable atom');\r\n    }\r\n  }, [store, atom]);\r\n  react.useDebugValue(value);\r\n  return [value, setAtom];\r\n}\r\n\r\nexports.Provider = Provider;\r\nexports.SECRET_INTERNAL_getScopeContext = getScopeContext;\r\nexports.atom = atom;\r\nexports.useAtom = useAtom;\r\n"]},"metadata":{},"sourceType":"script"}