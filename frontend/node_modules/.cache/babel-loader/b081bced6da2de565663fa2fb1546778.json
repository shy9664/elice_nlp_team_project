{"ast":null,"code":"'use strict';\n\nvar parser = require('slick/parser');\n\nmodule.exports = exports = Selector;\n/**\n * CSS selector constructor.\n *\n * @param {String} selector text\n * @param {Array} optionally, precalculated specificity\n * @api public\n */\n\nfunction Selector(text, styleAttribute) {\n  this.text = text;\n  this.spec = undefined;\n  this.styleAttribute = styleAttribute || false;\n}\n/**\n * Get parsed selector.\n *\n * @api public\n */\n\n\nSelector.prototype.parsed = function () {\n  if (!this.tokens) {\n    this.tokens = parse(this.text);\n  }\n\n  return this.tokens;\n};\n/**\n * Lazy specificity getter\n *\n * @api public\n */\n\n\nSelector.prototype.specificity = function () {\n  var styleAttribute = this.styleAttribute;\n\n  if (!this.spec) {\n    this.spec = specificity(this.text, this.parsed());\n  }\n\n  return this.spec;\n\n  function specificity(text, parsed) {\n    var expressions = parsed || parse(text);\n    var spec = [styleAttribute ? 1 : 0, 0, 0, 0];\n    var nots = [];\n\n    for (var i = 0; i < expressions.length; i++) {\n      var expression = expressions[i];\n      var pseudos = expression.pseudos; // id awards a point in the second column\n\n      if (expression.id) {\n        spec[1]++;\n      } // classes and attributes award a point each in the third column\n\n\n      if (expression.attributes) {\n        spec[2] += expression.attributes.length;\n      }\n\n      if (expression.classList) {\n        spec[2] += expression.classList.length;\n      } // tag awards a point in the fourth column\n\n\n      if (expression.tag && expression.tag !== '*') {\n        spec[3]++;\n      } // pseudos award a point each in the fourth column\n\n\n      if (pseudos) {\n        spec[3] += pseudos.length;\n\n        for (var p = 0; p < pseudos.length; p++) {\n          if (pseudos[p].name === 'not') {\n            nots.push(pseudos[p].value);\n            spec[3]--;\n          }\n        }\n      }\n    }\n\n    for (var ii = nots.length; ii--;) {\n      var not = specificity(nots[ii]);\n\n      for (var jj = 4; jj--;) {\n        spec[jj] += not[jj];\n      }\n    }\n\n    return spec;\n  }\n};\n/**\n * Parses a selector and returns the tokens.\n *\n * @param {String} selector\n * @api private.\n */\n\n\nfunction parse(text) {\n  try {\n    return parser(text)[0];\n  } catch (e) {\n    return [];\n  }\n}","map":{"version":3,"sources":["/Users/hyun/Desktop/33333333/frontend/node_modules/juice/lib/selector.js"],"names":["parser","require","module","exports","Selector","text","styleAttribute","spec","undefined","prototype","parsed","tokens","parse","specificity","expressions","nots","i","length","expression","pseudos","id","attributes","classList","tag","p","name","push","value","ii","not","jj","e"],"mappings":"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","sourcesContent":["'use strict';\n\nvar parser = require('slick/parser');\n\nmodule.exports = exports = Selector;\n\n/**\n * CSS selector constructor.\n *\n * @param {String} selector text\n * @param {Array} optionally, precalculated specificity\n * @api public\n */\n\nfunction Selector(text, styleAttribute) {\n  this.text = text;\n  this.spec = undefined;\n  this.styleAttribute = styleAttribute || false;\n}\n\n/**\n * Get parsed selector.\n *\n * @api public\n */\n\nSelector.prototype.parsed = function() {\n  if (!this.tokens) { this.tokens = parse(this.text); }\n  return this.tokens;\n};\n\n/**\n * Lazy specificity getter\n *\n * @api public\n */\n\nSelector.prototype.specificity = function() {\n  var styleAttribute = this.styleAttribute;\n  if (!this.spec) { this.spec = specificity(this.text, this.parsed()); }\n  return this.spec;\n\n  function specificity(text, parsed) {\n    var expressions = parsed || parse(text);\n    var spec = [styleAttribute ? 1 : 0, 0, 0, 0];\n    var nots = [];\n\n    for (var i = 0; i < expressions.length; i++) {\n      var expression = expressions[i];\n      var pseudos = expression.pseudos;\n\n      // id awards a point in the second column\n      if (expression.id) { spec[1]++; }\n\n      // classes and attributes award a point each in the third column\n      if (expression.attributes) { spec[2] += expression.attributes.length; }\n      if (expression.classList) { spec[2] += expression.classList.length; }\n\n      // tag awards a point in the fourth column\n      if (expression.tag && expression.tag !== '*') { spec[3]++; }\n\n      // pseudos award a point each in the fourth column\n      if (pseudos) {\n        spec[3] += pseudos.length;\n\n        for (var p = 0; p < pseudos.length; p++) {\n          if (pseudos[p].name === 'not') {\n            nots.push(pseudos[p].value);\n            spec[3]--;\n          }\n        }\n      }\n    }\n\n    for (var ii = nots.length; ii--;) {\n      var not = specificity(nots[ii]);\n      for (var jj = 4; jj--;) { spec[jj] += not[jj]; }\n    }\n\n    return spec;\n  }\n};\n\n/**\n * Parses a selector and returns the tokens.\n *\n * @param {String} selector\n * @api private.\n */\n\nfunction parse(text) {\n  try {\n    return parser(text)[0];\n  } catch (e) {\n    return [];\n  }\n}\n"]},"metadata":{},"sourceType":"script"}