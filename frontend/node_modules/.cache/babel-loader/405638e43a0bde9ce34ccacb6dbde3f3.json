{"ast":null,"code":"import { someNode, getPluginType, getParent, getAbove, isCollapsed, isElement, createPluginFactory, findNodePath, ELEMENT_DEFAULT, insertNodes, findNode, setNodes } from '@udecode/plate-core';\nimport { Editor, Path, Transforms, Node, Point } from 'slate';\n\nfunction getCellInNextTableRow(editor, currentRowPath) {\n  try {\n    var _nextRowNode$children;\n\n    const nextRow = Editor.node(editor, Path.next(currentRowPath)); // TODO: Many tables in rich text editors (Google Docs, Word),\n    // add a new row if we're in the last cell. Should we do the same?\n\n    const [nextRowNode, nextRowPath] = nextRow;\n    const nextCell = nextRowNode === null || nextRowNode === void 0 ? void 0 : (_nextRowNode$children = nextRowNode.children) === null || _nextRowNode$children === void 0 ? void 0 : _nextRowNode$children[0];\n    const nextCellPath = nextRowPath.concat(0);\n\n    if (nextCell && nextCellPath) {\n      return Editor.node(editor, nextCellPath);\n    }\n  } catch (err) {}\n}\n\nfunction getNextTableCell(editor, currentCell, currentPath, currentRow) {\n  try {\n    return Editor.node(editor, Path.next(currentPath));\n  } catch (err) {\n    const [, currentRowPath] = currentRow;\n    return getCellInNextTableRow(editor, currentRowPath);\n  }\n}\n\nfunction getCellInPreviousTableRow(editor, currentRowPath) {\n  try {\n    var _previousRowNode$chil;\n\n    const previousRow = Editor.node(editor, Path.previous(currentRowPath));\n    const [previousRowNode, previousRowPath] = previousRow;\n    const previousCell = previousRowNode === null || previousRowNode === void 0 ? void 0 : (_previousRowNode$chil = previousRowNode.children) === null || _previousRowNode$chil === void 0 ? void 0 : _previousRowNode$chil[previousRowNode.children.length - 1];\n    const previousCellPath = previousRowPath.concat(previousRowNode.children.length - 1);\n\n    if (previousCell && previousCellPath) {\n      return Editor.node(editor, previousCellPath);\n    }\n  } catch (err) {}\n}\n\nfunction getPreviousTableCell(editor, currentCell, currentPath, currentRow) {\n  try {\n    return Editor.node(editor, Path.previous(currentPath));\n  } catch (err) {\n    const [, currentRowPath] = currentRow;\n    return getCellInPreviousTableRow(editor, currentRowPath);\n  }\n}\n/**\n * If at (default = selection) is in table>tr>td or table>tr>th,\n * return table, tr, and td or th node entries.\n */\n\n\nconst getTableCellEntry = (editor, {\n  at = editor.selection\n} = {}) => {\n  if (at && someNode(editor, {\n    at,\n    match: {\n      type: [getPluginType(editor, ELEMENT_TD), getPluginType(editor, ELEMENT_TH)]\n    }\n  })) {\n    const selectionParent = getParent(editor, at);\n    if (!selectionParent) return;\n    const [, paragraphPath] = selectionParent;\n    const tableCell = getAbove(editor, {\n      at,\n      match: {\n        type: [getPluginType(editor, ELEMENT_TD), getPluginType(editor, ELEMENT_TH)]\n      }\n    }) || getParent(editor, paragraphPath);\n    if (!tableCell) return;\n    const [tableCellNode, tableCellPath] = tableCell;\n    if (tableCellNode.type !== getPluginType(editor, ELEMENT_TD) && tableCellNode.type !== getPluginType(editor, ELEMENT_TH)) return;\n    const tableRow = getParent(editor, tableCellPath);\n    if (!tableRow) return;\n    const [tableRowNode, tableRowPath] = tableRow;\n    if (tableRowNode.type !== getPluginType(editor, ELEMENT_TR)) return;\n    const tableElement = getParent(editor, tableRowPath);\n    if (!tableElement) return;\n    return {\n      tableElement,\n      tableRow,\n      tableCell\n    };\n  }\n};\n\nconst onKeyDownTable = (editor, {\n  type\n}) => e => {\n  if (e.key === 'Tab') {\n    e.preventDefault();\n    const res = getTableCellEntry(editor, {});\n    if (!res) return;\n    const {\n      tableRow,\n      tableCell\n    } = res;\n    const [, tableCellPath] = tableCell;\n    const shiftTab = e.shiftKey;\n    const tab = !e.shiftKey;\n\n    if (shiftTab) {\n      // move left with shift+tab\n      const previousCell = getPreviousTableCell(editor, tableCell, tableCellPath, tableRow);\n\n      if (previousCell) {\n        const [, previousCellPath] = previousCell;\n        Transforms.select(editor, previousCellPath);\n      }\n    } else if (tab) {\n      // move right with tab\n      const nextCell = getNextTableCell(editor, tableCell, tableCellPath, tableRow);\n\n      if (nextCell) {\n        const [, nextCellPath] = nextCell;\n        Transforms.select(editor, nextCellPath);\n      }\n    }\n  } // FIXME: would prefer this as mod+a, but doesn't work\n\n\n  if (e.key === 'a' && (e.metaKey || e.ctrlKey)) {\n    const res = getAbove(editor, {\n      match: {\n        type\n      }\n    });\n    if (!res) return;\n    const [, tablePath] = res; // select the whole table\n\n    Transforms.select(editor, tablePath);\n    e.preventDefault();\n    e.stopPropagation();\n  }\n};\n\nconst withTable = editor => {\n  const matchCells = node => {\n    return isElement(node) && (node.type === getPluginType(editor, ELEMENT_TD) || node.type === getPluginType(editor, ELEMENT_TH));\n  };\n\n  const {\n    deleteBackward,\n    deleteForward,\n    deleteFragment,\n    insertText\n  } = editor;\n\n  const preventDeleteCell = (operation, pointCallback, nextPoint) => unit => {\n    const {\n      selection\n    } = editor;\n\n    if (isCollapsed(selection)) {\n      const [cell] = Editor.nodes(editor, {\n        match: matchCells\n      });\n\n      if (cell) {\n        // Prevent deletions within a cell\n        const [, cellPath] = cell;\n        const start = pointCallback(editor, cellPath);\n\n        if (selection && Point.equals(selection.anchor, start)) {\n          return;\n        }\n      } else {\n        // Prevent deleting cell when selection is before or after a table\n        const next = nextPoint(editor, selection, {\n          unit\n        });\n        const [nextCell] = Editor.nodes(editor, {\n          match: matchCells,\n          at: next\n        });\n        if (nextCell) return;\n      }\n    }\n\n    operation(unit);\n  };\n\n  editor.deleteFragment = () => {\n    const {\n      selection\n    } = editor;\n    const [start] = Editor.nodes(editor, {\n      match: matchCells,\n      at: selection === null || selection === void 0 ? void 0 : selection.anchor.path\n    });\n    const [end] = Editor.nodes(editor, {\n      match: matchCells,\n      at: selection === null || selection === void 0 ? void 0 : selection.focus.path\n    }); // Skip deletes if they start or end in a table cell, unless start & end in the same cell\n\n    if ((start || end) && (start === null || start === void 0 ? void 0 : start[0]) !== (end === null || end === void 0 ? void 0 : end[0])) {\n      // Clear cells content\n      const cells = Editor.nodes(editor, {\n        match: matchCells\n      });\n\n      for (const [, path] of cells) {\n        for (const [, childPath] of Node.children(editor, path, {\n          reverse: true\n        })) {\n          Transforms.removeNodes(editor, {\n            at: childPath\n          });\n        }\n      }\n\n      Transforms.collapse(editor);\n      return;\n    }\n\n    deleteFragment();\n  };\n\n  editor.insertText = text => {\n    const {\n      selection\n    } = editor;\n    const [start] = Editor.nodes(editor, {\n      match: matchCells,\n      at: selection === null || selection === void 0 ? void 0 : selection.anchor.path\n    });\n    const [end] = Editor.nodes(editor, {\n      match: matchCells,\n      at: selection === null || selection === void 0 ? void 0 : selection.focus.path\n    }); // Collapse selection if multiple cells are selected to avoid breaking the table\n\n    if (!isCollapsed(selection) && (start || end) && (start === null || start === void 0 ? void 0 : start[0]) !== (end === null || end === void 0 ? void 0 : end[0])) {\n      const [cell] = Editor.nodes(editor, {\n        match: matchCells\n      });\n\n      if (cell) {\n        Transforms.collapse(editor, {\n          edge: 'end'\n        });\n        insertText(text);\n        return;\n      }\n    }\n\n    insertText(text);\n  }; // prevent deleting cells with deleteBackward\n\n\n  editor.deleteBackward = preventDeleteCell(deleteBackward, Editor.start, Editor.before); // prevent deleting cells with deleteForward\n\n  editor.deleteForward = preventDeleteCell(deleteForward, Editor.end, Editor.after);\n  return editor;\n};\n\nconst ELEMENT_TABLE = 'table';\nconst ELEMENT_TH = 'th';\nconst ELEMENT_TR = 'tr';\nconst ELEMENT_TD = 'td';\n/**\n * Enables support for tables.\n */\n\nconst createTablePlugin = createPluginFactory({\n  key: ELEMENT_TABLE,\n  isElement: true,\n  handlers: {\n    onKeyDown: onKeyDownTable\n  },\n  deserializeHtml: {\n    validNodeName: 'TABLE'\n  },\n  withOverrides: withTable,\n  plugins: [{\n    key: ELEMENT_TR,\n    isElement: true,\n    deserializeHtml: {\n      validNodeName: 'TR'\n    }\n  }, {\n    key: ELEMENT_TD,\n    isElement: true,\n    deserializeHtml: {\n      attributeNames: ['rowspan', 'colspan'],\n      validNodeName: 'TD'\n    },\n    props: ({\n      element\n    }) => {\n      var _element$attributes, _element$attributes2;\n\n      return {\n        nodeProps: {\n          colSpan: element === null || element === void 0 ? void 0 : (_element$attributes = element.attributes) === null || _element$attributes === void 0 ? void 0 : _element$attributes.colspan,\n          rowSpan: element === null || element === void 0 ? void 0 : (_element$attributes2 = element.attributes) === null || _element$attributes2 === void 0 ? void 0 : _element$attributes2.rowspan\n        }\n      };\n    }\n  }, {\n    key: ELEMENT_TH,\n    isElement: true,\n    deserializeHtml: {\n      attributeNames: ['rowspan', 'colspan'],\n      validNodeName: 'TH'\n    },\n    props: ({\n      element\n    }) => {\n      var _element$attributes3, _element$attributes4;\n\n      return {\n        nodeProps: {\n          colSpan: element === null || element === void 0 ? void 0 : (_element$attributes3 = element.attributes) === null || _element$attributes3 === void 0 ? void 0 : _element$attributes3.colspan,\n          rowSpan: element === null || element === void 0 ? void 0 : (_element$attributes4 = element.attributes) === null || _element$attributes4 === void 0 ? void 0 : _element$attributes4.rowspan\n        }\n      };\n    }\n  }]\n});\n\nconst getTableColumnCount = tableNode => {\n  var _tableNode$children$, _tableNode$children$2;\n\n  return (_tableNode$children$ = (_tableNode$children$2 = tableNode.children[0]) === null || _tableNode$children$2 === void 0 ? void 0 : _tableNode$children$2.children.length) !== null && _tableNode$children$ !== void 0 ? _tableNode$children$ : 0;\n};\n/**\n * Get table column index of a cell node.\n */\n\n\nconst getTableColumnIndex = (editor, {\n  node\n}) => {\n  var _getParent;\n\n  const path = findNodePath(editor, node);\n  if (!path) return 0;\n  const [trNode] = (_getParent = getParent(editor, path)) !== null && _getParent !== void 0 ? _getParent : [];\n  if (!trNode) return 0;\n  let colIndex = 0;\n  trNode.children.some((item, index) => {\n    if (item === node) {\n      colIndex = index;\n      return true;\n    }\n\n    return false;\n  });\n  return colIndex;\n};\n\nconst getEmptyCellNode = (editor, {\n  header\n}) => {\n  return {\n    type: header ? getPluginType(editor, ELEMENT_TH) : getPluginType(editor, ELEMENT_TD),\n    children: [{\n      type: getPluginType(editor, ELEMENT_DEFAULT),\n      children: [{\n        text: ''\n      }]\n    }]\n  };\n};\n\nconst addColumn = (editor, {\n  header\n}) => {\n  if (someNode(editor, {\n    match: {\n      type: getPluginType(editor, ELEMENT_TABLE)\n    }\n  })) {\n    const currentCellItem = getAbove(editor, {\n      match: {\n        type: [getPluginType(editor, ELEMENT_TH), getPluginType(editor, ELEMENT_TD)]\n      }\n    });\n    const currentTableItem = getAbove(editor, {\n      match: {\n        type: getPluginType(editor, ELEMENT_TABLE)\n      }\n    });\n\n    if (currentCellItem && currentTableItem) {\n      const nextCellPath = Path.next(currentCellItem[1]);\n      const newCellPath = nextCellPath.slice();\n      const replacePathPos = newCellPath.length - 2;\n      const currentRowIdx = nextCellPath[replacePathPos];\n      currentTableItem[0].children.forEach((row, rowIdx) => {\n        newCellPath[replacePathPos] = rowIdx;\n        const isHeaderRow = header === undefined ? row.children[0].type === ELEMENT_TH : header;\n        insertNodes(editor, getEmptyCellNode(editor, {\n          header: isHeaderRow\n        }), {\n          at: newCellPath,\n          select: rowIdx === currentRowIdx\n        });\n      });\n    }\n  }\n};\n\nconst getEmptyRowNode = (editor, {\n  header,\n  colCount\n}) => {\n  return {\n    type: getPluginType(editor, ELEMENT_TR),\n    children: Array(colCount).fill(colCount).map(() => getEmptyCellNode(editor, {\n      header\n    }))\n  };\n};\n\nconst addRow = (editor, {\n  header\n}) => {\n  if (someNode(editor, {\n    match: {\n      type: getPluginType(editor, ELEMENT_TABLE)\n    }\n  })) {\n    const currentRowItem = getAbove(editor, {\n      match: {\n        type: getPluginType(editor, ELEMENT_TR)\n      }\n    });\n\n    if (currentRowItem) {\n      const [currentRowElem, currentRowPath] = currentRowItem;\n      insertNodes(editor, getEmptyRowNode(editor, {\n        header,\n        colCount: currentRowElem.children.length\n      }), {\n        at: Path.next(currentRowPath),\n        select: true\n      });\n    }\n  }\n};\n\nconst deleteColumn = editor => {\n  if (someNode(editor, {\n    match: {\n      type: getPluginType(editor, ELEMENT_TABLE)\n    }\n  })) {\n    const currentCellItem = getAbove(editor, {\n      match: {\n        type: [getPluginType(editor, ELEMENT_TD), getPluginType(editor, ELEMENT_TH)]\n      }\n    });\n    const currentRowItem = getAbove(editor, {\n      match: {\n        type: getPluginType(editor, ELEMENT_TR)\n      }\n    });\n    const currentTableItem = getAbove(editor, {\n      match: {\n        type: getPluginType(editor, ELEMENT_TABLE)\n      }\n    });\n\n    if (currentCellItem && currentRowItem && currentTableItem && // Cannot delete the last cell\n    currentRowItem[0].children.length > 1) {\n      const currentCellPath = currentCellItem[1];\n      const pathToDelete = currentCellPath.slice();\n      const replacePathPos = pathToDelete.length - 2;\n      currentTableItem[0].children.forEach((row, rowIdx) => {\n        pathToDelete[replacePathPos] = rowIdx;\n        Transforms.removeNodes(editor, {\n          at: pathToDelete\n        });\n      });\n    }\n  }\n};\n\nconst deleteRow = editor => {\n  if (someNode(editor, {\n    match: {\n      type: getPluginType(editor, ELEMENT_TABLE)\n    }\n  })) {\n    const currentTableItem = getAbove(editor, {\n      match: {\n        type: getPluginType(editor, ELEMENT_TABLE)\n      }\n    });\n    const currentRowItem = getAbove(editor, {\n      match: {\n        type: getPluginType(editor, ELEMENT_TR)\n      }\n    });\n\n    if (currentRowItem && currentTableItem && // Cannot delete the last row\n    currentTableItem[0].children.length > 1) {\n      Transforms.removeNodes(editor, {\n        at: currentRowItem[1]\n      });\n    }\n  }\n};\n\nconst deleteTable = editor => {\n  if (someNode(editor, {\n    match: {\n      type: getPluginType(editor, ELEMENT_TABLE)\n    }\n  })) {\n    const tableItem = getAbove(editor, {\n      match: {\n        type: getPluginType(editor, ELEMENT_TABLE)\n      }\n    });\n\n    if (tableItem) {\n      Transforms.removeNodes(editor, {\n        at: tableItem[1]\n      });\n    }\n  }\n};\n\nconst getEmptyTableNode = (editor, {\n  header\n}) => {\n  return {\n    type: getPluginType(editor, ELEMENT_TABLE),\n    children: [getEmptyRowNode(editor, {\n      header,\n      colCount: 2\n    }), getEmptyRowNode(editor, {\n      header: false,\n      colCount: 2\n    })]\n  };\n};\n\nconst insertTable = (editor, {\n  header\n}) => {\n  if (!someNode(editor, {\n    match: {\n      type: getPluginType(editor, ELEMENT_TABLE)\n    }\n  })) {\n    insertNodes(editor, getEmptyTableNode(editor, {\n      header\n    }));\n  }\n};\n\nconst setTableColSize = (editor, {\n  colIndex,\n  width\n}, options = {}) => {\n  const table = findNode(editor, { ...options,\n    match: {\n      type: ELEMENT_TABLE\n    }\n  });\n  if (!table) return;\n  const [tableNode, tablePath] = table;\n  const colSizes = tableNode.colSizes ? [...tableNode.colSizes] : Array(getTableColumnCount(tableNode)).fill(0);\n  colSizes[colIndex] = width;\n  setNodes(editor, {\n    colSizes\n  }, {\n    at: tablePath\n  });\n};\n\nexport { ELEMENT_TABLE, ELEMENT_TD, ELEMENT_TH, ELEMENT_TR, addColumn, addRow, createTablePlugin, deleteColumn, deleteRow, deleteTable, getCellInNextTableRow, getCellInPreviousTableRow, getEmptyCellNode, getEmptyRowNode, getEmptyTableNode, getNextTableCell, getPreviousTableCell, getTableCellEntry, getTableColumnCount, getTableColumnIndex, insertTable, onKeyDownTable, setTableColSize, withTable };","map":{"version":3,"sources":["../src/queries/getCellInNextTableRow.ts","../src/queries/getNextTableCell.ts","../src/queries/getCellInPreviousTableRow.ts","../src/queries/getPreviousTableCell.ts","../src/queries/getTableCellEntry.ts","../src/onKeyDownTable.ts","../src/withTable.ts","../src/createTablePlugin.ts","../src/queries/getTableColumnCount.ts","../src/queries/getTableColumnIndex.ts","../src/utils/getEmptyCellNode.ts","../src/transforms/addColumn.ts","../src/utils/getEmptyRowNode.ts","../src/transforms/addRow.ts","../src/transforms/deleteColumn.ts","../src/transforms/deleteRow.ts","../src/transforms/deleteTable.ts","../src/utils/getEmptyTableNode.ts","../src/transforms/insertTable.ts","../src/transforms/setTableColSize.ts"],"names":["nextRow","Editor","Path","nextCell","nextRowNode","nextCellPath","nextRowPath","getCellInNextTableRow","previousRow","previousCell","previousRowNode","previousCellPath","previousRowPath","getCellInPreviousTableRow","getTableCellEntry","at","editor","selection","someNode","match","type","getPluginType","selectionParent","getParent","tableCell","tableCellNode","tableRow","tableRowNode","tableElement","onKeyDownTable","e","res","shiftTab","tab","getPreviousTableCell","Transforms","getNextTableCell","getAbove","withTable","matchCells","node","isElement","insertText","preventDeleteCell","unit","isCollapsed","start","pointCallback","Point","next","nextPoint","operation","path","end","cells","reverse","childPath","deleteFragment","text","edge","ELEMENT_TABLE","ELEMENT_TH","ELEMENT_TR","ELEMENT_TD","createTablePlugin","createPluginFactory","key","handlers","onKeyDown","deserializeHtml","validNodeName","withOverrides","plugins","attributeNames","props","element","nodeProps","colSpan","rowSpan","rowspan","getTableColumnCount","tableNode","getTableColumnIndex","findNodePath","colIndex","trNode","item","getEmptyCellNode","header","children","addColumn","currentCellItem","currentTableItem","newCellPath","replacePathPos","currentRowIdx","isHeaderRow","row","insertNodes","select","rowIdx","getEmptyRowNode","colCount","addRow","currentRowItem","currentRowElem","length","deleteColumn","currentCellPath","pathToDelete","deleteRow","deleteTable","tableItem","getEmptyTableNode","insertTable","setTableColSize","width","options","table","findNode","colSizes","Array","setNodes","tablePath"],"mappings":"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","sourcesContent":["import { TEditor } from '@udecode/plate-core';\nimport { Ancestor, Editor, NodeEntry, Path } from 'slate';\n\nexport function getCellInNextTableRow(\n  editor: TEditor,\n  currentRowPath: Path\n): NodeEntry | undefined {\n  try {\n    const nextRow = Editor.node(\n      editor,\n      Path.next(currentRowPath)\n    ) as NodeEntry<Ancestor>;\n    // TODO: Many tables in rich text editors (Google Docs, Word),\n    // add a new row if we're in the last cell. Should we do the same?\n    const [nextRowNode, nextRowPath] = nextRow;\n    const nextCell = nextRowNode?.children?.[0];\n    const nextCellPath = nextRowPath.concat(0);\n    if (nextCell && nextCellPath) {\n      return Editor.node(editor, nextCellPath);\n    }\n  } catch (err) {}\n}\n","import { TEditor } from '@udecode/plate-core';\nimport { Editor, NodeEntry, Path } from 'slate';\nimport { getCellInNextTableRow } from './getCellInNextTableRow';\n\nexport function getNextTableCell(\n  editor: TEditor,\n  currentCell: NodeEntry,\n  currentPath: Path,\n  currentRow: NodeEntry\n): NodeEntry | undefined {\n  try {\n    return Editor.node(editor, Path.next(currentPath));\n  } catch (err) {\n    const [, currentRowPath] = currentRow;\n    return getCellInNextTableRow(editor, currentRowPath);\n  }\n}\n","import { TEditor } from '@udecode/plate-core';\nimport { Ancestor, Editor, NodeEntry, Path } from 'slate';\n\nexport function getCellInPreviousTableRow(\n  editor: TEditor,\n  currentRowPath: Path\n): NodeEntry | undefined {\n  try {\n    const previousRow = Editor.node(\n      editor,\n      Path.previous(currentRowPath)\n    ) as NodeEntry<Ancestor>;\n    const [previousRowNode, previousRowPath] = previousRow;\n    const previousCell =\n      previousRowNode?.children?.[previousRowNode.children.length - 1];\n    const previousCellPath = previousRowPath.concat(\n      previousRowNode.children.length - 1\n    );\n    if (previousCell && previousCellPath) {\n      return Editor.node(editor, previousCellPath);\n    }\n  } catch (err) {}\n}\n","import { TEditor } from '@udecode/plate-core';\nimport { Editor, NodeEntry, Path } from 'slate';\nimport { getCellInPreviousTableRow } from './getCellInPreviousTableRow';\n\nexport function getPreviousTableCell(\n  editor: TEditor,\n  currentCell: NodeEntry,\n  currentPath: Path,\n  currentRow: NodeEntry\n): NodeEntry | undefined {\n  try {\n    return Editor.node(editor, Path.previous(currentPath));\n  } catch (err) {\n    const [, currentRowPath] = currentRow;\n    return getCellInPreviousTableRow(editor, currentRowPath);\n  }\n}\n","import {\n  getAbove,\n  getParent,\n  getPluginType,\n  PlateEditor,\n  someNode,\n} from '@udecode/plate-core';\nimport { Location } from 'slate';\nimport { ELEMENT_TD, ELEMENT_TH, ELEMENT_TR } from '../createTablePlugin';\n\n/**\n * If at (default = selection) is in table>tr>td or table>tr>th,\n * return table, tr, and td or th node entries.\n */\nexport const getTableCellEntry = <T = {}>(\n  editor: PlateEditor<T>,\n  { at = editor.selection }: { at?: Location | null } = {}\n) => {\n  if (\n    at &&\n    someNode(editor, {\n      at,\n      match: {\n        type: [\n          getPluginType(editor, ELEMENT_TD),\n          getPluginType(editor, ELEMENT_TH),\n        ],\n      },\n    })\n  ) {\n    const selectionParent = getParent(editor, at);\n    if (!selectionParent) return;\n    const [, paragraphPath] = selectionParent;\n\n    const tableCell =\n      getAbove(editor, {\n        at,\n        match: {\n          type: [\n            getPluginType(editor, ELEMENT_TD),\n            getPluginType(editor, ELEMENT_TH),\n          ],\n        },\n      }) || getParent(editor, paragraphPath);\n\n    if (!tableCell) return;\n    const [tableCellNode, tableCellPath] = tableCell;\n\n    if (\n      tableCellNode.type !== getPluginType(editor, ELEMENT_TD) &&\n      tableCellNode.type !== getPluginType(editor, ELEMENT_TH)\n    )\n      return;\n\n    const tableRow = getParent(editor, tableCellPath);\n    if (!tableRow) return;\n    const [tableRowNode, tableRowPath] = tableRow;\n\n    if (tableRowNode.type !== getPluginType(editor, ELEMENT_TR)) return;\n\n    const tableElement = getParent(editor, tableRowPath);\n    if (!tableElement) return;\n\n    return {\n      tableElement,\n      tableRow,\n      tableCell,\n    };\n  }\n};\n","import { getAbove, KeyboardHandler, TElement } from '@udecode/plate-core';\nimport { Transforms } from 'slate';\nimport { getNextTableCell } from './queries/getNextTableCell';\nimport { getPreviousTableCell } from './queries/getPreviousTableCell';\nimport { getTableCellEntry } from './queries/getTableCellEntry';\n\nexport const onKeyDownTable: KeyboardHandler = (editor, { type }) => (e) => {\n  if (e.key === 'Tab') {\n    e.preventDefault();\n    const res = getTableCellEntry(editor, {});\n    if (!res) return;\n    const { tableRow, tableCell } = res;\n    const [, tableCellPath] = tableCell;\n    const shiftTab = e.shiftKey;\n    const tab = !e.shiftKey;\n    if (shiftTab) {\n      // move left with shift+tab\n      const previousCell = getPreviousTableCell(\n        editor,\n        tableCell,\n        tableCellPath,\n        tableRow\n      );\n      if (previousCell) {\n        const [, previousCellPath] = previousCell;\n        Transforms.select(editor, previousCellPath);\n      }\n    } else if (tab) {\n      // move right with tab\n      const nextCell = getNextTableCell(\n        editor,\n        tableCell,\n        tableCellPath,\n        tableRow\n      );\n      if (nextCell) {\n        const [, nextCellPath] = nextCell;\n        Transforms.select(editor, nextCellPath);\n      }\n    }\n  }\n\n  // FIXME: would prefer this as mod+a, but doesn't work\n  if (e.key === 'a' && (e.metaKey || e.ctrlKey)) {\n    const res = getAbove<TElement>(editor, { match: { type } });\n    if (!res) return;\n\n    const [, tablePath] = res;\n\n    // select the whole table\n    Transforms.select(editor, tablePath);\n\n    e.preventDefault();\n    e.stopPropagation();\n  }\n};\n","import {\n  getPluginType,\n  isCollapsed,\n  isElement,\n  TElement,\n  WithOverride,\n} from '@udecode/plate-core';\nimport { Editor, Node, Point, Transforms } from 'slate';\nimport { ELEMENT_TD, ELEMENT_TH } from './createTablePlugin';\n\nexport const withTable: WithOverride = (editor) => {\n  const matchCells = (node: Node) => {\n    return (\n      isElement(node) &&\n      (node.type === getPluginType(editor, ELEMENT_TD) ||\n        node.type === getPluginType(editor, ELEMENT_TH))\n    );\n  };\n\n  const { deleteBackward, deleteForward, deleteFragment, insertText } = editor;\n\n  const preventDeleteCell = (\n    operation: any,\n    pointCallback: any,\n    nextPoint: any\n  ) => (unit: any) => {\n    const { selection } = editor;\n\n    if (isCollapsed(selection)) {\n      const [cell] = Editor.nodes<TElement>(editor, {\n        match: matchCells,\n      });\n      if (cell) {\n        // Prevent deletions within a cell\n        const [, cellPath] = cell;\n        const start = pointCallback(editor, cellPath);\n\n        if (selection && Point.equals(selection.anchor, start)) {\n          return;\n        }\n      } else {\n        // Prevent deleting cell when selection is before or after a table\n        const next = nextPoint(editor, selection, { unit });\n        const [nextCell] = Editor.nodes(editor, {\n          match: matchCells,\n          at: next,\n        });\n        if (nextCell) return;\n      }\n    }\n\n    operation(unit);\n  };\n\n  editor.deleteFragment = () => {\n    const { selection } = editor;\n    const [start] = Editor.nodes(editor, {\n      match: matchCells,\n      at: selection?.anchor.path,\n    });\n    const [end] = Editor.nodes(editor, {\n      match: matchCells,\n      at: selection?.focus.path,\n    });\n    // Skip deletes if they start or end in a table cell, unless start & end in the same cell\n    if ((start || end) && start?.[0] !== end?.[0]) {\n      // Clear cells content\n      const cells = Editor.nodes(editor, {\n        match: matchCells,\n      });\n      for (const [, path] of cells) {\n        for (const [, childPath] of Node.children(editor, path, {\n          reverse: true,\n        })) {\n          Transforms.removeNodes(editor, { at: childPath });\n        }\n      }\n      Transforms.collapse(editor);\n      return;\n    }\n    deleteFragment();\n  };\n\n  editor.insertText = (text) => {\n    const { selection } = editor;\n    const [start] = Editor.nodes(editor, {\n      match: matchCells,\n      at: selection?.anchor.path,\n    });\n    const [end] = Editor.nodes(editor, {\n      match: matchCells,\n      at: selection?.focus.path,\n    });\n    // Collapse selection if multiple cells are selected to avoid breaking the table\n    if (!isCollapsed(selection) && (start || end) && start?.[0] !== end?.[0]) {\n      const [cell] = Editor.nodes(editor, { match: matchCells });\n      if (cell) {\n        Transforms.collapse(editor, { edge: 'end' });\n        insertText(text);\n        return;\n      }\n    }\n    insertText(text);\n  };\n\n  // prevent deleting cells with deleteBackward\n  editor.deleteBackward = preventDeleteCell(\n    deleteBackward,\n    Editor.start,\n    Editor.before\n  );\n\n  // prevent deleting cells with deleteForward\n  editor.deleteForward = preventDeleteCell(\n    deleteForward,\n    Editor.end,\n    Editor.after\n  );\n\n  return editor;\n};\n","import { createPluginFactory } from '@udecode/plate-core';\nimport { onKeyDownTable } from './onKeyDownTable';\nimport { withTable } from './withTable';\n\nexport const ELEMENT_TABLE = 'table';\nexport const ELEMENT_TH = 'th';\nexport const ELEMENT_TR = 'tr';\nexport const ELEMENT_TD = 'td';\n\n/**\n * Enables support for tables.\n */\nexport const createTablePlugin = createPluginFactory({\n  key: ELEMENT_TABLE,\n  isElement: true,\n  handlers: {\n    onKeyDown: onKeyDownTable,\n  },\n  deserializeHtml: {\n    validNodeName: 'TABLE',\n  },\n  withOverrides: withTable,\n  plugins: [\n    {\n      key: ELEMENT_TR,\n      isElement: true,\n      deserializeHtml: {\n        validNodeName: 'TR',\n      },\n    },\n    {\n      key: ELEMENT_TD,\n      isElement: true,\n      deserializeHtml: {\n        attributeNames: ['rowspan', 'colspan'],\n        validNodeName: 'TD',\n      },\n      props: ({ element }) => ({\n        nodeProps: {\n          colSpan: element?.attributes?.colspan,\n          rowSpan: element?.attributes?.rowspan,\n        },\n      }),\n    },\n    {\n      key: ELEMENT_TH,\n      isElement: true,\n      deserializeHtml: {\n        attributeNames: ['rowspan', 'colspan'],\n        validNodeName: 'TH',\n      },\n      props: ({ element }) => ({\n        nodeProps: {\n          colSpan: element?.attributes?.colspan,\n          rowSpan: element?.attributes?.rowspan,\n        },\n      }),\n    },\n  ],\n});\n","import { TElement } from '@udecode/plate-core';\n\nexport const getTableColumnCount = (tableNode: TElement) => {\n  return tableNode.children[0]?.children.length ?? 0;\n};\n","import { findNodePath, getParent, TElement } from '@udecode/plate-core';\nimport { ReactEditor } from 'slate-react';\n\n/**\n * Get table column index of a cell node.\n */\nexport const getTableColumnIndex = (\n  editor: ReactEditor,\n  { node }: { node: TElement }\n) => {\n  const path = findNodePath(editor, node);\n  if (!path) return 0;\n\n  const [trNode] = getParent(editor, path) ?? [];\n  if (!trNode) return 0;\n\n  let colIndex = 0;\n\n  trNode.children.some((item, index) => {\n    if (item === node) {\n      colIndex = index;\n      return true;\n    }\n    return false;\n  });\n\n  return colIndex;\n};\n","import {\n  ELEMENT_DEFAULT,\n  getPluginType,\n  PlateEditor,\n} from '@udecode/plate-core';\nimport { ELEMENT_TD, ELEMENT_TH } from '../createTablePlugin';\nimport { TablePluginOptions } from '../types';\n\nexport const getEmptyCellNode = (\n  editor: PlateEditor,\n  { header }: TablePluginOptions\n) => {\n  return {\n    type: header\n      ? getPluginType(editor, ELEMENT_TH)\n      : getPluginType(editor, ELEMENT_TD),\n    children: [\n      {\n        type: getPluginType(editor, ELEMENT_DEFAULT),\n        children: [{ text: '' }],\n      },\n    ],\n  };\n};\n","import {\n  getAbove,\n  getPluginType,\n  insertNodes,\n  PlateEditor,\n  someNode,\n  TElement,\n} from '@udecode/plate-core';\nimport { Path } from 'slate';\nimport { ELEMENT_TABLE, ELEMENT_TD, ELEMENT_TH } from '../createTablePlugin';\nimport { TablePluginOptions } from '../types';\nimport { getEmptyCellNode } from '../utils/getEmptyCellNode';\n\nexport const addColumn = (\n  editor: PlateEditor,\n  { header }: TablePluginOptions\n) => {\n  if (\n    someNode(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TABLE) },\n    })\n  ) {\n    const currentCellItem = getAbove(editor, {\n      match: {\n        type: [\n          getPluginType(editor, ELEMENT_TH),\n          getPluginType(editor, ELEMENT_TD),\n        ],\n      },\n    });\n\n    const currentTableItem = getAbove(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TABLE) },\n    });\n\n    if (currentCellItem && currentTableItem) {\n      const nextCellPath = Path.next(currentCellItem[1]);\n      const newCellPath = nextCellPath.slice();\n      const replacePathPos = newCellPath.length - 2;\n      const currentRowIdx = nextCellPath[replacePathPos];\n\n      currentTableItem[0].children.forEach((row: TElement, rowIdx) => {\n        newCellPath[replacePathPos] = rowIdx;\n        const isHeaderRow =\n          header === undefined ? row.children[0].type === ELEMENT_TH : header;\n\n        insertNodes<TElement>(\n          editor,\n          getEmptyCellNode(editor, { header: isHeaderRow }),\n          {\n            at: newCellPath,\n            select: rowIdx === currentRowIdx,\n          }\n        );\n      });\n    }\n  }\n};\n","import { getPluginType, PlateEditor } from '@udecode/plate-core';\nimport { ELEMENT_TR } from '../createTablePlugin';\nimport { TablePluginOptions } from '../types';\nimport { getEmptyCellNode } from './getEmptyCellNode';\n\nexport const getEmptyRowNode = (\n  editor: PlateEditor,\n  { header, colCount }: TablePluginOptions & { colCount: number }\n) => {\n  return {\n    type: getPluginType(editor, ELEMENT_TR),\n    children: Array(colCount)\n      .fill(colCount)\n      .map(() => getEmptyCellNode(editor, { header })),\n  };\n};\n","import {\n  getAbove,\n  getPluginType,\n  insertNodes,\n  PlateEditor,\n  someNode,\n  TElement,\n} from '@udecode/plate-core';\nimport { Path } from 'slate';\nimport { ELEMENT_TABLE, ELEMENT_TR } from '../createTablePlugin';\nimport { TablePluginOptions } from '../types';\nimport { getEmptyRowNode } from '../utils/getEmptyRowNode';\n\nexport const addRow = (editor: PlateEditor, { header }: TablePluginOptions) => {\n  if (\n    someNode(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TABLE) },\n    })\n  ) {\n    const currentRowItem = getAbove(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TR) },\n    });\n    if (currentRowItem) {\n      const [currentRowElem, currentRowPath] = currentRowItem;\n      insertNodes<TElement>(\n        editor,\n        getEmptyRowNode(editor, {\n          header,\n          colCount: currentRowElem.children.length,\n        }),\n        {\n          at: Path.next(currentRowPath),\n          select: true,\n        }\n      );\n    }\n  }\n};\n","import {\n  getAbove,\n  getPluginType,\n  PlateEditor,\n  someNode,\n} from '@udecode/plate-core';\nimport { Transforms } from 'slate';\nimport {\n  ELEMENT_TABLE,\n  ELEMENT_TD,\n  ELEMENT_TH,\n  ELEMENT_TR,\n} from '../createTablePlugin';\n\nexport const deleteColumn = (editor: PlateEditor) => {\n  if (\n    someNode(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TABLE) },\n    })\n  ) {\n    const currentCellItem = getAbove(editor, {\n      match: {\n        type: [\n          getPluginType(editor, ELEMENT_TD),\n          getPluginType(editor, ELEMENT_TH),\n        ],\n      },\n    });\n    const currentRowItem = getAbove(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TR) },\n    });\n    const currentTableItem = getAbove(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TABLE) },\n    });\n\n    if (\n      currentCellItem &&\n      currentRowItem &&\n      currentTableItem &&\n      // Cannot delete the last cell\n      currentRowItem[0].children.length > 1\n    ) {\n      const currentCellPath = currentCellItem[1];\n      const pathToDelete = currentCellPath.slice();\n      const replacePathPos = pathToDelete.length - 2;\n\n      currentTableItem[0].children.forEach((row, rowIdx) => {\n        pathToDelete[replacePathPos] = rowIdx;\n\n        Transforms.removeNodes(editor, {\n          at: pathToDelete,\n        });\n      });\n    }\n  }\n};\n","import {\n  getAbove,\n  getPluginType,\n  PlateEditor,\n  someNode,\n} from '@udecode/plate-core';\nimport { Transforms } from 'slate';\nimport { ELEMENT_TABLE, ELEMENT_TR } from '../createTablePlugin';\n\nexport const deleteRow = (editor: PlateEditor) => {\n  if (\n    someNode(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TABLE) },\n    })\n  ) {\n    const currentTableItem = getAbove(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TABLE) },\n    });\n    const currentRowItem = getAbove(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TR) },\n    });\n    if (\n      currentRowItem &&\n      currentTableItem &&\n      // Cannot delete the last row\n      currentTableItem[0].children.length > 1\n    ) {\n      Transforms.removeNodes(editor, {\n        at: currentRowItem[1],\n      });\n    }\n  }\n};\n","import {\n  getAbove,\n  getPluginType,\n  PlateEditor,\n  someNode,\n} from '@udecode/plate-core';\nimport { Transforms } from 'slate';\nimport { ELEMENT_TABLE } from '../createTablePlugin';\n\nexport const deleteTable = (editor: PlateEditor) => {\n  if (\n    someNode(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TABLE) },\n    })\n  ) {\n    const tableItem = getAbove(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TABLE) },\n    });\n    if (tableItem) {\n      Transforms.removeNodes(editor, {\n        at: tableItem[1],\n      });\n    }\n  }\n};\n","import { getPluginType, PlateEditor } from '@udecode/plate-core';\nimport { ELEMENT_TABLE } from '../createTablePlugin';\nimport { TablePluginOptions } from '../types';\nimport { getEmptyRowNode } from './getEmptyRowNode';\n\nexport const getEmptyTableNode = (\n  editor: PlateEditor,\n  { header }: TablePluginOptions\n) => {\n  return {\n    type: getPluginType(editor, ELEMENT_TABLE),\n    children: [\n      getEmptyRowNode(editor, { header, colCount: 2 }),\n      getEmptyRowNode(editor, { header: false, colCount: 2 }),\n    ],\n  };\n};\n","import {\n  getPluginType,\n  insertNodes,\n  PlateEditor,\n  someNode,\n  TElement,\n} from '@udecode/plate-core';\nimport { ELEMENT_TABLE } from '../createTablePlugin';\nimport { TablePluginOptions } from '../types';\nimport { getEmptyTableNode } from '../utils/getEmptyTableNode';\n\nexport const insertTable = (\n  editor: PlateEditor,\n  { header }: TablePluginOptions\n) => {\n  if (\n    !someNode(editor, {\n      match: { type: getPluginType(editor, ELEMENT_TABLE) },\n    })\n  ) {\n    insertNodes<TElement>(editor, getEmptyTableNode(editor, { header }));\n  }\n};\n","import {\n  EditorAboveOptions,\n  findNode,\n  setNodes,\n  TEditor,\n  TElement,\n} from '@udecode/plate-core';\nimport { ELEMENT_TABLE } from '../createTablePlugin';\nimport { getTableColumnCount } from '../queries/getTableColumnCount';\nimport { TableNodeData } from '../types';\n\nexport const setTableColSize = (\n  editor: TEditor,\n  { colIndex, width }: { colIndex: number; width: number },\n  options: EditorAboveOptions = {}\n) => {\n  const table = findNode<TElement<TableNodeData>>(editor, {\n    ...options,\n    match: { type: ELEMENT_TABLE },\n  });\n  if (!table) return;\n\n  const [tableNode, tablePath] = table;\n\n  const colSizes = tableNode.colSizes\n    ? [...tableNode.colSizes]\n    : Array(getTableColumnCount(tableNode)).fill(0);\n\n  colSizes[colIndex] = width;\n\n  setNodes(editor, { colSizes }, { at: tablePath });\n};\n"]},"metadata":{},"sourceType":"module"}