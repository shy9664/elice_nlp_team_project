{"ast":null,"code":"var DEBUG = false; // `true` to print debugging info.\n\nvar TIMER = false; // `true` to time calls to `lex()` and print the results.\n\nvar debug = require('./debug')('lex');\n\nexports = module.exports = lex;\n/**\n * Convert a CSS string into an array of lexical tokens.\n *\n * @param {String} css CSS\n * @returns {Array} lexical tokens\n */\n\nfunction lex(css) {\n  var start; // Debug timer start.\n\n  var buffer = ''; // Character accumulator\n\n  var ch; // Current character\n\n  var column = 0; // Current source column number\n\n  var cursor = -1; // Current source cursor position\n\n  var depth = 0; // Current nesting depth\n\n  var line = 1; // Current source line number\n\n  var state = 'before-selector'; // Current state\n\n  var stack = [state]; // State stack\n\n  var token = {}; // Current token\n\n  var tokens = []; // Token accumulator\n  // Supported @-rules, in roughly descending order of usage probability.\n\n  var atRules = ['media', 'keyframes', {\n    name: '-webkit-keyframes',\n    type: 'keyframes',\n    prefix: '-webkit-'\n  }, {\n    name: '-moz-keyframes',\n    type: 'keyframes',\n    prefix: '-moz-'\n  }, {\n    name: '-ms-keyframes',\n    type: 'keyframes',\n    prefix: '-ms-'\n  }, {\n    name: '-o-keyframes',\n    type: 'keyframes',\n    prefix: '-o-'\n  }, 'font-face', {\n    name: 'import',\n    state: 'before-at-value'\n  }, {\n    name: 'charset',\n    state: 'before-at-value'\n  }, 'supports', 'viewport', {\n    name: 'namespace',\n    state: 'before-at-value'\n  }, 'document', {\n    name: '-moz-document',\n    type: 'document',\n    prefix: '-moz-'\n  }, 'page']; // -- Functions ------------------------------------------------------------\n\n  /**\n   * Advance the character cursor and return the next character.\n   *\n   * @returns {String} The next character.\n   */\n\n  function getCh() {\n    skip();\n    return css[cursor];\n  }\n  /**\n   * Return the state at the given index in the stack.\n   * The stack is LIFO so indexing is from the right.\n   *\n   * @param {Number} [index=0] Index to return.\n   * @returns {String} state\n   */\n\n\n  function getState(index) {\n    return index ? stack[stack.length - 1 - index] : state;\n  }\n  /**\n   * Look ahead for a string beginning from the next position. The string\n   * being looked for must start at the next position.\n   *\n   * @param {String} str The string to look for.\n   * @returns {Boolean} Whether the string was found.\n   */\n\n\n  function isNextString(str) {\n    var start = cursor + 1;\n    return str === css.slice(start, start + str.length);\n  }\n  /**\n   * Find the start position of a substring beginning from the next\n   * position. The string being looked for may begin anywhere.\n   *\n   * @param {String} str The substring to look for.\n   * @returns {Number|false} The position, or `false` if not found.\n   */\n\n\n  function find(str) {\n    var pos = css.slice(cursor).indexOf(str);\n    return pos > 0 ? pos : false;\n  }\n  /**\n   * Determine whether a character is next.\n   *\n   * @param {String} ch Character.\n   * @returns {Boolean} Whether the character is next.\n   */\n\n\n  function isNextChar(ch) {\n    return ch === peek(1);\n  }\n  /**\n   * Return the character at the given cursor offset. The offset is relative\n   * to the cursor, so negative values move backwards.\n   *\n   * @param {Number} [offset=1] Cursor offset.\n   * @returns {String} Character.\n   */\n\n\n  function peek(offset) {\n    return css[cursor + (offset || 1)];\n  }\n  /**\n   * Remove the current state from the stack and set the new current state.\n   *\n   * @returns {String} The removed state.\n   */\n\n\n  function popState() {\n    var removed = stack.pop();\n    state = stack[stack.length - 1];\n    return removed;\n  }\n  /**\n   * Set the current state and add it to the stack.\n   *\n   * @param {String} newState The new state.\n   * @returns {Number} The new stack length.\n   */\n\n\n  function pushState(newState) {\n    state = newState;\n    stack.push(state);\n    return stack.length;\n  }\n  /**\n   * Replace the current state with a new state.\n   *\n   * @param {String} newState The new state.\n   * @returns {String} The replaced state.\n   */\n\n\n  function replaceState(newState) {\n    var previousState = state;\n    stack[stack.length - 1] = state = newState;\n    return previousState;\n  }\n  /**\n   * Move the character cursor. Positive numbers move the cursor forward.\n   * Negative numbers are not supported!\n   *\n   * @param {Number} [n=1] Number of characters to skip.\n   */\n\n\n  function skip(n) {\n    if ((n || 1) == 1) {\n      if (css[cursor] == '\\n') {\n        line++;\n        column = 1;\n      } else {\n        column++;\n      }\n\n      cursor++;\n    } else {\n      var skipStr = css.slice(cursor, cursor + n).split('\\n');\n\n      if (skipStr.length > 1) {\n        line += skipStr.length - 1;\n        column = 1;\n      }\n\n      column += skipStr[skipStr.length - 1].length;\n      cursor = cursor + n;\n    }\n  }\n  /**\n   * Add the current token to the pile and reset the buffer.\n   */\n\n\n  function addToken() {\n    token.end = {\n      line: line,\n      col: column\n    };\n    DEBUG && debug('addToken:', JSON.stringify(token, null, 2));\n    tokens.push(token);\n    buffer = '';\n    token = {};\n  }\n  /**\n   * Set the current token.\n   *\n   * @param {String} type Token type.\n   */\n\n\n  function initializeToken(type) {\n    token = {\n      type: type,\n      start: {\n        line: line,\n        col: column\n      }\n    };\n  } // -- Main Loop ------------------------------------------------------------\n\n  /*\n  The main loop is a state machine that reads in one character at a time,\n  and determines what to do based on the current state and character.\n  This is implemented as a series of nested `switch` statements and the\n  case orders have been mildly optimized based on rough probabilities\n  calculated by processing a small sample of real-world CSS.\n   Further optimization (such as a dispatch table) shouldn't be necessary\n  since the total number of cases is very low.\n  */\n\n\n  TIMER && (start = Date.now());\n\n  while (ch = getCh()) {\n    DEBUG && debug(ch, getState()); // column += 1;\n\n    switch (ch) {\n      // Space\n      case ' ':\n        switch (getState()) {\n          case 'selector':\n          case 'value':\n          case 'value-paren':\n          case 'at-group':\n          case 'at-value':\n          case 'comment':\n          case 'double-string':\n          case 'single-string':\n            buffer += ch;\n            break;\n        }\n\n        break;\n      // Newline or tab\n\n      case '\\n':\n      case '\\t':\n      case '\\r':\n      case '\\f':\n        switch (getState()) {\n          case 'value':\n          case 'value-paren':\n          case 'at-group':\n          case 'comment':\n          case 'single-string':\n          case 'double-string':\n          case 'selector':\n            buffer += ch;\n            break;\n\n          case 'at-value':\n            // Tokenize an @-rule if a semi-colon was omitted.\n            if ('\\n' === ch) {\n              token.value = buffer.trim();\n              addToken();\n              popState();\n            }\n\n            break;\n        } // if ('\\n' === ch) {\n        //   column = 0;\n        //   line += 1;\n        // }\n\n\n        break;\n\n      case ':':\n        switch (getState()) {\n          case 'name':\n            token.name = buffer.trim();\n            buffer = '';\n            replaceState('before-value');\n            break;\n\n          case 'before-selector':\n            buffer += ch;\n            initializeToken('selector');\n            pushState('selector');\n            break;\n\n          case 'before-value':\n            replaceState('value');\n            buffer += ch;\n            break;\n\n          default:\n            buffer += ch;\n            break;\n        }\n\n        break;\n\n      case ';':\n        switch (getState()) {\n          case 'name':\n          case 'before-value':\n          case 'value':\n            // Tokenize a declaration\n            // if value is empty skip the declaration\n            if (buffer.trim().length > 0) {\n              token.value = buffer.trim(), addToken();\n            }\n\n            replaceState('before-name');\n            break;\n\n          case 'value-paren':\n            // Insignificant semi-colon\n            buffer += ch;\n            break;\n\n          case 'at-value':\n            // Tokenize an @-rule\n            token.value = buffer.trim();\n            addToken();\n            popState();\n            break;\n\n          case 'before-name':\n            // Extraneous semi-colon\n            break;\n\n          default:\n            buffer += ch;\n            break;\n        }\n\n        break;\n\n      case '{':\n        switch (getState()) {\n          case 'selector':\n            // If the sequence is `\\{` then assume that the brace should be escaped.\n            if (peek(-1) === '\\\\') {\n              buffer += ch;\n              break;\n            } // Tokenize a selector\n\n\n            token.text = buffer.trim();\n            addToken();\n            replaceState('before-name');\n            depth = depth + 1;\n            break;\n\n          case 'at-group':\n            // Tokenize an @-group\n            token.name = buffer.trim(); // XXX: @-rules are starting to get hairy\n\n            switch (token.type) {\n              case 'font-face':\n              case 'viewport':\n              case 'page':\n                pushState('before-name');\n                break;\n\n              default:\n                pushState('before-selector');\n            }\n\n            addToken();\n            depth = depth + 1;\n            break;\n\n          case 'name':\n          case 'at-rule':\n            // Tokenize a declaration or an @-rule\n            token.name = buffer.trim();\n            addToken();\n            pushState('before-name');\n            depth = depth + 1;\n            break;\n\n          case 'comment':\n          case 'double-string':\n          case 'single-string':\n            // Ignore braces in comments and strings\n            buffer += ch;\n            break;\n\n          case 'before-value':\n            replaceState('value');\n            buffer += ch;\n            break;\n        }\n\n        break;\n\n      case '}':\n        switch (getState()) {\n          case 'before-name':\n          case 'name':\n          case 'before-value':\n          case 'value':\n            // If the buffer contains anything, it is a value\n            if (buffer) {\n              token.value = buffer.trim();\n            } // If the current token has a name and a value it should be tokenized.\n\n\n            if (token.name && token.value) {\n              addToken();\n            } // Leave the block\n\n\n            initializeToken('end');\n            addToken();\n            popState(); // We might need to leave again.\n            // XXX: What about 3 levels deep?\n\n            if ('at-group' === getState()) {\n              initializeToken('at-group-end');\n              addToken();\n              popState();\n            }\n\n            if (depth > 0) {\n              depth = depth - 1;\n            }\n\n            break;\n\n          case 'at-group':\n          case 'before-selector':\n          case 'selector':\n            // If the sequence is `\\}` then assume that the brace should be escaped.\n            if (peek(-1) === '\\\\') {\n              buffer += ch;\n              break;\n            }\n\n            if (depth > 0) {\n              // Leave block if in an at-group\n              if ('at-group' === getState(1)) {\n                initializeToken('at-group-end');\n                addToken();\n              }\n            }\n\n            if (depth > 1) {\n              popState();\n            }\n\n            if (depth > 0) {\n              depth = depth - 1;\n            }\n\n            break;\n\n          case 'double-string':\n          case 'single-string':\n          case 'comment':\n            // Ignore braces in comments and strings.\n            buffer += ch;\n            break;\n        }\n\n        break;\n      // Strings\n\n      case '\"':\n      case \"'\":\n        switch (getState()) {\n          case 'double-string':\n            if ('\"' === ch && '\\\\' !== peek(-1)) {\n              popState();\n            }\n\n            break;\n\n          case 'single-string':\n            if (\"'\" === ch && '\\\\' !== peek(-1)) {\n              popState();\n            }\n\n            break;\n\n          case 'before-at-value':\n            replaceState('at-value');\n            pushState('\"' === ch ? 'double-string' : 'single-string');\n            break;\n\n          case 'before-value':\n            replaceState('value');\n            pushState('\"' === ch ? 'double-string' : 'single-string');\n            break;\n\n          case 'comment':\n            // Ignore strings within comments.\n            break;\n\n          default:\n            if ('\\\\' !== peek(-1)) {\n              pushState('\"' === ch ? 'double-string' : 'single-string');\n            }\n\n        }\n\n        buffer += ch;\n        break;\n      // Comments\n\n      case '/':\n        switch (getState()) {\n          case 'comment':\n          case 'double-string':\n          case 'single-string':\n            // Ignore\n            buffer += ch;\n            break;\n\n          case 'before-value':\n          case 'selector':\n          case 'name':\n          case 'value':\n            if (isNextChar('*')) {\n              // Ignore comments in selectors, properties and values. They are\n              // difficult to represent in the AST.\n              var pos = find('*/');\n\n              if (pos) {\n                skip(pos + 1);\n              }\n            } else {\n              if (getState() == 'before-value') replaceState('value');\n              buffer += ch;\n            }\n\n            break;\n\n          default:\n            if (isNextChar('*')) {\n              // Create a comment token\n              initializeToken('comment');\n              pushState('comment');\n              skip();\n            } else {\n              buffer += ch;\n            }\n\n            break;\n        }\n\n        break;\n      // Comment end or universal selector\n\n      case '*':\n        switch (getState()) {\n          case 'comment':\n            if (isNextChar('/')) {\n              // Tokenize a comment\n              token.text = buffer; // Don't trim()!\n\n              skip();\n              addToken();\n              popState();\n            } else {\n              buffer += ch;\n            }\n\n            break;\n\n          case 'before-selector':\n            buffer += ch;\n            initializeToken('selector');\n            pushState('selector');\n            break;\n\n          case 'before-value':\n            replaceState('value');\n            buffer += ch;\n            break;\n\n          default:\n            buffer += ch;\n        }\n\n        break;\n      // @-rules\n\n      case '@':\n        switch (getState()) {\n          case 'comment':\n          case 'double-string':\n          case 'single-string':\n            buffer += ch;\n            break;\n\n          case 'before-value':\n            replaceState('value');\n            buffer += ch;\n            break;\n\n          default:\n            // Iterate over the supported @-rules and attempt to tokenize one.\n            var tokenized = false;\n            var name;\n            var rule;\n\n            for (var j = 0, len = atRules.length; !tokenized && j < len; ++j) {\n              rule = atRules[j];\n              name = rule.name || rule;\n\n              if (!isNextString(name)) {\n                continue;\n              }\n\n              tokenized = true;\n              initializeToken(name);\n              pushState(rule.state || 'at-group');\n              skip(name.length);\n\n              if (rule.prefix) {\n                token.prefix = rule.prefix;\n              }\n\n              if (rule.type) {\n                token.type = rule.type;\n              }\n            }\n\n            if (!tokenized) {\n              // Keep on truckin' America!\n              buffer += ch;\n            }\n\n            break;\n        }\n\n        break;\n      // Parentheses are tracked to disambiguate semi-colons, such as within a\n      // data URI.\n\n      case '(':\n        switch (getState()) {\n          case 'value':\n            pushState('value-paren');\n            break;\n\n          case 'before-value':\n            replaceState('value');\n            break;\n        }\n\n        buffer += ch;\n        break;\n\n      case ')':\n        switch (getState()) {\n          case 'value-paren':\n            popState();\n            break;\n\n          case 'before-value':\n            replaceState('value');\n            break;\n        }\n\n        buffer += ch;\n        break;\n\n      default:\n        switch (getState()) {\n          case 'before-selector':\n            initializeToken('selector');\n            pushState('selector');\n            break;\n\n          case 'before-name':\n            initializeToken('property');\n            replaceState('name');\n            break;\n\n          case 'before-value':\n            replaceState('value');\n            break;\n\n          case 'before-at-value':\n            replaceState('at-value');\n            break;\n        }\n\n        buffer += ch;\n        break;\n    }\n  }\n\n  TIMER && debug('ran in', Date.now() - start + 'ms');\n  return tokens;\n}","map":{"version":3,"sources":["/Users/hyun/Desktop/33333333 2/frontend/node_modules/mensch/lib/lexer.js"],"names":["DEBUG","TIMER","debug","require","exports","module","lex","css","start","buffer","ch","column","cursor","depth","line","state","stack","token","tokens","atRules","name","type","prefix","getCh","skip","getState","index","length","isNextString","str","slice","find","pos","indexOf","isNextChar","peek","offset","popState","removed","pop","pushState","newState","push","replaceState","previousState","n","skipStr","split","addToken","end","col","JSON","stringify","initializeToken","Date","now","value","trim","text","tokenized","rule","j","len"],"mappings":"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","sourcesContent":["var DEBUG = false; // `true` to print debugging info.\nvar TIMER = false; // `true` to time calls to `lex()` and print the results.\n\nvar debug = require('./debug')('lex');\n\nexports = module.exports = lex;\n\n/**\n * Convert a CSS string into an array of lexical tokens.\n *\n * @param {String} css CSS\n * @returns {Array} lexical tokens\n */\nfunction lex(css) {\n  var start; // Debug timer start.\n\n  var buffer = '';      // Character accumulator\n  var ch;               // Current character\n  var column = 0;       // Current source column number\n  var cursor = -1;      // Current source cursor position\n  var depth = 0;        // Current nesting depth\n  var line = 1;         // Current source line number\n  var state = 'before-selector'; // Current state\n  var stack = [state];  // State stack\n  var token = {};       // Current token\n  var tokens = [];      // Token accumulator\n\n  // Supported @-rules, in roughly descending order of usage probability.\n  var atRules = [\n    'media',\n    'keyframes',\n    { name: '-webkit-keyframes', type: 'keyframes', prefix: '-webkit-' },\n    { name: '-moz-keyframes', type: 'keyframes', prefix: '-moz-' },\n    { name: '-ms-keyframes', type: 'keyframes', prefix: '-ms-' },\n    { name: '-o-keyframes', type: 'keyframes', prefix: '-o-' },\n    'font-face',\n    { name: 'import', state: 'before-at-value' },\n    { name: 'charset', state: 'before-at-value' },\n    'supports',\n    'viewport',\n    { name: 'namespace', state: 'before-at-value' },\n    'document',\n    { name: '-moz-document', type: 'document', prefix: '-moz-' },\n    'page'\n  ];\n\n  // -- Functions ------------------------------------------------------------\n\n  /**\n   * Advance the character cursor and return the next character.\n   *\n   * @returns {String} The next character.\n   */\n  function getCh() {\n    skip();\n    return css[cursor];\n  }\n\n  /**\n   * Return the state at the given index in the stack.\n   * The stack is LIFO so indexing is from the right.\n   *\n   * @param {Number} [index=0] Index to return.\n   * @returns {String} state\n   */\n  function getState(index) {\n    return index ? stack[stack.length - 1 - index] : state;\n  }\n\n  /**\n   * Look ahead for a string beginning from the next position. The string\n   * being looked for must start at the next position.\n   *\n   * @param {String} str The string to look for.\n   * @returns {Boolean} Whether the string was found.\n   */\n  function isNextString(str) {\n    var start = cursor + 1;\n    return (str === css.slice(start, start + str.length));\n  }\n\n  /**\n   * Find the start position of a substring beginning from the next\n   * position. The string being looked for may begin anywhere.\n   *\n   * @param {String} str The substring to look for.\n   * @returns {Number|false} The position, or `false` if not found.\n   */\n  function find(str) {\n    var pos = css.slice(cursor).indexOf(str);\n\n    return pos > 0 ? pos : false;\n  }\n\n  /**\n   * Determine whether a character is next.\n   *\n   * @param {String} ch Character.\n   * @returns {Boolean} Whether the character is next.\n   */\n  function isNextChar(ch) {\n    return ch === peek(1);\n  }\n\n  /**\n   * Return the character at the given cursor offset. The offset is relative\n   * to the cursor, so negative values move backwards.\n   *\n   * @param {Number} [offset=1] Cursor offset.\n   * @returns {String} Character.\n   */\n  function peek(offset) {\n    return css[cursor + (offset || 1)];\n  }\n\n  /**\n   * Remove the current state from the stack and set the new current state.\n   *\n   * @returns {String} The removed state.\n   */\n  function popState() {\n    var removed = stack.pop();\n    state = stack[stack.length - 1];\n\n    return removed;\n  }\n\n  /**\n   * Set the current state and add it to the stack.\n   *\n   * @param {String} newState The new state.\n   * @returns {Number} The new stack length.\n   */\n  function pushState(newState) {\n    state = newState;\n    stack.push(state);\n\n    return stack.length;\n  }\n\n  /**\n   * Replace the current state with a new state.\n   *\n   * @param {String} newState The new state.\n   * @returns {String} The replaced state.\n   */\n  function replaceState(newState) {\n    var previousState = state;\n    stack[stack.length - 1] = state = newState;\n\n    return previousState;\n  }\n\n  /**\n   * Move the character cursor. Positive numbers move the cursor forward.\n   * Negative numbers are not supported!\n   *\n   * @param {Number} [n=1] Number of characters to skip.\n   */\n  function skip(n) {\n    if ((n || 1) == 1) {\n      if (css[cursor] == '\\n') {\n        line++;\n        column = 1;\n      } else {\n        column++;\n      }\n      cursor++;\n    } else {\n      var skipStr = css.slice(cursor, cursor + n).split('\\n');\n      if (skipStr.length > 1) {\n        line += skipStr.length - 1;\n        column = 1;\n      }\n      column += skipStr[skipStr.length - 1].length;\n      cursor = cursor + n;\n    }\n  }\n\n  /**\n   * Add the current token to the pile and reset the buffer.\n   */\n  function addToken() {\n    token.end = {\n      line: line,\n      col: column\n    };\n\n    DEBUG && debug('addToken:', JSON.stringify(token, null, 2));\n\n    tokens.push(token);\n\n    buffer = '';\n    token = {};\n  }\n\n  /**\n   * Set the current token.\n   *\n   * @param {String} type Token type.\n   */\n  function initializeToken(type) {\n    token = {\n      type: type,\n      start: {\n        line: line,\n        col : column\n      }\n    };\n  }\n\n  // -- Main Loop ------------------------------------------------------------\n\n  /*\n  The main loop is a state machine that reads in one character at a time,\n  and determines what to do based on the current state and character.\n  This is implemented as a series of nested `switch` statements and the\n  case orders have been mildly optimized based on rough probabilities\n  calculated by processing a small sample of real-world CSS.\n\n  Further optimization (such as a dispatch table) shouldn't be necessary\n  since the total number of cases is very low.\n  */\n\n  TIMER && (start = Date.now());\n\n  while (ch = getCh()) {\n    DEBUG && debug(ch, getState());\n\n    // column += 1;\n\n    switch (ch) {\n    // Space\n    case ' ':\n      switch (getState()) {\n      case 'selector':\n      case 'value':\n      case 'value-paren':\n      case 'at-group':\n      case 'at-value':\n      case 'comment':\n      case 'double-string':\n      case 'single-string':\n        buffer += ch;\n        break;\n      }\n      break;\n\n    // Newline or tab\n    case '\\n':\n    case '\\t':\n    case '\\r':\n    case '\\f':\n      switch (getState()) {\n      case 'value':\n      case 'value-paren':\n      case 'at-group':\n      case 'comment':\n      case 'single-string':\n      case 'double-string':\n      case 'selector':\n        buffer += ch;\n        break;\n\n      case 'at-value':\n        // Tokenize an @-rule if a semi-colon was omitted.\n        if ('\\n' === ch) {\n          token.value = buffer.trim();\n          addToken();\n          popState();\n        }\n        break;\n      }\n\n      // if ('\\n' === ch) {\n      //   column = 0;\n      //   line += 1;\n      // }\n      break;\n\n    case ':':\n      switch (getState()) {\n      case 'name':\n        token.name = buffer.trim();\n        buffer = '';\n\n        replaceState('before-value');\n        break;\n\n      case 'before-selector':\n        buffer += ch;\n\n        initializeToken('selector');\n        pushState('selector');\n        break;\n\n      case 'before-value':\n        replaceState('value');\n        buffer += ch;\n        break;\n\n      default:\n        buffer += ch;\n        break;\n      }\n      break;\n\n    case ';':\n      switch (getState()) {\n      case 'name':\n      case 'before-value':\n      case 'value':\n        // Tokenize a declaration\n        // if value is empty skip the declaration\n        if (buffer.trim().length > 0) {\n          token.value = buffer.trim(),\n          addToken();\n        }\n        replaceState('before-name');\n        break;\n\n      case 'value-paren':\n        // Insignificant semi-colon\n        buffer += ch;\n        break;\n\n      case 'at-value':\n        // Tokenize an @-rule\n        token.value = buffer.trim();\n        addToken();\n        popState();\n        break;\n\n      case 'before-name':\n        // Extraneous semi-colon\n        break;\n\n      default:\n        buffer += ch;\n        break;\n      }\n      break;\n\n    case '{':\n      switch (getState()) {\n      case 'selector':\n        // If the sequence is `\\{` then assume that the brace should be escaped.\n        if (peek(-1) === '\\\\') {\n            buffer += ch;\n            break;\n        }\n\n        // Tokenize a selector\n        token.text = buffer.trim();\n        addToken();\n        replaceState('before-name');\n        depth = depth + 1;\n        break;\n\n      case 'at-group':\n        // Tokenize an @-group\n        token.name = buffer.trim();\n\n        // XXX: @-rules are starting to get hairy\n        switch (token.type) {\n        case 'font-face':\n        case 'viewport' :\n        case 'page'     :\n          pushState('before-name');\n          break;\n\n        default:\n          pushState('before-selector');\n        }\n\n        addToken();\n        depth = depth + 1;\n        break;\n\n      case 'name':\n      case 'at-rule':\n        // Tokenize a declaration or an @-rule\n        token.name = buffer.trim();\n        addToken();\n        pushState('before-name');\n        depth = depth + 1;\n        break;\n\n      case 'comment':\n      case 'double-string':\n      case 'single-string':\n        // Ignore braces in comments and strings\n        buffer += ch;\n        break;\n      case 'before-value':\n        replaceState('value');\n        buffer += ch;\n        break;\n      }\n\n      break;\n\n    case '}':\n      switch (getState()) {\n      case 'before-name':\n      case 'name':\n      case 'before-value':\n      case 'value':\n        // If the buffer contains anything, it is a value\n        if (buffer) {\n          token.value = buffer.trim();\n        }\n\n        // If the current token has a name and a value it should be tokenized.\n        if (token.name && token.value) {\n          addToken();\n        }\n\n        // Leave the block\n        initializeToken('end');\n        addToken();\n        popState();\n\n        // We might need to leave again.\n        // XXX: What about 3 levels deep?\n        if ('at-group' === getState()) {\n          initializeToken('at-group-end');\n          addToken();\n          popState();\n        }\n        \n        if (depth > 0) {\n          depth = depth - 1;\n        }\n\n        break;\n\n      case 'at-group':\n      case 'before-selector':\n      case 'selector':\n        // If the sequence is `\\}` then assume that the brace should be escaped.\n        if (peek(-1) === '\\\\') {\n            buffer += ch;\n            break;\n        }\n\n        if (depth > 0) {\n          // Leave block if in an at-group\n          if ('at-group' === getState(1)) {\n            initializeToken('at-group-end');\n            addToken();\n          }\n        }\n\n        if (depth > 1) {\n          popState();\n        }\n\n        if (depth > 0) {\n          depth = depth - 1;\n        }\n        break;\n\n      case 'double-string':\n      case 'single-string':\n      case 'comment':\n        // Ignore braces in comments and strings.\n        buffer += ch;\n        break;\n      }\n\n      break;\n\n    // Strings\n    case '\"':\n    case \"'\":\n      switch (getState()) {\n      case 'double-string':\n        if ('\"' === ch && '\\\\' !== peek(-1)) {\n          popState();\n        }\n        break;\n\n      case 'single-string':\n        if (\"'\" === ch && '\\\\' !== peek(-1)) {\n          popState();\n        }\n        break;\n\n      case 'before-at-value':\n        replaceState('at-value');\n        pushState('\"' === ch ? 'double-string' : 'single-string');\n        break;\n\n      case 'before-value':\n        replaceState('value');\n        pushState('\"' === ch ? 'double-string' : 'single-string');\n        break;\n\n      case 'comment':\n        // Ignore strings within comments.\n        break;\n\n      default:\n        if ('\\\\' !== peek(-1)) {\n          pushState('\"' === ch ? 'double-string' : 'single-string');\n        }\n      }\n\n      buffer += ch;\n      break;\n\n    // Comments\n    case '/':\n      switch (getState()) {\n      case 'comment':\n      case 'double-string':\n      case 'single-string':\n        // Ignore\n        buffer += ch;\n        break;\n\n      case 'before-value':\n      case 'selector':\n      case 'name':\n      case 'value':\n        if (isNextChar('*')) {\n          // Ignore comments in selectors, properties and values. They are\n          // difficult to represent in the AST.\n          var pos = find('*/');\n\n          if (pos) {\n            skip(pos + 1);\n          }\n        } else {\n          if (getState() == 'before-value') replaceState('value');\n          buffer += ch;\n        }\n        break;\n\n      default:\n        if (isNextChar('*')) {\n          // Create a comment token\n          initializeToken('comment');\n          pushState('comment');\n          skip();\n        }\n        else {\n          buffer += ch;\n        }\n        break;\n      }\n      break;\n\n    // Comment end or universal selector\n    case '*':\n      switch (getState()) {\n      case 'comment':\n        if (isNextChar('/')) {\n          // Tokenize a comment\n          token.text = buffer; // Don't trim()!\n          skip();\n          addToken();\n          popState();\n        }\n        else {\n          buffer += ch;\n        }\n        break;\n\n      case 'before-selector':\n        buffer += ch;\n        initializeToken('selector');\n        pushState('selector');\n        break;\n\n      case 'before-value':\n        replaceState('value');\n        buffer += ch;\n        break;\n\n      default:\n        buffer += ch;\n      }\n      break;\n\n    // @-rules\n    case '@':\n      switch (getState()) {\n      case 'comment':\n      case 'double-string':\n      case 'single-string':\n        buffer += ch;\n        break;\n      case 'before-value':\n        replaceState('value');\n        buffer += ch;\n        break;\n\n      default:\n        // Iterate over the supported @-rules and attempt to tokenize one.\n        var tokenized = false;\n        var name;\n        var rule;\n\n        for (var j = 0, len = atRules.length; !tokenized && j < len; ++j) {\n          rule = atRules[j];\n          name = rule.name || rule;\n\n          if (!isNextString(name)) { continue; }\n\n          tokenized = true;\n\n          initializeToken(name);\n          pushState(rule.state || 'at-group');\n          skip(name.length);\n\n          if (rule.prefix) {\n            token.prefix = rule.prefix;\n          }\n\n          if (rule.type) {\n            token.type = rule.type;\n          }\n        }\n\n        if (!tokenized) {\n          // Keep on truckin' America!\n          buffer += ch;\n        }\n        break;\n      }\n      break;\n\n    // Parentheses are tracked to disambiguate semi-colons, such as within a\n    // data URI.\n    case '(':\n      switch (getState()) {\n      case 'value':\n        pushState('value-paren');\n        break;\n      case 'before-value':\n        replaceState('value');\n        break;\n      }\n\n      buffer += ch;\n      break;\n\n    case ')':\n      switch (getState()) {\n      case 'value-paren':\n        popState();\n        break;\n      case 'before-value':\n        replaceState('value');\n        break;\n      }\n\n      buffer += ch;\n      break;\n\n    default:\n      switch (getState()) {\n      case 'before-selector':\n        initializeToken('selector');\n        pushState('selector');\n        break;\n\n      case 'before-name':\n        initializeToken('property');\n        replaceState('name');\n        break;\n\n      case 'before-value':\n        replaceState('value');\n        break;\n\n      case 'before-at-value':\n        replaceState('at-value');\n        break;\n      }\n\n      buffer += ch;\n      break;\n    }\n  }\n\n  TIMER && debug('ran in', (Date.now() - start) + 'ms');\n\n  return tokens;\n}\n"]},"metadata":{},"sourceType":"script"}