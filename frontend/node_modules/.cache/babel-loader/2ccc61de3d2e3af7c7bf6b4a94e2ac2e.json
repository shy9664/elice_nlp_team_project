{"ast":null,"code":"import escapeHtml from 'escape-html';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar defaultNodeTypes = {\n  paragraph: 'paragraph',\n  block_quote: 'block_quote',\n  code_block: 'code_block',\n  link: 'link',\n  ul_list: 'ul_list',\n  ol_list: 'ol_list',\n  listItem: 'list_item',\n  heading: {\n    1: 'heading_one',\n    2: 'heading_two',\n    3: 'heading_three',\n    4: 'heading_four',\n    5: 'heading_five',\n    6: 'heading_six'\n  },\n  emphasis_mark: 'italic',\n  strong_mark: 'bold',\n  delete_mark: 'strikeThrough',\n  inline_code_mark: 'code',\n  thematic_break: 'thematic_break',\n  image: 'image'\n};\n\nfunction deserialize(node, opts) {\n  var _opts$nodeTypes, _opts$linkDestination, _opts$imageSourceKey, _opts$imageCaptionKey, _ref, _ref2, _node$value, _extends2, _extends3, _extends4, _extends5;\n\n  var types = _extends({}, defaultNodeTypes, opts === null || opts === void 0 ? void 0 : opts.nodeTypes, {\n    heading: _extends({}, defaultNodeTypes.heading, opts === null || opts === void 0 ? void 0 : (_opts$nodeTypes = opts.nodeTypes) === null || _opts$nodeTypes === void 0 ? void 0 : _opts$nodeTypes.heading)\n  });\n\n  var linkDestinationKey = (_opts$linkDestination = opts === null || opts === void 0 ? void 0 : opts.linkDestinationKey) !== null && _opts$linkDestination !== void 0 ? _opts$linkDestination : 'link';\n  var imageSourceKey = (_opts$imageSourceKey = opts === null || opts === void 0 ? void 0 : opts.imageSourceKey) !== null && _opts$imageSourceKey !== void 0 ? _opts$imageSourceKey : 'link';\n  var imageCaptionKey = (_opts$imageCaptionKey = opts === null || opts === void 0 ? void 0 : opts.imageCaptionKey) !== null && _opts$imageCaptionKey !== void 0 ? _opts$imageCaptionKey : 'caption';\n  var children = [{\n    text: ''\n  }];\n\n  if (node.children && Array.isArray(node.children) && node.children.length > 0) {\n    // @ts-ignore\n    children = node.children.map(function (c) {\n      return deserialize(_extends({}, c, {\n        ordered: node.ordered || false\n      }), opts);\n    });\n  }\n\n  switch (node.type) {\n    case 'heading':\n      return {\n        type: types.heading[node.depth || 1],\n        children: children\n      };\n\n    case 'list':\n      return {\n        type: node.ordered ? types.ol_list : types.ul_list,\n        children: children\n      };\n\n    case 'listItem':\n      return {\n        type: types.listItem,\n        children: children\n      };\n\n    case 'paragraph':\n      return {\n        type: types.paragraph,\n        children: children\n      };\n\n    case 'link':\n      return _ref = {\n        type: types.link\n      }, _ref[linkDestinationKey] = node.url, _ref.children = children, _ref;\n\n    case 'image':\n      return _ref2 = {\n        type: types.image,\n        children: [{\n          text: ''\n        }]\n      }, _ref2[imageSourceKey] = node.url, _ref2[imageCaptionKey] = node.alt, _ref2;\n\n    case 'blockquote':\n      return {\n        type: types.block_quote,\n        children: children\n      };\n\n    case 'code':\n      return {\n        type: types.code_block,\n        language: node.lang,\n        children: [{\n          text: node.value\n        }]\n      };\n\n    case 'html':\n      if ((_node$value = node.value) === null || _node$value === void 0 ? void 0 : _node$value.includes('<br>')) {\n        var _node$value2;\n\n        return {\n          \"break\": true,\n          type: types.paragraph,\n          children: [{\n            text: ((_node$value2 = node.value) === null || _node$value2 === void 0 ? void 0 : _node$value2.replace(/<br>/g, '')) || ''\n          }]\n        };\n      }\n\n      return {\n        type: 'paragraph',\n        children: [{\n          text: node.value || ''\n        }]\n      };\n\n    case 'emphasis':\n      return _extends((_extends2 = {}, _extends2[types.emphasis_mark] = true, _extends2), forceLeafNode(children), persistLeafFormats(children));\n\n    case 'strong':\n      return _extends((_extends3 = {}, _extends3[types.strong_mark] = true, _extends3), forceLeafNode(children), persistLeafFormats(children));\n\n    case 'delete':\n      return _extends((_extends4 = {}, _extends4[types.delete_mark] = true, _extends4), forceLeafNode(children), persistLeafFormats(children));\n\n    case 'inlineCode':\n      return _extends((_extends5 = {}, _extends5[types.inline_code_mark] = true, _extends5.text = node.value, _extends5), persistLeafFormats(children));\n\n    case 'thematicBreak':\n      return {\n        type: types.thematic_break,\n        children: [{\n          text: ''\n        }]\n      };\n\n    case 'text':\n    default:\n      return {\n        text: node.value || ''\n      };\n  }\n}\n\nvar forceLeafNode = function forceLeafNode(children) {\n  return {\n    text: children.map(function (k) {\n      return k === null || k === void 0 ? void 0 : k.text;\n    }).join('')\n  };\n}; // This function is will take any unknown keys, and bring them up a level\n// allowing leaf nodes to have many different formats at once\n// for example, bold and italic on the same node\n\n\nfunction persistLeafFormats(children) {\n  return children.reduce(function (acc, node) {\n    Object.keys(node).forEach(function (key) {\n      if (key === 'children' || key === 'type' || key === 'text') return; // @ts-ignore\n\n      acc[key] = node[key];\n    });\n    return acc;\n  }, {});\n}\n\nvar isLeafNode = function isLeafNode(node) {\n  return typeof node.text === 'string';\n};\n\nvar VOID_ELEMENTS = ['thematic_break'];\nvar BREAK_TAG = '<br>';\n\nfunction serialize(chunk, opts) {\n  if (opts === void 0) {\n    opts = {\n      nodeTypes: defaultNodeTypes\n    };\n  }\n\n  var _opts = opts,\n      _opts$nodeTypes = _opts.nodeTypes,\n      userNodeTypes = _opts$nodeTypes === void 0 ? defaultNodeTypes : _opts$nodeTypes,\n      _opts$ignoreParagraph = _opts.ignoreParagraphNewline,\n      ignoreParagraphNewline = _opts$ignoreParagraph === void 0 ? false : _opts$ignoreParagraph,\n      _opts$listDepth = _opts.listDepth,\n      listDepth = _opts$listDepth === void 0 ? 0 : _opts$listDepth;\n  var text = chunk.text || '';\n  var type = chunk.type || '';\n\n  var nodeTypes = _extends({}, defaultNodeTypes, userNodeTypes, {\n    heading: _extends({}, defaultNodeTypes.heading, userNodeTypes.heading)\n  });\n\n  var LIST_TYPES = [nodeTypes.ul_list, nodeTypes.ol_list];\n  var children = text;\n\n  if (!isLeafNode(chunk)) {\n    children = chunk.children.map(function (c) {\n      var isList = !isLeafNode(c) ? LIST_TYPES.includes(c.type || '') : false;\n      var selfIsList = LIST_TYPES.includes(chunk.type || ''); // Links can have the following shape\n      // In which case we don't want to surround\n      // with break tags\n      // {\n      //  type: 'paragraph',\n      //  children: [\n      //    { text: '' },\n      //    { type: 'link', children: [{ text: foo.com }]}\n      //    { text: '' }\n      //  ]\n      // }\n\n      var childrenHasLink = false;\n\n      if (!isLeafNode(chunk) && Array.isArray(chunk.children)) {\n        childrenHasLink = chunk.children.some(function (f) {\n          return !isLeafNode(f) && f.type === nodeTypes.link;\n        });\n      }\n\n      return serialize(_extends({}, c, {\n        parentType: type\n      }), {\n        nodeTypes: nodeTypes,\n        // WOAH.\n        // what we're doing here is pretty tricky, it relates to the block below where\n        // we check for ignoreParagraphNewline and set type to paragraph.\n        // We want to strip out empty paragraphs sometimes, but other times we don't.\n        // If we're the descendant of a list, we know we don't want a bunch\n        // of whitespace. If we're parallel to a link we also don't want\n        // to respect neighboring paragraphs\n        ignoreParagraphNewline: (ignoreParagraphNewline || isList || selfIsList || childrenHasLink) && // if we have c.break, never ignore empty paragraph new line\n        !c[\"break\"],\n        // track depth of nested lists so we can add proper spacing\n        listDepth: LIST_TYPES.includes(c.type || '') ? listDepth + 1 : listDepth\n      });\n    }).join('');\n  } // This is pretty fragile code, check the long comment where we iterate over children\n\n\n  if (!ignoreParagraphNewline && (text === '' || text === '\\n') && chunk.parentType === nodeTypes.paragraph) {\n    type = nodeTypes.paragraph;\n    children = BREAK_TAG;\n  }\n\n  if (children === '' && !VOID_ELEMENTS.find(function (k) {\n    return nodeTypes[k] === type;\n  })) return; // Never allow decorating break tags with rich text formatting,\n  // this can malform generated markdown\n  // Also ensure we're only ever applying text formatting to leaf node\n  // level chunks, otherwise we can end up in a situation where\n  // we try applying formatting like to a node like this:\n  // \"Text foo bar **baz**\" resulting in \"**Text foo bar **baz****\"\n  // which is invalid markup and can mess everything up\n\n  if (children !== BREAK_TAG && isLeafNode(chunk)) {\n    if (chunk.strikeThrough && chunk.bold && chunk.italic) {\n      children = retainWhitespaceAndFormat(children, '~~***');\n    } else if (chunk.bold && chunk.italic) {\n      children = retainWhitespaceAndFormat(children, '***');\n    } else {\n      if (chunk.bold) {\n        children = retainWhitespaceAndFormat(children, '**');\n      }\n\n      if (chunk.italic) {\n        children = retainWhitespaceAndFormat(children, '_');\n      }\n\n      if (chunk.strikeThrough) {\n        children = retainWhitespaceAndFormat(children, '~~');\n      }\n\n      if (chunk.code) {\n        children = retainWhitespaceAndFormat(children, '`');\n      }\n    }\n  }\n\n  switch (type) {\n    case nodeTypes.heading[1]:\n      return \"# \" + children + \"\\n\";\n\n    case nodeTypes.heading[2]:\n      return \"## \" + children + \"\\n\";\n\n    case nodeTypes.heading[3]:\n      return \"### \" + children + \"\\n\";\n\n    case nodeTypes.heading[4]:\n      return \"#### \" + children + \"\\n\";\n\n    case nodeTypes.heading[5]:\n      return \"##### \" + children + \"\\n\";\n\n    case nodeTypes.heading[6]:\n      return \"###### \" + children + \"\\n\";\n\n    case nodeTypes.block_quote:\n      // For some reason, marked is parsing blockquotes w/ one new line\n      // as contiued blockquotes, so adding two new lines ensures that doesn't\n      // happen\n      return \"> \" + children + \"\\n\\n\";\n\n    case nodeTypes.code_block:\n      return \"```\" + (chunk.language || '') + \"\\n\" + children + \"\\n```\\n\";\n\n    case nodeTypes.link:\n      return \"[\" + children + \"](\" + (chunk.link || '') + \")\";\n\n    case nodeTypes.image:\n      return \"![\" + chunk.caption + \"](\" + (chunk.link || '') + \")\";\n\n    case nodeTypes.ul_list:\n    case nodeTypes.ol_list:\n      return \"\\n\" + children + \"\\n\";\n\n    case nodeTypes.listItem:\n      var isOL = chunk && chunk.parentType === nodeTypes.ol_list;\n      var spacer = '';\n\n      for (var k = 0; listDepth > k; k++) {\n        if (isOL) {\n          // https://github.com/remarkjs/remark-react/issues/65\n          spacer += '   ';\n        } else {\n          spacer += '  ';\n        }\n      }\n\n      return \"\" + spacer + (isOL ? '1.' : '-') + \" \" + children;\n\n    case nodeTypes.paragraph:\n      return children + \"\\n\";\n\n    case nodeTypes.thematic_break:\n      return \"---\\n\";\n\n    default:\n      return escapeHtml(children);\n  }\n} // This function handles the case of a string like this: \"   foo   \"\n// Where it would be invalid markdown to generate this: \"**   foo   **\"\n// We instead, want to trim the whitespace out, apply formatting, and then\n// bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\n\n\nfunction retainWhitespaceAndFormat(string, format) {\n  // we keep this for a comparison later\n  var frozenString = string.trim(); // children will be mutated\n\n  var children = frozenString; // We reverse the right side formatting, to properly handle bold/italic and strikeThrough\n  // formats, so we can create ~~***FooBar***~~\n\n  var fullFormat = \"\" + format + children + reverseStr(format); // This conditions accounts for no whitespace in our string\n  // if we don't have any, we can return early.\n\n  if (children.length === string.length) {\n    return fullFormat;\n  } // if we do have whitespace, let's add our formatting around our trimmed string\n  // We reverse the right side formatting, to properly handle bold/italic and strikeThrough\n  // formats, so we can create ~~***FooBar***~~\n\n\n  var formattedString = format + children + reverseStr(format); // and replace the non-whitespace content of the string\n\n  return string.replace(frozenString, formattedString);\n}\n\nvar reverseStr = function reverseStr(string) {\n  return string.split('').reverse().join('');\n};\n\nfunction plugin(opts) {\n  var compiler = function compiler(node) {\n    return node.children.map(function (c) {\n      return deserialize(c, opts);\n    });\n  }; // @ts-ignore\n\n\n  this.Compiler = compiler;\n}\n\nexport default plugin;\nexport { defaultNodeTypes, deserialize, serialize };","map":{"version":3,"sources":["../src/deserialize.ts","../src/serialize.ts","../src/plugin.ts"],"names":["defaultNodeTypes","paragraph","block_quote","code_block","link","ul_list","ol_list","listItem","heading","emphasis_mark","strong_mark","delete_mark","inline_code_mark","thematic_break","image","deserialize","node","opts","types","linkDestinationKey","imageSourceKey","imageCaptionKey","children","text","Array","ordered","type","language","value","forceLeafNode","persistLeafFormats","k","Object","key","acc","isLeafNode","VOID_ELEMENTS","BREAK_TAG","serialize","chunk","nodeTypes","userNodeTypes","ignoreParagraphNewline","listDepth","LIST_TYPES","isList","c","selfIsList","childrenHasLink","f","parentType","retainWhitespaceAndFormat","isOL","spacer","escapeHtml","frozenString","string","fullFormat","reverseStr","formattedString","format","plugin","compiler","transform"],"mappings":"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","sourcesContent":["export interface NodeTypes {\n  paragraph: string;\n  block_quote: string;\n  code_block: string;\n  link: string;\n  image: string;\n  ul_list: string;\n  ol_list: string;\n  listItem: string;\n  heading: {\n    1: string;\n    2: string;\n    3: string;\n    4: string;\n    5: string;\n    6: string;\n  };\n  emphasis_mark: string;\n  strong_mark: string;\n  delete_mark: string;\n  inline_code_mark: string;\n  thematic_break: string;\n}\n\ntype RecursivePartial<T> = {\n  [P in keyof T]?: RecursivePartial<T[P]>;\n};\n\nexport interface OptionType {\n  nodeTypes?: RecursivePartial<NodeTypes>;\n  linkDestinationKey?: string;\n  imageSourceKey?: string;\n  imageCaptionKey?: string;\n}\n\nexport interface MdastNode {\n  type?: string;\n  ordered?: boolean;\n  value?: string;\n  text?: string;\n  children?: Array<MdastNode>;\n  depth?: 1 | 2 | 3 | 4 | 5 | 6;\n  url?: string;\n  alt?: string;\n  lang?: string;\n  // mdast metadata\n  position?: any;\n  spread?: any;\n  checked?: any;\n  indent?: any;\n}\n\nexport const defaultNodeTypes: NodeTypes = {\n  paragraph: 'paragraph',\n  block_quote: 'block_quote',\n  code_block: 'code_block',\n  link: 'link',\n  ul_list: 'ul_list',\n  ol_list: 'ol_list',\n  listItem: 'list_item',\n  heading: {\n    1: 'heading_one',\n    2: 'heading_two',\n    3: 'heading_three',\n    4: 'heading_four',\n    5: 'heading_five',\n    6: 'heading_six',\n  },\n  emphasis_mark: 'italic',\n  strong_mark: 'bold',\n  delete_mark: 'strikeThrough',\n  inline_code_mark: 'code',\n  thematic_break: 'thematic_break',\n  image: 'image',\n};\n\nexport default function deserialize(node: MdastNode, opts?: OptionType) {\n  const types = {\n    ...defaultNodeTypes,\n    ...opts?.nodeTypes,\n    heading: {\n      ...defaultNodeTypes.heading,\n      ...opts?.nodeTypes?.heading,\n    },\n  };\n\n  const linkDestinationKey = opts?.linkDestinationKey ?? 'link';\n  const imageSourceKey = opts?.imageSourceKey ?? 'link';\n  const imageCaptionKey = opts?.imageCaptionKey ?? 'caption';\n\n  let children = [{ text: '' }];\n\n  if (\n    node.children &&\n    Array.isArray(node.children) &&\n    node.children.length > 0\n  ) {\n    // @ts-ignore\n    children = node.children.map((c: MdastNode) =>\n      deserialize(\n        {\n          ...c,\n          ordered: node.ordered || false,\n        },\n        opts\n      )\n    );\n  }\n\n  switch (node.type) {\n    case 'heading':\n      return { type: types.heading[node.depth || 1], children };\n    case 'list':\n      return { type: node.ordered ? types.ol_list : types.ul_list, children };\n    case 'listItem':\n      return { type: types.listItem, children };\n    case 'paragraph':\n      return { type: types.paragraph, children };\n    case 'link':\n      return { type: types.link, [linkDestinationKey]: node.url, children };\n    case 'image':\n      return {\n        type: types.image,\n        children: [{ text: '' }],\n        [imageSourceKey]: node.url,\n        [imageCaptionKey]: node.alt,\n      };\n    case 'blockquote':\n      return { type: types.block_quote, children };\n    case 'code':\n      return {\n        type: types.code_block,\n        language: node.lang,\n        children: [{ text: node.value }],\n      };\n\n    case 'html':\n      if (node.value?.includes('<br>')) {\n        return {\n          break: true,\n          type: types.paragraph,\n          children: [{ text: node.value?.replace(/<br>/g, '') || '' }],\n        };\n      }\n      return { type: 'paragraph', children: [{ text: node.value || '' }] };\n\n    case 'emphasis':\n      return {\n        [types.emphasis_mark]: true,\n        ...forceLeafNode(children),\n        ...persistLeafFormats(children),\n      };\n    case 'strong':\n      return {\n        [types.strong_mark]: true,\n        ...forceLeafNode(children),\n        ...persistLeafFormats(children),\n      };\n    case 'delete':\n      return {\n        [types.delete_mark]: true,\n        ...forceLeafNode(children),\n        ...persistLeafFormats(children),\n      };\n    case 'inlineCode':\n      return {\n        [types.inline_code_mark]: true,\n        text: node.value,\n        ...persistLeafFormats(children),\n      };\n    case 'thematicBreak':\n      return {\n        type: types.thematic_break,\n        children: [{ text: '' }],\n      };\n\n    case 'text':\n    default:\n      return { text: node.value || '' };\n  }\n}\n\nconst forceLeafNode = (children: Array<{ text?: string }>) => ({\n  text: children.map((k) => k?.text).join(''),\n});\n\n// This function is will take any unknown keys, and bring them up a level\n// allowing leaf nodes to have many different formats at once\n// for example, bold and italic on the same node\nfunction persistLeafFormats(children: Array<MdastNode>) {\n  return children.reduce((acc, node) => {\n    Object.keys(node).forEach(function (key) {\n      if (key === 'children' || key === 'type' || key === 'text') return;\n\n      // @ts-ignore\n      acc[key] = node[key];\n    });\n\n    return acc;\n  }, {});\n}\n","import escapeHtml from 'escape-html';\n\nimport { defaultNodeTypes, NodeTypes } from './deserialize';\n\nexport interface LeafType {\n  text: string;\n  strikeThrough?: boolean;\n  bold?: boolean;\n  italic?: boolean;\n  code?: boolean;\n  parentType?: string;\n}\n\nexport interface BlockType {\n  type: string;\n  parentType?: string;\n  link?: string;\n  caption?: string;\n  language?: string;\n  break?: boolean;\n  children: Array<BlockType | LeafType>;\n}\n\ninterface Options {\n  nodeTypes: NodeTypes;\n  listDepth?: number;\n  ignoreParagraphNewline?: boolean;\n}\n\nconst isLeafNode = (node: BlockType | LeafType): node is LeafType => {\n  return typeof (node as LeafType).text === 'string';\n};\n\nconst VOID_ELEMENTS: Array<keyof NodeTypes> = ['thematic_break'];\n\nconst BREAK_TAG = '<br>';\n\nexport default function serialize(\n  chunk: BlockType | LeafType,\n  opts: Options = { nodeTypes: defaultNodeTypes }\n) {\n  const {\n    nodeTypes: userNodeTypes = defaultNodeTypes,\n    ignoreParagraphNewline = false,\n    listDepth = 0,\n  } = opts;\n\n  let text = (chunk as LeafType).text || '';\n  let type = (chunk as BlockType).type || '';\n\n  const nodeTypes: NodeTypes = {\n    ...defaultNodeTypes,\n    ...userNodeTypes,\n    heading: {\n      ...defaultNodeTypes.heading,\n      ...userNodeTypes.heading,\n    },\n  };\n\n  const LIST_TYPES = [nodeTypes.ul_list, nodeTypes.ol_list];\n\n  let children = text;\n\n  if (!isLeafNode(chunk)) {\n    children = chunk.children\n      .map((c: BlockType | LeafType) => {\n        const isList = !isLeafNode(c)\n          ? LIST_TYPES.includes(c.type || '')\n          : false;\n\n        const selfIsList = LIST_TYPES.includes(chunk.type || '');\n\n        // Links can have the following shape\n        // In which case we don't want to surround\n        // with break tags\n        // {\n        //  type: 'paragraph',\n        //  children: [\n        //    { text: '' },\n        //    { type: 'link', children: [{ text: foo.com }]}\n        //    { text: '' }\n        //  ]\n        // }\n        let childrenHasLink = false;\n\n        if (!isLeafNode(chunk) && Array.isArray(chunk.children)) {\n          childrenHasLink = chunk.children.some(\n            (f) => !isLeafNode(f) && f.type === nodeTypes.link\n          );\n        }\n\n        return serialize(\n          { ...c, parentType: type },\n          {\n            nodeTypes,\n            // WOAH.\n            // what we're doing here is pretty tricky, it relates to the block below where\n            // we check for ignoreParagraphNewline and set type to paragraph.\n            // We want to strip out empty paragraphs sometimes, but other times we don't.\n            // If we're the descendant of a list, we know we don't want a bunch\n            // of whitespace. If we're parallel to a link we also don't want\n            // to respect neighboring paragraphs\n            ignoreParagraphNewline:\n              (ignoreParagraphNewline ||\n                isList ||\n                selfIsList ||\n                childrenHasLink) &&\n              // if we have c.break, never ignore empty paragraph new line\n              !(c as BlockType).break,\n\n            // track depth of nested lists so we can add proper spacing\n            listDepth: LIST_TYPES.includes((c as BlockType).type || '')\n              ? listDepth + 1\n              : listDepth,\n          }\n        );\n      })\n      .join('');\n  }\n\n  // This is pretty fragile code, check the long comment where we iterate over children\n  if (\n    !ignoreParagraphNewline &&\n    (text === '' || text === '\\n') &&\n    chunk.parentType === nodeTypes.paragraph\n  ) {\n    type = nodeTypes.paragraph;\n    children = BREAK_TAG;\n  }\n\n  if (children === '' && !VOID_ELEMENTS.find((k) => nodeTypes[k] === type))\n    return;\n\n  // Never allow decorating break tags with rich text formatting,\n  // this can malform generated markdown\n  // Also ensure we're only ever applying text formatting to leaf node\n  // level chunks, otherwise we can end up in a situation where\n  // we try applying formatting like to a node like this:\n  // \"Text foo bar **baz**\" resulting in \"**Text foo bar **baz****\"\n  // which is invalid markup and can mess everything up\n  if (children !== BREAK_TAG && isLeafNode(chunk)) {\n    if (chunk.strikeThrough && chunk.bold && chunk.italic) {\n      children = retainWhitespaceAndFormat(children, '~~***');\n    } else if (chunk.bold && chunk.italic) {\n      children = retainWhitespaceAndFormat(children, '***');\n    } else {\n      if (chunk.bold) {\n        children = retainWhitespaceAndFormat(children, '**');\n      }\n\n      if (chunk.italic) {\n        children = retainWhitespaceAndFormat(children, '_');\n      }\n\n      if (chunk.strikeThrough) {\n        children = retainWhitespaceAndFormat(children, '~~');\n      }\n\n      if (chunk.code) {\n        children = retainWhitespaceAndFormat(children, '`');\n      }\n    }\n  }\n\n  switch (type) {\n    case nodeTypes.heading[1]:\n      return `# ${children}\\n`;\n    case nodeTypes.heading[2]:\n      return `## ${children}\\n`;\n    case nodeTypes.heading[3]:\n      return `### ${children}\\n`;\n    case nodeTypes.heading[4]:\n      return `#### ${children}\\n`;\n    case nodeTypes.heading[5]:\n      return `##### ${children}\\n`;\n    case nodeTypes.heading[6]:\n      return `###### ${children}\\n`;\n\n    case nodeTypes.block_quote:\n      // For some reason, marked is parsing blockquotes w/ one new line\n      // as contiued blockquotes, so adding two new lines ensures that doesn't\n      // happen\n      return `> ${children}\\n\\n`;\n\n    case nodeTypes.code_block:\n      return `\\`\\`\\`${\n        (chunk as BlockType).language || ''\n      }\\n${children}\\n\\`\\`\\`\\n`;\n\n    case nodeTypes.link:\n      return `[${children}](${(chunk as BlockType).link || ''})`;\n    case nodeTypes.image:\n      return `![${(chunk as BlockType).caption}](${\n        (chunk as BlockType).link || ''\n      })`;\n\n    case nodeTypes.ul_list:\n    case nodeTypes.ol_list:\n      return `\\n${children}\\n`;\n\n    case nodeTypes.listItem:\n      const isOL = chunk && chunk.parentType === nodeTypes.ol_list;\n\n      let spacer = '';\n      for (let k = 0; listDepth > k; k++) {\n        if (isOL) {\n          // https://github.com/remarkjs/remark-react/issues/65\n          spacer += '   ';\n        } else {\n          spacer += '  ';\n        }\n      }\n      return `${spacer}${isOL ? '1.' : '-'} ${children}`;\n\n    case nodeTypes.paragraph:\n      return `${children}\\n`;\n\n    case nodeTypes.thematic_break:\n      return `---\\n`;\n\n    default:\n      return escapeHtml(children);\n  }\n}\n\n// This function handles the case of a string like this: \"   foo   \"\n// Where it would be invalid markdown to generate this: \"**   foo   **\"\n// We instead, want to trim the whitespace out, apply formatting, and then\n// bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\nfunction retainWhitespaceAndFormat(string: string, format: string) {\n  // we keep this for a comparison later\n  const frozenString = string.trim();\n\n  // children will be mutated\n  let children = frozenString;\n\n  // We reverse the right side formatting, to properly handle bold/italic and strikeThrough\n  // formats, so we can create ~~***FooBar***~~\n  const fullFormat = `${format}${children}${reverseStr(format)}`;\n\n  // This conditions accounts for no whitespace in our string\n  // if we don't have any, we can return early.\n  if (children.length === string.length) {\n    return fullFormat;\n  }\n\n  // if we do have whitespace, let's add our formatting around our trimmed string\n  // We reverse the right side formatting, to properly handle bold/italic and strikeThrough\n  // formats, so we can create ~~***FooBar***~~\n  const formattedString = format + children + reverseStr(format);\n\n  // and replace the non-whitespace content of the string\n  return string.replace(frozenString, formattedString);\n}\n\nconst reverseStr = (string: string) => string.split('').reverse().join('');\n","import transform, { OptionType, MdastNode } from './deserialize';\n\nexport default function plugin(opts?: OptionType) {\n  const compiler = (node: { children: Array<MdastNode> }) => {\n    return node.children.map((c) => transform(c, opts));\n  };\n\n  // @ts-ignore\n  this.Compiler = compiler;\n}\n"]},"metadata":{},"sourceType":"module"}