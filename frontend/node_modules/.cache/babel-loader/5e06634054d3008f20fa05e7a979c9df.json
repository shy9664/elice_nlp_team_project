{"ast":null,"code":"import { findNode, getPluginType, getPlugin, insertNodes, createPluginFactory, getBlockAbove } from '@udecode/plate-core';\nimport { Range, Transforms, Editor, Node } from 'slate';\nimport { comboboxStore } from '@udecode/plate-combobox';\nimport { HistoryEditor } from 'slate-history';\n\nconst moveSelectionByOffset = (editor, {\n  query = () => true\n}) => event => {\n  const {\n    selection\n  } = editor;\n\n  if (!selection || Range.isExpanded(selection) || !query(editor)) {\n    return false;\n  }\n\n  if (event.key === 'ArrowLeft') {\n    event.preventDefault();\n    Transforms.move(editor, {\n      unit: 'offset',\n      reverse: true\n    });\n    return true;\n  }\n\n  if (event.key === 'ArrowRight') {\n    event.preventDefault();\n    Transforms.move(editor, {\n      unit: 'offset'\n    });\n    return true;\n  }\n};\n\nconst findMentionInput = (editor, options) => findNode(editor, { ...options,\n  match: {\n    type: getPluginType(editor, ELEMENT_MENTION_INPUT)\n  }\n});\n\nconst isNodeMentionInput = (editor, node) => {\n  return node.type === getPluginType(editor, ELEMENT_MENTION_INPUT);\n};\n\nconst isSelectionInMentionInput = editor => findMentionInput(editor) !== undefined;\n\nconst removeMentionInput = (editor, path) => Editor.withoutNormalizing(editor, () => {\n  const {\n    trigger\n  } = Node.get(editor, path);\n  Transforms.insertText(editor, trigger, {\n    at: {\n      path: [...path, 0],\n      offset: 0\n    }\n  });\n  Transforms.unwrapNodes(editor, {\n    at: path\n  });\n});\n\nconst withMention = (editor, {\n  options: {\n    id,\n    trigger\n  }\n}) => {\n  const {\n    type\n  } = getPlugin(editor, ELEMENT_MENTION_INPUT);\n  const {\n    apply,\n    insertText,\n    deleteBackward\n  } = editor;\n\n  editor.deleteBackward = unit => {\n    const currentMentionInput = findMentionInput(editor);\n\n    if (currentMentionInput && Node.string(currentMentionInput[0]) === '') {\n      return removeMentionInput(editor, currentMentionInput[1]);\n    }\n\n    deleteBackward(unit);\n  };\n\n  editor.insertText = text => {\n    if (isSelectionInMentionInput(editor)) {\n      return Transforms.insertText(editor, text);\n    }\n\n    if (!editor.selection || text !== trigger) {\n      return insertText(text);\n    } // Make sure a mention input is created at the beginning of line or after a whitespace\n\n\n    const previousCharLocation = Editor.before(editor, editor.selection);\n\n    if (previousCharLocation) {\n      const previousChar = Editor.string(editor, Editor.range(editor, editor.selection, previousCharLocation));\n\n      if (previousChar !== '' && previousChar !== ' ') {\n        return insertText(text);\n      }\n    }\n\n    insertNodes(editor, {\n      type,\n      children: [{\n        text: ''\n      }],\n      trigger\n    });\n  };\n\n  editor.apply = operation => {\n    if (HistoryEditor.isHistoryEditor(editor) && findMentionInput(editor)) {\n      HistoryEditor.withoutSaving(editor, () => apply(operation));\n    } else {\n      apply(operation);\n    }\n\n    if (operation.type === 'insert_text' || operation.type === 'remove_text') {\n      const currentMentionInput = findMentionInput(editor);\n\n      if (currentMentionInput) {\n        comboboxStore.set.text(Node.string(currentMentionInput[0]));\n      }\n    } else if (operation.type === 'set_selection') {\n      var _findMentionInput, _findMentionInput2;\n\n      const previousMentionInputPath = Range.isRange(operation.properties) ? (_findMentionInput = findMentionInput(editor, {\n        at: operation.properties\n      })) === null || _findMentionInput === void 0 ? void 0 : _findMentionInput[1] : undefined;\n      const currentMentionInputPath = Range.isRange(operation.newProperties) ? (_findMentionInput2 = findMentionInput(editor, {\n        at: operation.newProperties\n      })) === null || _findMentionInput2 === void 0 ? void 0 : _findMentionInput2[1] : undefined;\n\n      if (previousMentionInputPath && !currentMentionInputPath) {\n        removeMentionInput(editor, previousMentionInputPath);\n      }\n\n      if (currentMentionInputPath) {\n        comboboxStore.set.targetRange(editor.selection);\n      }\n    } else if (operation.type === 'insert_node' && isNodeMentionInput(editor, operation.node)) {\n      if (operation.node.trigger !== trigger) {\n        return;\n      }\n\n      comboboxStore.set.open({\n        activeId: id,\n        text: '',\n        targetRange: editor.selection\n      });\n    } else if (operation.type === 'remove_node' && isNodeMentionInput(editor, operation.node)) {\n      if (operation.node.trigger !== trigger) {\n        return;\n      }\n\n      comboboxStore.set.reset();\n    }\n  };\n\n  return editor;\n};\n\nconst ELEMENT_MENTION = 'mention';\nconst ELEMENT_MENTION_INPUT = 'mention_input';\n/**\n * Enables support for autocompleting @mentions.\n */\n\nconst createMentionPlugin = createPluginFactory({\n  key: ELEMENT_MENTION,\n  isElement: true,\n  isInline: true,\n  isVoid: true,\n  handlers: {\n    onKeyDown: editor => moveSelectionByOffset(editor, {\n      query: isSelectionInMentionInput\n    })\n  },\n  withOverrides: withMention,\n  options: {\n    trigger: '@',\n    createMentionNode: item => ({\n      value: item.text\n    })\n  },\n  plugins: [{\n    key: ELEMENT_MENTION_INPUT,\n    isElement: true,\n    isInline: true\n  }],\n  then: (editor, {\n    key\n  }) => ({\n    options: {\n      id: key\n    }\n  })\n});\n\nconst getMentionOnSelectItem = ({\n  key = ELEMENT_MENTION\n} = {}) => (editor, item) => {\n  var _getBlockAbove;\n\n  const targetRange = comboboxStore.get.targetRange();\n  if (!targetRange) return;\n  const {\n    type,\n    options: {\n      insertSpaceAfterMention,\n      createMentionNode\n    }\n  } = getPlugin(editor, key);\n  const pathAbove = (_getBlockAbove = getBlockAbove(editor)) === null || _getBlockAbove === void 0 ? void 0 : _getBlockAbove[1];\n  const isBlockEnd = editor.selection && pathAbove && Editor.isEnd(editor, editor.selection.anchor, pathAbove);\n  Editor.withoutNormalizing(editor, () => {\n    // insert a space to fix the bug\n    if (isBlockEnd) {\n      Transforms.insertText(editor, ' ');\n    } // select the text and insert the element\n\n\n    Transforms.select(editor, targetRange);\n    Transforms.removeNodes(editor, {\n      // TODO: replace any\n      match: node => node.type === ELEMENT_MENTION_INPUT\n    });\n    insertNodes(editor, {\n      type: type,\n      children: [{\n        text: ''\n      }],\n      ...createMentionNode(item)\n    }); // move the selection after the element\n\n    Transforms.move(editor); // delete the inserted space\n\n    if (isBlockEnd && !insertSpaceAfterMention) {\n      Transforms.delete(editor);\n    }\n  });\n  return comboboxStore.set.reset();\n};\n\nexport { ELEMENT_MENTION, ELEMENT_MENTION_INPUT, createMentionPlugin, findMentionInput, getMentionOnSelectItem, isNodeMentionInput, isSelectionInMentionInput, moveSelectionByOffset, removeMentionInput, withMention };","map":{"version":3,"sources":["../src/moveSelectionByOffset.ts","../src/queries/findMentionInput.ts","../src/queries/isNodeMentionInput.ts","../src/queries/isSelectionInMentionInput.ts","../src/transforms/removeMentionInput.ts","../src/withMention.ts","../src/createMentionPlugin.ts","../src/getMentionOnSelectItem.ts"],"names":["moveSelectionByOffset","query","event","selection","Range","Transforms","unit","reverse","findMentionInput","findNode","match","type","getPluginType","isNodeMentionInput","node","isSelectionInMentionInput","editor","undefined","removeMentionInput","trigger","Node","at","path","offset","withMention","options","getPlugin","deleteBackward","currentMentionInput","text","insertText","previousCharLocation","Editor","previousChar","insertNodes","children","operation","HistoryEditor","apply","comboboxStore","previousMentionInputPath","properties","currentMentionInputPath","newProperties","activeId","targetRange","ELEMENT_MENTION","ELEMENT_MENTION_INPUT","createMentionPlugin","createPluginFactory","key","isElement","isInline","isVoid","handlers","onKeyDown","withOverrides","createMentionNode","item","value","plugins","then","id","getMentionOnSelectItem","pathAbove","getBlockAbove","isBlockEnd"],"mappings":"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","sourcesContent":["import { KeyboardEvent } from 'react';\nimport { PlateEditor } from '@udecode/plate-core';\nimport { HandlerReturnType } from '@udecode/plate-core/src';\nimport { Range, Transforms } from 'slate';\n\nexport const moveSelectionByOffset = (\n  editor: PlateEditor,\n  { query = () => true }: { query: (editor: PlateEditor) => boolean }\n) => (event: KeyboardEvent): HandlerReturnType => {\n  const { selection } = editor;\n  if (!selection || Range.isExpanded(selection) || !query(editor)) {\n    return false;\n  }\n\n  if (event.key === 'ArrowLeft') {\n    event.preventDefault();\n    Transforms.move(editor, { unit: 'offset', reverse: true });\n    return true;\n  }\n\n  if (event.key === 'ArrowRight') {\n    event.preventDefault();\n    Transforms.move(editor, { unit: 'offset' });\n    return true;\n  }\n};\n","import {\n  findNode,\n  FindNodeOptions,\n  getPluginType,\n  PlateEditor,\n} from '@udecode/plate-core';\nimport { ELEMENT_MENTION_INPUT } from '../createMentionPlugin';\n\nexport const findMentionInput = (\n  editor: PlateEditor,\n  options?: Omit<FindNodeOptions, 'match'>\n) =>\n  findNode(editor, {\n    ...options,\n    match: { type: getPluginType(editor, ELEMENT_MENTION_INPUT) },\n  });\n","import { getPluginType, PlateEditor, TDescendant } from '@udecode/plate-core';\nimport { ELEMENT_MENTION_INPUT } from '../createMentionPlugin';\nimport { MentionInputNode } from '../types';\n\nexport const isNodeMentionInput = (\n  editor: PlateEditor,\n  node: TDescendant\n): node is MentionInputNode => {\n  return node.type === getPluginType(editor, ELEMENT_MENTION_INPUT);\n};\n","import { PlateEditor } from '@udecode/plate-core';\nimport { findMentionInput } from './findMentionInput';\n\nexport const isSelectionInMentionInput = (editor: PlateEditor) =>\n  findMentionInput(editor) !== undefined;\n","import { PlateEditor, TDescendant } from '@udecode/plate-core';\nimport { Editor, Node, Path, Transforms } from 'slate';\n\nexport const removeMentionInput = (editor: PlateEditor, path: Path) =>\n  Editor.withoutNormalizing(editor, () => {\n    const { trigger } = Node.get(editor, path) as TDescendant;\n\n    Transforms.insertText(editor, trigger, {\n      at: { path: [...path, 0], offset: 0 },\n    });\n    Transforms.unwrapNodes(editor, {\n      at: path,\n    });\n  });\n","import { comboboxStore } from '@udecode/plate-combobox';\nimport { getPlugin, insertNodes, WithOverride } from '@udecode/plate-core';\nimport { Editor, Node, Range, Transforms } from 'slate';\nimport { HistoryEditor } from 'slate-history';\nimport { removeMentionInput } from './transforms/removeMentionInput';\nimport { ELEMENT_MENTION_INPUT } from './createMentionPlugin';\nimport {\n  findMentionInput,\n  isNodeMentionInput,\n  isSelectionInMentionInput,\n} from './queries';\nimport { MentionInputNode, MentionPlugin } from './types';\n\nexport const withMention: WithOverride<{}, MentionPlugin> = (\n  editor,\n  { options: { id, trigger } }\n) => {\n  const { type } = getPlugin(editor, ELEMENT_MENTION_INPUT);\n\n  const { apply, insertText, deleteBackward } = editor;\n\n  editor.deleteBackward = (unit) => {\n    const currentMentionInput = findMentionInput(editor);\n    if (currentMentionInput && Node.string(currentMentionInput[0]) === '') {\n      return removeMentionInput(editor, currentMentionInput[1]);\n    }\n\n    deleteBackward(unit);\n  };\n\n  editor.insertText = (text) => {\n    if (isSelectionInMentionInput(editor)) {\n      return Transforms.insertText(editor, text);\n    }\n\n    if (!editor.selection || text !== trigger) {\n      return insertText(text);\n    }\n\n    // Make sure a mention input is created at the beginning of line or after a whitespace\n    const previousCharLocation = Editor.before(editor, editor.selection);\n    if (previousCharLocation) {\n      const previousChar = Editor.string(\n        editor,\n        Editor.range(editor, editor.selection, previousCharLocation)\n      );\n      if (previousChar !== '' && previousChar !== ' ') {\n        return insertText(text);\n      }\n    }\n\n    insertNodes<MentionInputNode>(editor, {\n      type,\n      children: [{ text: '' }],\n      trigger,\n    });\n  };\n\n  editor.apply = (operation) => {\n    if (HistoryEditor.isHistoryEditor(editor) && findMentionInput(editor)) {\n      HistoryEditor.withoutSaving(editor, () => apply(operation));\n    } else {\n      apply(operation);\n    }\n\n    if (operation.type === 'insert_text' || operation.type === 'remove_text') {\n      const currentMentionInput = findMentionInput(editor);\n      if (currentMentionInput) {\n        comboboxStore.set.text(Node.string(currentMentionInput[0]));\n      }\n    } else if (operation.type === 'set_selection') {\n      const previousMentionInputPath = Range.isRange(operation.properties)\n        ? findMentionInput(editor, { at: operation.properties })?.[1]\n        : undefined;\n\n      const currentMentionInputPath = Range.isRange(operation.newProperties)\n        ? findMentionInput(editor, { at: operation.newProperties })?.[1]\n        : undefined;\n\n      if (previousMentionInputPath && !currentMentionInputPath) {\n        removeMentionInput(editor, previousMentionInputPath);\n      }\n\n      if (currentMentionInputPath) {\n        comboboxStore.set.targetRange(editor.selection);\n      }\n    } else if (\n      operation.type === 'insert_node' &&\n      isNodeMentionInput(editor, operation.node)\n    ) {\n      if (operation.node.trigger !== trigger) {\n        return;\n      }\n\n      comboboxStore.set.open({\n        activeId: id!,\n        text: '',\n        targetRange: editor.selection,\n      });\n    } else if (\n      operation.type === 'remove_node' &&\n      isNodeMentionInput(editor, operation.node)\n    ) {\n      if (operation.node.trigger !== trigger) {\n        return;\n      }\n\n      comboboxStore.set.reset();\n    }\n  };\n\n  return editor;\n};\n","import { createPluginFactory } from '@udecode/plate-core';\nimport { moveSelectionByOffset } from './moveSelectionByOffset';\nimport { isSelectionInMentionInput } from './queries';\nimport { MentionPlugin } from './types';\nimport { withMention } from './withMention';\n\nexport const ELEMENT_MENTION = 'mention';\nexport const ELEMENT_MENTION_INPUT = 'mention_input';\n\n/**\n * Enables support for autocompleting @mentions.\n */\nexport const createMentionPlugin = createPluginFactory<MentionPlugin>({\n  key: ELEMENT_MENTION,\n  isElement: true,\n  isInline: true,\n  isVoid: true,\n  handlers: {\n    onKeyDown: (editor) =>\n      moveSelectionByOffset(editor, { query: isSelectionInMentionInput }),\n  },\n  withOverrides: withMention,\n  options: {\n    trigger: '@',\n    createMentionNode: (item) => ({ value: item.text }),\n  },\n  plugins: [\n    {\n      key: ELEMENT_MENTION_INPUT,\n      isElement: true,\n      isInline: true,\n    },\n  ],\n  then: (editor, { key }) => ({\n    options: {\n      id: key,\n    },\n  }),\n});\n","import {\n  ComboboxOnSelectItem,\n  comboboxStore,\n  Data,\n  NoData,\n  TComboboxItem,\n} from '@udecode/plate-combobox';\nimport {\n  getBlockAbove,\n  getPlugin,\n  insertNodes,\n  PlatePluginKey,\n} from '@udecode/plate-core';\nimport { Editor, Transforms } from 'slate';\nimport { ELEMENT_MENTION, ELEMENT_MENTION_INPUT } from './createMentionPlugin';\nimport { MentionNode, MentionNodeData, MentionPlugin } from './types';\n\nexport interface CreateMentionNode<TData extends Data> {\n  (item: TComboboxItem<TData>): MentionNodeData;\n}\n\nexport const getMentionOnSelectItem = <TData extends Data = NoData>({\n  key = ELEMENT_MENTION,\n}: PlatePluginKey = {}): ComboboxOnSelectItem<TData> => (editor, item) => {\n  const targetRange = comboboxStore.get.targetRange();\n  if (!targetRange) return;\n\n  const {\n    type,\n    options: { insertSpaceAfterMention, createMentionNode },\n  } = getPlugin<MentionPlugin>(editor, key);\n\n  const pathAbove = getBlockAbove(editor)?.[1];\n  const isBlockEnd =\n    editor.selection &&\n    pathAbove &&\n    Editor.isEnd(editor, editor.selection.anchor, pathAbove);\n\n  Editor.withoutNormalizing(editor, () => {\n    // insert a space to fix the bug\n    if (isBlockEnd) {\n      Transforms.insertText(editor, ' ');\n    }\n\n    // select the text and insert the element\n    Transforms.select(editor, targetRange);\n\n    Transforms.removeNodes(editor, {\n      // TODO: replace any\n      match: (node: any) => node.type === ELEMENT_MENTION_INPUT,\n    });\n\n    insertNodes<MentionNode>(editor, {\n      type: type!,\n      children: [{ text: '' }],\n      ...createMentionNode!(item),\n    });\n    // move the selection after the element\n    Transforms.move(editor);\n\n    // delete the inserted space\n    if (isBlockEnd && !insertSpaceAfterMention) {\n      Transforms.delete(editor);\n    }\n  });\n  return comboboxStore.set.reset();\n};\n"]},"metadata":{},"sourceType":"module"}