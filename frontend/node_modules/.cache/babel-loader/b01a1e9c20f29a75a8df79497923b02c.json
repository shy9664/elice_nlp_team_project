{"ast":null,"code":"'use strict';\n\nvar parser = require('slick/parser');\n\nmodule.exports = exports = Selector;\n/**\r\n * CSS selector constructor.\r\n *\r\n * @param {String} selector text\r\n * @param {Array} optionally, precalculated specificity\r\n * @api public\r\n */\n\nfunction Selector(text, styleAttribute) {\n  this.text = text;\n  this.spec = undefined;\n  this.styleAttribute = styleAttribute || false;\n}\n/**\r\n * Get parsed selector.\r\n *\r\n * @api public\r\n */\n\n\nSelector.prototype.parsed = function () {\n  if (!this.tokens) {\n    this.tokens = parse(this.text);\n  }\n\n  return this.tokens;\n};\n/**\r\n * Lazy specificity getter\r\n *\r\n * @api public\r\n */\n\n\nSelector.prototype.specificity = function () {\n  var styleAttribute = this.styleAttribute;\n\n  if (!this.spec) {\n    this.spec = specificity(this.text, this.parsed());\n  }\n\n  return this.spec;\n\n  function specificity(text, parsed) {\n    var expressions = parsed || parse(text);\n    var spec = [styleAttribute ? 1 : 0, 0, 0, 0];\n    var nots = [];\n\n    for (var i = 0; i < expressions.length; i++) {\n      var expression = expressions[i];\n      var pseudos = expression.pseudos; // id awards a point in the second column\n\n      if (expression.id) {\n        spec[1]++;\n      } // classes and attributes award a point each in the third column\n\n\n      if (expression.attributes) {\n        spec[2] += expression.attributes.length;\n      }\n\n      if (expression.classList) {\n        spec[2] += expression.classList.length;\n      } // tag awards a point in the fourth column\n\n\n      if (expression.tag && expression.tag !== '*') {\n        spec[3]++;\n      } // pseudos award a point each in the fourth column\n\n\n      if (pseudos) {\n        spec[3] += pseudos.length;\n\n        for (var p = 0; p < pseudos.length; p++) {\n          if (pseudos[p].name === 'not') {\n            nots.push(pseudos[p].value);\n            spec[3]--;\n          }\n        }\n      }\n    }\n\n    for (var ii = nots.length; ii--;) {\n      var not = specificity(nots[ii]);\n\n      for (var jj = 4; jj--;) {\n        spec[jj] += not[jj];\n      }\n    }\n\n    return spec;\n  }\n};\n/**\r\n * Parses a selector and returns the tokens.\r\n *\r\n * @param {String} selector\r\n * @api private.\r\n */\n\n\nfunction parse(text) {\n  try {\n    return parser(text)[0];\n  } catch (e) {\n    return [];\n  }\n}","map":{"version":3,"sources":["C:/Users/ghdus/OneDrive/바탕 화면/team-project/nlp-project-team2/frontend/node_modules/juice/lib/selector.js"],"names":["parser","require","module","exports","Selector","text","styleAttribute","spec","undefined","prototype","parsed","tokens","parse","specificity","expressions","nots","i","length","expression","pseudos","id","attributes","classList","tag","p","name","push","value","ii","not","jj","e"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar parser = require('slick/parser');\r\n\r\nmodule.exports = exports = Selector;\r\n\r\n/**\r\n * CSS selector constructor.\r\n *\r\n * @param {String} selector text\r\n * @param {Array} optionally, precalculated specificity\r\n * @api public\r\n */\r\n\r\nfunction Selector(text, styleAttribute) {\r\n  this.text = text;\r\n  this.spec = undefined;\r\n  this.styleAttribute = styleAttribute || false;\r\n}\r\n\r\n/**\r\n * Get parsed selector.\r\n *\r\n * @api public\r\n */\r\n\r\nSelector.prototype.parsed = function() {\r\n  if (!this.tokens) { this.tokens = parse(this.text); }\r\n  return this.tokens;\r\n};\r\n\r\n/**\r\n * Lazy specificity getter\r\n *\r\n * @api public\r\n */\r\n\r\nSelector.prototype.specificity = function() {\r\n  var styleAttribute = this.styleAttribute;\r\n  if (!this.spec) { this.spec = specificity(this.text, this.parsed()); }\r\n  return this.spec;\r\n\r\n  function specificity(text, parsed) {\r\n    var expressions = parsed || parse(text);\r\n    var spec = [styleAttribute ? 1 : 0, 0, 0, 0];\r\n    var nots = [];\r\n\r\n    for (var i = 0; i < expressions.length; i++) {\r\n      var expression = expressions[i];\r\n      var pseudos = expression.pseudos;\r\n\r\n      // id awards a point in the second column\r\n      if (expression.id) { spec[1]++; }\r\n\r\n      // classes and attributes award a point each in the third column\r\n      if (expression.attributes) { spec[2] += expression.attributes.length; }\r\n      if (expression.classList) { spec[2] += expression.classList.length; }\r\n\r\n      // tag awards a point in the fourth column\r\n      if (expression.tag && expression.tag !== '*') { spec[3]++; }\r\n\r\n      // pseudos award a point each in the fourth column\r\n      if (pseudos) {\r\n        spec[3] += pseudos.length;\r\n\r\n        for (var p = 0; p < pseudos.length; p++) {\r\n          if (pseudos[p].name === 'not') {\r\n            nots.push(pseudos[p].value);\r\n            spec[3]--;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    for (var ii = nots.length; ii--;) {\r\n      var not = specificity(nots[ii]);\r\n      for (var jj = 4; jj--;) { spec[jj] += not[jj]; }\r\n    }\r\n\r\n    return spec;\r\n  }\r\n};\r\n\r\n/**\r\n * Parses a selector and returns the tokens.\r\n *\r\n * @param {String} selector\r\n * @api private.\r\n */\r\n\r\nfunction parse(text) {\r\n  try {\r\n    return parser(text)[0];\r\n  } catch (e) {\r\n    return [];\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}