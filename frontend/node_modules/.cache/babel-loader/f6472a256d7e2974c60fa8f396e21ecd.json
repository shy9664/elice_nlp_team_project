{"ast":null,"code":"/*\r\nSlick Parser\r\n - originally created by the almighty Thomas Aylott <@subtlegradient> (http://subtlegradient.com)\r\n*/\n\"use strict\"; // Notable changes from Slick.Parser 1.0.x\n// The parser now uses 2 classes: Expressions and Expression\n// `new Expressions` produces an array-like object containing a list of Expression objects\n// - Expressions::toString() produces a cleaned up expressions string\n// `new Expression` produces an array-like object\n// - Expression::toString() produces a cleaned up expression string\n// The only exposed method is parse, which produces a (cached) `new Expressions` instance\n// parsed.raw is no longer present, use .toString()\n// parsed.expression is now useless, just use the indices\n// parsed.reverse() has been removed for now, due to its apparent uselessness\n// Other changes in the Expressions object:\n// - classNames are now unique, and save both escaped and unescaped values\n// - attributes now save both escaped and unescaped values\n// - pseudos now save both escaped and unescaped values\n\nvar escapeRe = /([-.*+?^${}()|[\\]\\/\\\\])/g,\n    unescapeRe = /\\\\/g;\n\nvar escape = function (string) {\n  // XRegExp v2.0.0-beta-3\n  // « https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js\n  return (string + \"\").replace(escapeRe, '\\\\$1');\n};\n\nvar unescape = function (string) {\n  return (string + \"\").replace(unescapeRe, '');\n};\n\nvar slickRe = RegExp(\n/*\r\n#!/usr/bin/env ruby\r\nputs \"\\t\\t\" + DATA.read.gsub(/\\(\\?x\\)|\\s+#.*$|\\s+|\\\\$|\\\\n/,'')\r\n__END__\r\n    \"(?x)^(?:\\\r\n      \\\\s* ( , ) \\\\s*               # Separator          \\n\\\r\n    | \\\\s* ( <combinator>+ ) \\\\s*   # Combinator         \\n\\\r\n    |      ( \\\\s+ )                 # CombinatorChildren \\n\\\r\n    |      ( <unicode>+ | \\\\* )     # Tag                \\n\\\r\n    | \\\\#  ( <unicode>+       )     # ID                 \\n\\\r\n    | \\\\.  ( <unicode>+       )     # ClassName          \\n\\\r\n    |                               # Attribute          \\n\\\r\n    \\\\[  \\\r\n        \\\\s* (<unicode1>+)  (?:  \\\r\n            \\\\s* ([*^$!~|]?=)  (?:  \\\r\n                \\\\s* (?:\\\r\n                    ([\\\"']?)(.*?)\\\\9 \\\r\n                )\\\r\n            )  \\\r\n        )?  \\\\s*  \\\r\n    \\\\](?!\\\\]) \\n\\\r\n    |   :+ ( <unicode>+ )(?:\\\r\n    \\\\( (?:\\\r\n        (?:([\\\"'])([^\\\\12]*)\\\\12)|((?:\\\\([^)]+\\\\)|[^()]*)+)\\\r\n    ) \\\\)\\\r\n    )?\\\r\n    )\"\r\n*/\n\"^(?:\\\\s*(,)\\\\s*|\\\\s*(<combinator>+)\\\\s*|(\\\\s+)|(<unicode>+|\\\\*)|\\\\#(<unicode>+)|\\\\.(<unicode>+)|\\\\[\\\\s*(<unicode1>+)(?:\\\\s*([*^$!~|]?=)(?:\\\\s*(?:([\\\"']?)(.*?)\\\\9)))?\\\\s*\\\\](?!\\\\])|(:+)(<unicode>+)(?:\\\\((?:(?:([\\\"'])([^\\\\13]*)\\\\13)|((?:\\\\([^)]+\\\\)|[^()]*)+))\\\\))?)\".replace(/<combinator>/, '[' + escape(\">+~`!@$%^&={}\\\\;</\") + ']').replace(/<unicode>/g, '(?:[\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\[^\\\\s0-9a-f])').replace(/<unicode1>/g, '(?:[:\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\[^\\\\s0-9a-f])')); // Part\n\nvar Part = function Part(combinator) {\n  this.combinator = combinator || \" \";\n  this.tag = \"*\";\n};\n\nPart.prototype.toString = function () {\n  if (!this.raw) {\n    var xpr = \"\",\n        k,\n        part;\n    xpr += this.tag || \"*\";\n    if (this.id) xpr += \"#\" + this.id;\n    if (this.classes) xpr += \".\" + this.classList.join(\".\");\n    if (this.attributes) for (k = 0; part = this.attributes[k++];) {\n      xpr += \"[\" + part.name + (part.operator ? part.operator + '\"' + part.value + '\"' : '') + \"]\";\n    }\n    if (this.pseudos) for (k = 0; part = this.pseudos[k++];) {\n      xpr += \":\" + part.name;\n      if (part.value) xpr += \"(\" + part.value + \")\";\n    }\n    this.raw = xpr;\n  }\n\n  return this.raw;\n}; // Expression\n\n\nvar Expression = function Expression() {\n  this.length = 0;\n};\n\nExpression.prototype.toString = function () {\n  if (!this.raw) {\n    var xpr = \"\";\n\n    for (var j = 0, bit; bit = this[j++];) {\n      if (j !== 1) xpr += \" \";\n      if (bit.combinator !== \" \") xpr += bit.combinator + \" \";\n      xpr += bit;\n    }\n\n    this.raw = xpr;\n  }\n\n  return this.raw;\n};\n\nvar replacer = function (rawMatch, separator, combinator, combinatorChildren, tagName, id, className, attributeKey, attributeOperator, attributeQuote, attributeValue, pseudoMarker, pseudoClass, pseudoQuote, pseudoClassQuotedValue, pseudoClassValue) {\n  var expression, current;\n\n  if (separator || !this.length) {\n    expression = this[this.length++] = new Expression();\n    if (separator) return '';\n  }\n\n  if (!expression) expression = this[this.length - 1];\n\n  if (combinator || combinatorChildren || !expression.length) {\n    current = expression[expression.length++] = new Part(combinator);\n  }\n\n  if (!current) current = expression[expression.length - 1];\n\n  if (tagName) {\n    current.tag = unescape(tagName);\n  } else if (id) {\n    current.id = unescape(id);\n  } else if (className) {\n    var unescaped = unescape(className);\n    var classes = current.classes || (current.classes = {});\n\n    if (!classes[unescaped]) {\n      classes[unescaped] = escape(className);\n      var classList = current.classList || (current.classList = []);\n      classList.push(unescaped);\n      classList.sort();\n    }\n  } else if (pseudoClass) {\n    pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue;\n    (current.pseudos || (current.pseudos = [])).push({\n      type: pseudoMarker.length == 1 ? 'class' : 'element',\n      name: unescape(pseudoClass),\n      escapedName: escape(pseudoClass),\n      value: pseudoClassValue ? unescape(pseudoClassValue) : null,\n      escapedValue: pseudoClassValue ? escape(pseudoClassValue) : null\n    });\n  } else if (attributeKey) {\n    attributeValue = attributeValue ? escape(attributeValue) : null;\n    (current.attributes || (current.attributes = [])).push({\n      operator: attributeOperator,\n      name: unescape(attributeKey),\n      escapedName: escape(attributeKey),\n      value: attributeValue ? unescape(attributeValue) : null,\n      escapedValue: attributeValue ? escape(attributeValue) : null\n    });\n  }\n\n  return '';\n}; // Expressions\n\n\nvar Expressions = function Expressions(expression) {\n  this.length = 0;\n  var self = this;\n  var original = expression,\n      replaced;\n\n  while (expression) {\n    replaced = expression.replace(slickRe, function () {\n      return replacer.apply(self, arguments);\n    });\n    if (replaced === expression) throw new Error(original + ' is an invalid expression');\n    expression = replaced;\n  }\n};\n\nExpressions.prototype.toString = function () {\n  if (!this.raw) {\n    var expressions = [];\n\n    for (var i = 0, expression; expression = this[i++];) expressions.push(expression);\n\n    this.raw = expressions.join(\", \");\n  }\n\n  return this.raw;\n};\n\nvar cache = {};\n\nvar parse = function (expression) {\n  if (expression == null) return null;\n  expression = ('' + expression).replace(/^\\s+|\\s+$/g, '');\n  return cache[expression] || (cache[expression] = new Expressions(expression));\n};\n\nmodule.exports = parse;","map":{"version":3,"sources":["C:/Users/ghdus/OneDrive/바탕 화면/team-project/nlp-project-team2/frontend/node_modules/slick/parser.js"],"names":["escapeRe","unescapeRe","escape","string","replace","unescape","slickRe","RegExp","Part","combinator","tag","prototype","toString","raw","xpr","k","part","id","classes","classList","join","attributes","name","operator","value","pseudos","Expression","length","j","bit","replacer","rawMatch","separator","combinatorChildren","tagName","className","attributeKey","attributeOperator","attributeQuote","attributeValue","pseudoMarker","pseudoClass","pseudoQuote","pseudoClassQuotedValue","pseudoClassValue","expression","current","unescaped","push","sort","type","escapedName","escapedValue","Expressions","self","original","replaced","apply","arguments","Error","expressions","i","cache","parse","module","exports"],"mappings":"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","sourcesContent":["/*\r\nSlick Parser\r\n - originally created by the almighty Thomas Aylott <@subtlegradient> (http://subtlegradient.com)\r\n*/\"use strict\"\r\n\r\n// Notable changes from Slick.Parser 1.0.x\r\n\r\n// The parser now uses 2 classes: Expressions and Expression\r\n// `new Expressions` produces an array-like object containing a list of Expression objects\r\n// - Expressions::toString() produces a cleaned up expressions string\r\n// `new Expression` produces an array-like object\r\n// - Expression::toString() produces a cleaned up expression string\r\n// The only exposed method is parse, which produces a (cached) `new Expressions` instance\r\n// parsed.raw is no longer present, use .toString()\r\n// parsed.expression is now useless, just use the indices\r\n// parsed.reverse() has been removed for now, due to its apparent uselessness\r\n// Other changes in the Expressions object:\r\n// - classNames are now unique, and save both escaped and unescaped values\r\n// - attributes now save both escaped and unescaped values\r\n// - pseudos now save both escaped and unescaped values\r\n\r\nvar escapeRe   = /([-.*+?^${}()|[\\]\\/\\\\])/g,\r\n    unescapeRe = /\\\\/g\r\n\r\nvar escape = function(string){\r\n    // XRegExp v2.0.0-beta-3\r\n    // « https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js\r\n    return (string + \"\").replace(escapeRe, '\\\\$1')\r\n}\r\n\r\nvar unescape = function(string){\r\n    return (string + \"\").replace(unescapeRe, '')\r\n}\r\n\r\nvar slickRe = RegExp(\r\n/*\r\n#!/usr/bin/env ruby\r\nputs \"\\t\\t\" + DATA.read.gsub(/\\(\\?x\\)|\\s+#.*$|\\s+|\\\\$|\\\\n/,'')\r\n__END__\r\n    \"(?x)^(?:\\\r\n      \\\\s* ( , ) \\\\s*               # Separator          \\n\\\r\n    | \\\\s* ( <combinator>+ ) \\\\s*   # Combinator         \\n\\\r\n    |      ( \\\\s+ )                 # CombinatorChildren \\n\\\r\n    |      ( <unicode>+ | \\\\* )     # Tag                \\n\\\r\n    | \\\\#  ( <unicode>+       )     # ID                 \\n\\\r\n    | \\\\.  ( <unicode>+       )     # ClassName          \\n\\\r\n    |                               # Attribute          \\n\\\r\n    \\\\[  \\\r\n        \\\\s* (<unicode1>+)  (?:  \\\r\n            \\\\s* ([*^$!~|]?=)  (?:  \\\r\n                \\\\s* (?:\\\r\n                    ([\\\"']?)(.*?)\\\\9 \\\r\n                )\\\r\n            )  \\\r\n        )?  \\\\s*  \\\r\n    \\\\](?!\\\\]) \\n\\\r\n    |   :+ ( <unicode>+ )(?:\\\r\n    \\\\( (?:\\\r\n        (?:([\\\"'])([^\\\\12]*)\\\\12)|((?:\\\\([^)]+\\\\)|[^()]*)+)\\\r\n    ) \\\\)\\\r\n    )?\\\r\n    )\"\r\n*/\r\n\"^(?:\\\\s*(,)\\\\s*|\\\\s*(<combinator>+)\\\\s*|(\\\\s+)|(<unicode>+|\\\\*)|\\\\#(<unicode>+)|\\\\.(<unicode>+)|\\\\[\\\\s*(<unicode1>+)(?:\\\\s*([*^$!~|]?=)(?:\\\\s*(?:([\\\"']?)(.*?)\\\\9)))?\\\\s*\\\\](?!\\\\])|(:+)(<unicode>+)(?:\\\\((?:(?:([\\\"'])([^\\\\13]*)\\\\13)|((?:\\\\([^)]+\\\\)|[^()]*)+))\\\\))?)\"\r\n    .replace(/<combinator>/, '[' + escape(\">+~`!@$%^&={}\\\\;</\") + ']')\r\n    .replace(/<unicode>/g, '(?:[\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\[^\\\\s0-9a-f])')\r\n    .replace(/<unicode1>/g, '(?:[:\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\[^\\\\s0-9a-f])')\r\n)\r\n\r\n// Part\r\n\r\nvar Part = function Part(combinator){\r\n    this.combinator = combinator || \" \"\r\n    this.tag = \"*\"\r\n}\r\n\r\nPart.prototype.toString = function(){\r\n\r\n    if (!this.raw){\r\n\r\n        var xpr = \"\", k, part\r\n\r\n        xpr += this.tag || \"*\"\r\n        if (this.id) xpr += \"#\" + this.id\r\n        if (this.classes) xpr += \".\" + this.classList.join(\".\")\r\n        if (this.attributes) for (k = 0; part = this.attributes[k++];){\r\n            xpr += \"[\" + part.name + (part.operator ? part.operator + '\"' + part.value + '\"' : '') + \"]\"\r\n        }\r\n        if (this.pseudos) for (k = 0; part = this.pseudos[k++];){\r\n            xpr += \":\" + part.name\r\n            if (part.value) xpr += \"(\" + part.value + \")\"\r\n        }\r\n\r\n        this.raw = xpr\r\n\r\n    }\r\n\r\n    return this.raw\r\n}\r\n\r\n// Expression\r\n\r\nvar Expression = function Expression(){\r\n    this.length = 0\r\n}\r\n\r\nExpression.prototype.toString = function(){\r\n\r\n    if (!this.raw){\r\n\r\n        var xpr = \"\"\r\n\r\n        for (var j = 0, bit; bit = this[j++];){\r\n            if (j !== 1) xpr += \" \"\r\n            if (bit.combinator !== \" \") xpr += bit.combinator + \" \"\r\n            xpr += bit\r\n        }\r\n\r\n        this.raw = xpr\r\n\r\n    }\r\n\r\n    return this.raw\r\n}\r\n\r\nvar replacer = function(\r\n    rawMatch,\r\n\r\n    separator,\r\n    combinator,\r\n    combinatorChildren,\r\n\r\n    tagName,\r\n    id,\r\n    className,\r\n\r\n    attributeKey,\r\n    attributeOperator,\r\n    attributeQuote,\r\n    attributeValue,\r\n\r\n    pseudoMarker,\r\n    pseudoClass,\r\n    pseudoQuote,\r\n    pseudoClassQuotedValue,\r\n    pseudoClassValue\r\n){\r\n\r\n    var expression, current\r\n\r\n    if (separator || !this.length){\r\n        expression = this[this.length++] = new Expression\r\n        if (separator) return ''\r\n    }\r\n\r\n    if (!expression) expression = this[this.length - 1]\r\n\r\n    if (combinator || combinatorChildren || !expression.length){\r\n        current = expression[expression.length++] = new Part(combinator)\r\n    }\r\n\r\n    if (!current) current = expression[expression.length - 1]\r\n\r\n    if (tagName){\r\n\r\n        current.tag = unescape(tagName)\r\n\r\n    } else if (id){\r\n\r\n        current.id = unescape(id)\r\n\r\n    } else if (className){\r\n\r\n        var unescaped = unescape(className)\r\n\r\n        var classes = current.classes || (current.classes = {})\r\n        if (!classes[unescaped]){\r\n            classes[unescaped] = escape(className)\r\n            var classList = current.classList || (current.classList = [])\r\n            classList.push(unescaped)\r\n            classList.sort()\r\n        }\r\n\r\n    } else if (pseudoClass){\r\n\r\n        pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue\r\n\r\n        ;(current.pseudos || (current.pseudos = [])).push({\r\n            type         : pseudoMarker.length == 1 ? 'class' : 'element',\r\n            name         : unescape(pseudoClass),\r\n            escapedName  : escape(pseudoClass),\r\n            value        : pseudoClassValue ? unescape(pseudoClassValue) : null,\r\n            escapedValue : pseudoClassValue ? escape(pseudoClassValue) : null\r\n        })\r\n\r\n    } else if (attributeKey){\r\n\r\n        attributeValue = attributeValue ? escape(attributeValue) : null\r\n\r\n        ;(current.attributes || (current.attributes = [])).push({\r\n            operator     : attributeOperator,\r\n            name         : unescape(attributeKey),\r\n            escapedName  : escape(attributeKey),\r\n            value        : attributeValue ? unescape(attributeValue) : null,\r\n            escapedValue : attributeValue ? escape(attributeValue) : null\r\n        })\r\n\r\n    }\r\n\r\n    return ''\r\n\r\n}\r\n\r\n// Expressions\r\n\r\nvar Expressions = function Expressions(expression){\r\n    this.length = 0\r\n\r\n    var self = this\r\n\r\n    var original = expression, replaced\r\n\r\n    while (expression){\r\n        replaced = expression.replace(slickRe, function(){\r\n            return replacer.apply(self, arguments)\r\n        })\r\n        if (replaced === expression) throw new Error(original + ' is an invalid expression')\r\n        expression = replaced\r\n    }\r\n}\r\n\r\nExpressions.prototype.toString = function(){\r\n    if (!this.raw){\r\n        var expressions = []\r\n        for (var i = 0, expression; expression = this[i++];) expressions.push(expression)\r\n        this.raw = expressions.join(\", \")\r\n    }\r\n\r\n    return this.raw\r\n}\r\n\r\nvar cache = {}\r\n\r\nvar parse = function(expression){\r\n    if (expression == null) return null\r\n    expression = ('' + expression).replace(/^\\s+|\\s+$/g, '')\r\n    return cache[expression] || (cache[expression] = new Expressions(expression))\r\n}\r\n\r\nmodule.exports = parse\r\n"]},"metadata":{},"sourceType":"script"}