{"ast":null,"code":"import { ELEMENT_DEFAULT, getRangeFromBlockStart, someNode, getText, getRangeBefore, setNodes, getPointBefore, removeMark, isCollapsed, createPluginFactory } from '@udecode/plate-core';\nimport { Editor, Transforms } from 'slate';\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\n\nvar isArray = Array.isArray;\nvar isArray_1 = isArray;\n/**\n * Casts `value` as an array if it's not one.\n *\n * @static\n * @memberOf _\n * @since 4.4.0\n * @category Lang\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast array.\n * @example\n *\n * _.castArray(1);\n * // => [1]\n *\n * _.castArray({ 'a': 1 });\n * // => [{ 'a': 1 }]\n *\n * _.castArray('abc');\n * // => ['abc']\n *\n * _.castArray(null);\n * // => [null]\n *\n * _.castArray(undefined);\n * // => [undefined]\n *\n * _.castArray();\n * // => []\n *\n * var array = [1, 2, 3];\n * console.log(_.castArray(array) === array);\n * // => true\n */\n\nfunction castArray() {\n  if (!arguments.length) {\n    return [];\n  }\n\n  var value = arguments[0];\n  return isArray_1(value) ? value : [value];\n}\n\nvar castArray_1 = castArray;\n\nconst getMatchRange = ({\n  match,\n  trigger\n}) => {\n  let start;\n  let end;\n\n  if (typeof match === 'object') {\n    start = match.start;\n    end = match.end;\n  } else {\n    start = match;\n    end = start.split('').reverse().join('');\n  }\n\n  const triggers = trigger ? castArray_1(trigger) : [end.slice(-1)];\n  end = trigger ? end : end.slice(0, -1);\n  return {\n    start,\n    end,\n    triggers\n  };\n};\n\nconst autoformatBlock = (editor, {\n  text,\n  trigger,\n  match: _match,\n  type = ELEMENT_DEFAULT,\n  allowSameTypeAbove = false,\n  preFormat,\n  format,\n  triggerAtBlockStart = true\n}) => {\n  const matches = castArray_1(_match);\n\n  for (const match of matches) {\n    const {\n      end,\n      triggers\n    } = getMatchRange({\n      match: {\n        start: '',\n        end: match\n      },\n      trigger\n    });\n    if (!triggers.includes(text)) continue;\n    let matchRange;\n\n    if (triggerAtBlockStart) {\n      matchRange = getRangeFromBlockStart(editor); // Don't autoformat if there is void nodes.\n\n      const hasVoidNode = someNode(editor, {\n        at: matchRange,\n        match: n => Editor.isVoid(editor, n)\n      });\n      if (hasVoidNode) continue;\n      const textFromBlockStart = getText(editor, matchRange);\n      if (end !== textFromBlockStart) continue;\n    } else {\n      matchRange = getRangeBefore(editor, editor.selection, {\n        matchString: end\n      });\n      if (!matchRange) continue;\n    }\n\n    if (!allowSameTypeAbove) {\n      // Don't autoformat if already in a block of the same type.\n      const isBelowSameBlockType = someNode(editor, {\n        match: {\n          type\n        }\n      });\n      if (isBelowSameBlockType) continue;\n    }\n\n    Transforms.delete(editor, {\n      at: matchRange\n    });\n    preFormat === null || preFormat === void 0 ? void 0 : preFormat(editor);\n\n    if (!format) {\n      setNodes(editor, {\n        type\n      }, {\n        match: n => Editor.isBlock(editor, n)\n      });\n    } else {\n      format(editor);\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nconst isPreviousCharacterEmpty = (editor, at) => {\n  const range = getRangeBefore(editor, at);\n\n  if (range) {\n    const text = getText(editor, range);\n\n    if (text) {\n      const noWhiteSpaceRegex = new RegExp(`\\\\S+`);\n      return !text.match(noWhiteSpaceRegex);\n    }\n  }\n\n  return true;\n};\n\nconst getMatchPoints = (editor, {\n  start,\n  end\n}) => {\n  const selection = editor.selection;\n  let beforeEndMatchPoint = selection.anchor;\n\n  if (end) {\n    beforeEndMatchPoint = getPointBefore(editor, selection, {\n      matchString: end\n    });\n    if (!beforeEndMatchPoint) return;\n  }\n\n  let afterStartMatchPoint;\n  let beforeStartMatchPoint;\n\n  if (start) {\n    afterStartMatchPoint = getPointBefore(editor, beforeEndMatchPoint, {\n      matchString: start,\n      skipInvalid: true,\n      afterMatch: true\n    });\n    if (!afterStartMatchPoint) return;\n    beforeStartMatchPoint = getPointBefore(editor, beforeEndMatchPoint, {\n      matchString: start,\n      skipInvalid: true\n    });\n    if (!isPreviousCharacterEmpty(editor, beforeStartMatchPoint)) return;\n  }\n\n  return {\n    afterStartMatchPoint,\n    beforeStartMatchPoint,\n    beforeEndMatchPoint\n  };\n};\n\nconst autoformatMark = (editor, {\n  type,\n  text,\n  trigger,\n  match: _match,\n  ignoreTrim\n}) => {\n  if (!type) return false;\n  const selection = editor.selection;\n  const matches = castArray_1(_match);\n\n  for (const match of matches) {\n    const {\n      start,\n      end,\n      triggers\n    } = getMatchRange({\n      match,\n      trigger\n    });\n    if (!triggers.includes(text)) continue;\n    const matched = getMatchPoints(editor, {\n      start,\n      end\n    });\n    if (!matched) continue;\n    const {\n      afterStartMatchPoint,\n      beforeEndMatchPoint,\n      beforeStartMatchPoint\n    } = matched;\n    const matchRange = {\n      anchor: afterStartMatchPoint,\n      focus: beforeEndMatchPoint\n    };\n\n    if (!ignoreTrim) {\n      const matchText = getText(editor, matchRange);\n      if (matchText.trim() !== matchText) continue;\n    } // delete end match\n\n\n    if (end) {\n      Transforms.delete(editor, {\n        at: {\n          anchor: beforeEndMatchPoint,\n          focus: selection.anchor\n        }\n      });\n    }\n\n    const marks = castArray_1(type); // add mark to the text between the matches\n\n    Transforms.select(editor, matchRange);\n    marks.forEach(mark => {\n      editor.addMark(mark, true);\n    });\n    Transforms.collapse(editor, {\n      edge: 'end'\n    });\n    removeMark(editor, {\n      key: marks,\n      shouldChange: false\n    });\n    Transforms.delete(editor, {\n      at: {\n        anchor: beforeStartMatchPoint,\n        focus: afterStartMatchPoint\n      }\n    });\n    return true;\n  }\n\n  return false;\n};\n\nconst autoformatText = (editor, {\n  text,\n  match: _match,\n  trigger,\n  format\n}) => {\n  const selection = editor.selection;\n  const matches = castArray_1(_match); // dup\n\n  for (const match of matches) {\n    const {\n      start,\n      end,\n      triggers\n    } = getMatchRange({\n      match: Array.isArray(format) ? match : {\n        start: '',\n        end: match\n      },\n      trigger\n    });\n    if (!triggers.includes(text)) continue;\n    const matched = getMatchPoints(editor, {\n      start,\n      end\n    });\n    if (!matched) continue;\n    const {\n      afterStartMatchPoint,\n      beforeEndMatchPoint,\n      beforeStartMatchPoint\n    } = matched;\n\n    if (end) {\n      Transforms.delete(editor, {\n        at: {\n          anchor: beforeEndMatchPoint,\n          focus: selection.anchor\n        }\n      });\n    }\n\n    if (typeof format === 'function') {\n      format(editor, matched);\n    } else {\n      const formatEnd = Array.isArray(format) ? format[1] : format;\n      editor.insertText(formatEnd);\n\n      if (beforeStartMatchPoint) {\n        const formatStart = Array.isArray(format) ? format[0] : format;\n        Transforms.delete(editor, {\n          at: {\n            anchor: beforeStartMatchPoint,\n            focus: afterStartMatchPoint\n          }\n        });\n        Transforms.insertText(editor, formatStart, {\n          at: beforeStartMatchPoint\n        });\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n};\n/**\n * Enables support for autoformatting actions.\n * Once a match rule is validated, it does not check the following rules.\n */\n\n\nconst withAutoformat = (editor, {\n  options: {\n    rules\n  }\n}) => {\n  const {\n    insertText\n  } = editor;\n\n  editor.insertText = text => {\n    if (!isCollapsed(editor.selection)) return insertText(text);\n\n    for (const rule of rules) {\n      var _autoformatter$mode;\n\n      const {\n        mode = 'text',\n        insertTrigger,\n        query\n      } = rule;\n      if (query && !query(editor, { ...rule,\n        text\n      })) continue;\n      const autoformatter = {\n        block: autoformatBlock,\n        mark: autoformatMark,\n        text: autoformatText\n      };\n\n      if ((_autoformatter$mode = autoformatter[mode]) !== null && _autoformatter$mode !== void 0 && _autoformatter$mode.call(autoformatter, editor, { ...rule,\n        text\n      })) {\n        return insertTrigger && insertText(text);\n      }\n    }\n\n    insertText(text);\n  };\n\n  return editor;\n};\n\nconst KEY_AUTOFORMAT = 'autoformat';\n/**\n * @see {@link withAutoformat}\n */\n\nconst createAutoformatPlugin = createPluginFactory({\n  key: KEY_AUTOFORMAT,\n  withOverrides: withAutoformat,\n  options: {\n    rules: []\n  }\n});\nconst autoformatArrow = [{\n  mode: 'text',\n  match: '->',\n  format: '→'\n}, {\n  mode: 'text',\n  match: '<-',\n  format: '←'\n}, {\n  mode: 'text',\n  match: '=>',\n  format: '⇒'\n}, {\n  mode: 'text',\n  match: ['<=', '≤='],\n  format: '⇐'\n}];\nconst autoformatLegal = [{\n  mode: 'text',\n  match: ['(tm)', '(TM)'],\n  format: '™'\n}, {\n  mode: 'text',\n  match: ['(r)', '(R)'],\n  format: '®'\n}, {\n  mode: 'text',\n  match: ['(c)', '(C)'],\n  format: '©'\n}];\nconst autoformatLegalHtml = [{\n  mode: 'text',\n  match: '&trade;',\n  format: '™'\n}, {\n  mode: 'text',\n  match: '&reg;',\n  format: '®'\n}, {\n  mode: 'text',\n  match: '&copy;',\n  format: '©'\n}, {\n  mode: 'text',\n  match: '&sect;',\n  format: '§'\n}];\nconst autoformatPunctuation = [{\n  mode: 'text',\n  match: '--',\n  format: '\\u2014'\n}, {\n  mode: 'text',\n  match: '...',\n  format: '…'\n}, {\n  mode: 'text',\n  match: '>>',\n  format: '»'\n}, {\n  mode: 'text',\n  match: '<<',\n  format: '«'\n}];\nconst autoformatSmartQuotes = [{\n  mode: 'text',\n  match: '\"',\n  format: ['“', '”']\n}, {\n  mode: 'text',\n  match: \"'\",\n  format: ['‘', '’']\n}];\nconst autoformatComparison = [{\n  mode: 'text',\n  match: '!>',\n  format: '≯'\n}, {\n  mode: 'text',\n  match: '!<',\n  format: '≮'\n}, {\n  mode: 'text',\n  match: '>=',\n  format: '≥'\n}, {\n  mode: 'text',\n  match: '<=',\n  format: '≤'\n}, {\n  mode: 'text',\n  match: '!>=',\n  format: '≱'\n}, {\n  mode: 'text',\n  match: '!<=',\n  format: '≰'\n}];\nconst autoformatEquality = [{\n  mode: 'text',\n  match: '!=',\n  format: '≠'\n}, {\n  mode: 'text',\n  match: '==',\n  format: '≡'\n}, {\n  mode: 'text',\n  match: ['!==', '≠='],\n  format: '≢'\n}, {\n  mode: 'text',\n  match: '~=',\n  format: '≈'\n}, {\n  mode: 'text',\n  match: '!~=',\n  format: '≉'\n}];\nconst autoformatFraction = [{\n  mode: 'text',\n  match: '1/2',\n  format: '½'\n}, {\n  mode: 'text',\n  match: '1/3',\n  format: '⅓'\n}, {\n  mode: 'text',\n  match: '1/4',\n  format: '¼'\n}, {\n  mode: 'text',\n  match: '1/5',\n  format: '⅕'\n}, {\n  mode: 'text',\n  match: '1/6',\n  format: '⅙'\n}, {\n  mode: 'text',\n  match: '1/7',\n  format: '⅐'\n}, {\n  mode: 'text',\n  match: '1/8',\n  format: '⅛'\n}, {\n  mode: 'text',\n  match: '1/9',\n  format: '⅑'\n}, {\n  mode: 'text',\n  match: '1/10',\n  format: '⅒'\n}, {\n  mode: 'text',\n  match: '2/3',\n  format: '⅔'\n}, {\n  mode: 'text',\n  match: '2/5',\n  format: '⅖'\n}, {\n  mode: 'text',\n  match: '3/4',\n  format: '¾'\n}, {\n  mode: 'text',\n  match: '3/5',\n  format: '⅗'\n}, {\n  mode: 'text',\n  match: '3/8',\n  format: '⅜'\n}, {\n  mode: 'text',\n  match: '4/5',\n  format: '⅘'\n}, {\n  mode: 'text',\n  match: '5/6',\n  format: '⅚'\n}, {\n  mode: 'text',\n  match: '5/8',\n  format: '⅝'\n}, {\n  mode: 'text',\n  match: '7/8',\n  format: '⅞'\n}];\nconst autoformatDivision = [{\n  mode: 'text',\n  match: '//',\n  format: '÷'\n}];\nconst autoformatOperation = [{\n  mode: 'text',\n  match: '+-',\n  format: '±'\n}, {\n  mode: 'text',\n  match: '%%',\n  format: '‰'\n}, {\n  mode: 'text',\n  match: ['%%%', '‰%'],\n  format: '‱'\n}, ...autoformatDivision];\nconst autoformatSubscriptNumbers = [{\n  mode: 'text',\n  match: '~0',\n  format: '₀'\n}, {\n  mode: 'text',\n  match: '~1',\n  format: '₁'\n}, {\n  mode: 'text',\n  match: '~2',\n  format: '₂'\n}, {\n  mode: 'text',\n  match: '~3',\n  format: '₃'\n}, {\n  mode: 'text',\n  match: '~4',\n  format: '₄'\n}, {\n  mode: 'text',\n  match: '~5',\n  format: '₅'\n}, {\n  mode: 'text',\n  match: '~6',\n  format: '₆'\n}, {\n  mode: 'text',\n  match: '~7',\n  format: '₇'\n}, {\n  mode: 'text',\n  match: '~8',\n  format: '₈'\n}, {\n  mode: 'text',\n  match: '~9',\n  format: '₉'\n}];\nconst autoformatSubscriptSymbols = [{\n  mode: 'text',\n  match: '~+',\n  format: '₊'\n}, {\n  mode: 'text',\n  match: '~-',\n  format: '₋'\n}];\nconst autoformatSuperscriptNumbers = [{\n  mode: 'text',\n  match: '^0',\n  format: '⁰'\n}, {\n  mode: 'text',\n  match: '^1',\n  format: '¹'\n}, {\n  mode: 'text',\n  match: '^2',\n  format: '²'\n}, {\n  mode: 'text',\n  match: '^3',\n  format: '³'\n}, {\n  mode: 'text',\n  match: '^4',\n  format: '⁴'\n}, {\n  mode: 'text',\n  match: '^5',\n  format: '⁵'\n}, {\n  mode: 'text',\n  match: '^6',\n  format: '⁶'\n}, {\n  mode: 'text',\n  match: '^7',\n  format: '⁷'\n}, {\n  mode: 'text',\n  match: '^8',\n  format: '⁸'\n}, {\n  mode: 'text',\n  match: '^9',\n  format: '⁹'\n}];\nconst autoformatSuperscriptSymbols = [{\n  mode: 'text',\n  match: '^o',\n  format: '°'\n}, {\n  mode: 'text',\n  match: '^+',\n  format: '⁺'\n}, {\n  mode: 'text',\n  match: '^-',\n  format: '⁻'\n}];\nconst autoformatMath = [...autoformatComparison, ...autoformatEquality, ...autoformatOperation, ...autoformatFraction, ...autoformatSuperscriptSymbols, ...autoformatSubscriptSymbols, ...autoformatSuperscriptNumbers, ...autoformatSubscriptNumbers];\nexport { KEY_AUTOFORMAT, autoformatArrow, autoformatBlock, autoformatComparison, autoformatDivision, autoformatEquality, autoformatFraction, autoformatLegal, autoformatLegalHtml, autoformatMark, autoformatMath, autoformatOperation, autoformatPunctuation, autoformatSmartQuotes, autoformatSubscriptNumbers, autoformatSubscriptSymbols, autoformatSuperscriptNumbers, autoformatSuperscriptSymbols, autoformatText, createAutoformatPlugin, getMatchPoints, getMatchRange, isPreviousCharacterEmpty, withAutoformat };","map":{"version":3,"sources":["../../../../node_modules/lodash/isArray.js","../../../../node_modules/lodash/castArray.js","../src/utils/getMatchRange.ts","../src/transforms/autoformatBlock.ts","../src/utils/isPreviousCharacterEmpty.ts","../src/utils/getMatchPoints.ts","../src/transforms/autoformatMark.ts","../src/transforms/autoformatText.ts","../src/withAutoformat.ts","../src/createAutoformatPlugin.ts","../src/rules/autoformatArrow.ts","../src/rules/autoformatLegal.ts","../src/rules/autoformatPunctuation.ts","../src/rules/autoformatSmartQuotes.ts","../src/rules/math/autoformatComparison.ts","../src/rules/math/autoformatEquality.ts","../src/rules/math/autoformatFraction.ts","../src/rules/math/autoformatOperation.ts","../src/rules/math/autoformatSubscript.ts","../src/rules/math/autoformatSuperscript.ts","../src/rules/math/autoformatMath.ts"],"names":["isArray","getMatchRange","trigger","start","match","end","triggers","castArray","autoformatBlock","type","allowSameTypeAbove","triggerAtBlockStart","matches","matchRange","getRangeFromBlockStart","hasVoidNode","someNode","at","n","Editor","textFromBlockStart","getText","getRangeBefore","editor","matchString","isBelowSameBlockType","Transforms","preFormat","setNodes","format","isPreviousCharacterEmpty","range","text","noWhiteSpaceRegex","getMatchPoints","selection","beforeEndMatchPoint","getPointBefore","afterStartMatchPoint","skipInvalid","afterMatch","beforeStartMatchPoint","autoformatMark","ignoreTrim","matched","anchor","focus","matchText","marks","mark","edge","removeMark","key","shouldChange","autoformatText","Array","formatEnd","formatStart","withAutoformat","options","rules","insertText","isCollapsed","mode","query","autoformatter","block","insertTrigger","KEY_AUTOFORMAT","createAutoformatPlugin","createPluginFactory","withOverrides","autoformatArrow","autoformatLegal","autoformatLegalHtml","autoformatPunctuation","autoformatSmartQuotes","autoformatComparison","autoformatEquality","autoformatFraction","autoformatDivision","autoformatOperation","autoformatSubscriptNumbers","autoformatSubscriptSymbols","autoformatSuperscriptNumbers","autoformatSuperscriptSymbols","autoformatMath"],"mappings":"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","sourcesContent":["/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var isArray = require('./isArray');\n\n/**\n * Casts `value` as an array if it's not one.\n *\n * @static\n * @memberOf _\n * @since 4.4.0\n * @category Lang\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast array.\n * @example\n *\n * _.castArray(1);\n * // => [1]\n *\n * _.castArray({ 'a': 1 });\n * // => [{ 'a': 1 }]\n *\n * _.castArray('abc');\n * // => ['abc']\n *\n * _.castArray(null);\n * // => [null]\n *\n * _.castArray(undefined);\n * // => [undefined]\n *\n * _.castArray();\n * // => []\n *\n * var array = [1, 2, 3];\n * console.log(_.castArray(array) === array);\n * // => true\n */\nfunction castArray() {\n  if (!arguments.length) {\n    return [];\n  }\n  var value = arguments[0];\n  return isArray(value) ? value : [value];\n}\n\nmodule.exports = castArray;\n","import castArray from 'lodash/castArray';\nimport { AutoformatRule, MatchRange } from '../types';\n\nexport const getMatchRange = ({\n  match,\n  trigger,\n}: {\n  match: string | MatchRange;\n  trigger: AutoformatRule['trigger'];\n}) => {\n  let start: string;\n  let end: string;\n\n  if (typeof match === 'object') {\n    start = match.start;\n    end = match.end;\n  } else {\n    start = match;\n    end = start.split('').reverse().join('');\n  }\n\n  const triggers: string[] = trigger ? castArray(trigger) : [end.slice(-1)];\n\n  end = trigger ? end : end.slice(0, -1);\n\n  return {\n    start,\n    end,\n    triggers,\n  };\n};\n","import {\n  ELEMENT_DEFAULT,\n  getRangeBefore,\n  getRangeFromBlockStart,\n  getText,\n  setNodes,\n  someNode,\n  TEditor,\n  TElement,\n} from '@udecode/plate-core';\nimport castArray from 'lodash/castArray';\nimport { Editor, Range, Transforms } from 'slate';\nimport { AutoformatBlockRule } from '../types';\nimport { getMatchRange } from '../utils/getMatchRange';\n\nexport interface AutoformatBlockOptions extends AutoformatBlockRule {\n  text: string;\n}\n\nexport const autoformatBlock = (\n  editor: TEditor,\n  {\n    text,\n    trigger,\n    match: _match,\n    type = ELEMENT_DEFAULT,\n    allowSameTypeAbove = false,\n    preFormat,\n    format,\n    triggerAtBlockStart = true,\n  }: AutoformatBlockOptions\n) => {\n  const matches = castArray(_match as string | string[]);\n\n  for (const match of matches) {\n    const { end, triggers } = getMatchRange({\n      match: { start: '', end: match },\n      trigger,\n    });\n\n    if (!triggers.includes(text)) continue;\n\n    let matchRange: Range | undefined;\n\n    if (triggerAtBlockStart) {\n      matchRange = getRangeFromBlockStart(editor) as Range;\n\n      // Don't autoformat if there is void nodes.\n      const hasVoidNode = someNode(editor, {\n        at: matchRange,\n        match: (n) => Editor.isVoid(editor, n),\n      });\n      if (hasVoidNode) continue;\n\n      const textFromBlockStart = getText(editor, matchRange);\n\n      if (end !== textFromBlockStart) continue;\n    } else {\n      matchRange = getRangeBefore(editor, editor.selection as Range, {\n        matchString: end,\n      });\n      if (!matchRange) continue;\n    }\n\n    if (!allowSameTypeAbove) {\n      // Don't autoformat if already in a block of the same type.\n      const isBelowSameBlockType = someNode(editor, { match: { type } });\n      if (isBelowSameBlockType) continue;\n    }\n\n    Transforms.delete(editor, { at: matchRange });\n\n    preFormat?.(editor);\n\n    if (!format) {\n      setNodes<TElement>(\n        editor,\n        { type },\n        {\n          match: (n) => Editor.isBlock(editor, n),\n        }\n      );\n    } else {\n      format(editor);\n    }\n\n    return true;\n  }\n\n  return false;\n};\n","import { getRangeBefore, getText, TEditor } from '@udecode/plate-core';\nimport { Location } from 'slate';\n\nexport const isPreviousCharacterEmpty = (editor: TEditor, at: Location) => {\n  const range = getRangeBefore(editor, at);\n  if (range) {\n    const text = getText(editor, range);\n    if (text) {\n      const noWhiteSpaceRegex = new RegExp(`\\\\S+`);\n\n      return !text.match(noWhiteSpaceRegex);\n    }\n  }\n\n  return true;\n};\n","import { getPointBefore, TEditor } from '@udecode/plate-core';\nimport { Point, Range } from 'slate';\nimport { MatchRange } from '../types';\nimport { isPreviousCharacterEmpty } from './isPreviousCharacterEmpty';\n\nexport type GetMatchPointsReturnType =\n  | undefined\n  | {\n      beforeStartMatchPoint: Point | undefined;\n      afterStartMatchPoint: Point | undefined;\n      beforeEndMatchPoint: Point;\n    };\n\nexport const getMatchPoints = (editor: TEditor, { start, end }: MatchRange) => {\n  const selection = editor.selection as Range;\n\n  let beforeEndMatchPoint = selection.anchor;\n  if (end) {\n    beforeEndMatchPoint = getPointBefore(editor, selection, {\n      matchString: end,\n    });\n\n    if (!beforeEndMatchPoint) return;\n  }\n\n  let afterStartMatchPoint: Point | undefined;\n  let beforeStartMatchPoint: Point | undefined;\n\n  if (start) {\n    afterStartMatchPoint = getPointBefore(editor, beforeEndMatchPoint, {\n      matchString: start,\n      skipInvalid: true,\n      afterMatch: true,\n    });\n\n    if (!afterStartMatchPoint) return;\n\n    beforeStartMatchPoint = getPointBefore(editor, beforeEndMatchPoint, {\n      matchString: start,\n      skipInvalid: true,\n    });\n\n    if (!isPreviousCharacterEmpty(editor, beforeStartMatchPoint as Point))\n      return;\n  }\n\n  return {\n    afterStartMatchPoint,\n    beforeStartMatchPoint,\n    beforeEndMatchPoint,\n  };\n};\n","import { getText, removeMark, TEditor } from '@udecode/plate-core';\nimport castArray from 'lodash/castArray';\nimport { Point, Range, Transforms } from 'slate';\nimport { AutoformatMarkRule } from '../types';\nimport { getMatchPoints } from '../utils/getMatchPoints';\nimport { getMatchRange } from '../utils/getMatchRange';\n\nexport interface AutoformatMarkOptions extends AutoformatMarkRule {\n  text: string;\n}\n\nexport const autoformatMark = (\n  editor: TEditor,\n  { type, text, trigger, match: _match, ignoreTrim }: AutoformatMarkOptions\n) => {\n  if (!type) return false;\n\n  const selection = editor.selection as Range;\n  const matches = castArray(_match);\n\n  for (const match of matches) {\n    const { start, end, triggers } = getMatchRange({\n      match,\n      trigger,\n    });\n\n    if (!triggers.includes(text)) continue;\n\n    const matched = getMatchPoints(editor, { start, end });\n    if (!matched) continue;\n\n    const {\n      afterStartMatchPoint,\n      beforeEndMatchPoint,\n      beforeStartMatchPoint,\n    } = matched;\n\n    const matchRange = {\n      anchor: afterStartMatchPoint,\n      focus: beforeEndMatchPoint,\n    } as Range;\n\n    if (!ignoreTrim) {\n      const matchText = getText(editor, matchRange);\n      if (matchText.trim() !== matchText) continue;\n    }\n\n    // delete end match\n    if (end) {\n      Transforms.delete(editor, {\n        at: {\n          anchor: beforeEndMatchPoint,\n          focus: selection.anchor,\n        },\n      });\n    }\n\n    const marks = castArray(type);\n\n    // add mark to the text between the matches\n    Transforms.select(editor, matchRange as Range);\n    marks.forEach((mark) => {\n      editor.addMark(mark, true);\n    });\n    Transforms.collapse(editor, { edge: 'end' });\n    removeMark(editor, { key: marks, shouldChange: false });\n\n    Transforms.delete(editor, {\n      at: {\n        anchor: beforeStartMatchPoint as Point,\n        focus: afterStartMatchPoint as Point,\n      },\n    });\n\n    return true;\n  }\n\n  return false;\n};\n","import { TEditor } from '@udecode/plate-core';\nimport castArray from 'lodash/castArray';\nimport { Point, Range, Transforms } from 'slate';\nimport { AutoformatTextRule } from '../types';\nimport { getMatchPoints } from '../utils/getMatchPoints';\nimport { getMatchRange } from '../utils/getMatchRange';\n\nexport interface AutoformatTextOptions extends AutoformatTextRule {\n  text: string;\n}\n\nexport const autoformatText = (\n  editor: TEditor,\n  { text, match: _match, trigger, format }: AutoformatTextOptions\n) => {\n  const selection = editor.selection as Range;\n  const matches = castArray(_match);\n\n  // dup\n  for (const match of matches) {\n    const { start, end, triggers } = getMatchRange({\n      match: Array.isArray(format)\n        ? match\n        : {\n            start: '',\n            end: match,\n          },\n      trigger,\n    });\n\n    if (!triggers.includes(text)) continue;\n\n    const matched = getMatchPoints(editor, { start, end });\n    if (!matched) continue;\n\n    const {\n      afterStartMatchPoint,\n      beforeEndMatchPoint,\n      beforeStartMatchPoint,\n    } = matched;\n\n    if (end) {\n      Transforms.delete(editor, {\n        at: {\n          anchor: beforeEndMatchPoint,\n          focus: selection.anchor,\n        },\n      });\n    }\n\n    if (typeof format === 'function') {\n      format(editor, matched);\n    } else {\n      const formatEnd = Array.isArray(format) ? format[1] : format;\n      editor.insertText(formatEnd);\n\n      if (beforeStartMatchPoint) {\n        const formatStart = Array.isArray(format) ? format[0] : format;\n\n        Transforms.delete(editor, {\n          at: {\n            anchor: beforeStartMatchPoint as Point,\n            focus: afterStartMatchPoint as Point,\n          },\n        });\n\n        Transforms.insertText(editor, formatStart, {\n          at: beforeStartMatchPoint,\n        });\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n};\n","import { isCollapsed, WithOverride } from '@udecode/plate-core';\nimport { autoformatBlock } from './transforms/autoformatBlock';\nimport { autoformatMark } from './transforms/autoformatMark';\nimport { autoformatText } from './transforms/autoformatText';\nimport { AutoformatPlugin } from './types';\n\n/**\n * Enables support for autoformatting actions.\n * Once a match rule is validated, it does not check the following rules.\n */\nexport const withAutoformat: WithOverride<{}, AutoformatPlugin> = (\n  editor,\n  { options: { rules } }\n) => {\n  const { insertText } = editor;\n\n  editor.insertText = (text) => {\n    if (!isCollapsed(editor.selection)) return insertText(text);\n\n    for (const rule of rules!) {\n      const { mode = 'text', insertTrigger, query } = rule;\n\n      if (query && !query(editor, { ...rule, text })) continue;\n\n      const autoformatter: Record<typeof mode, Function> = {\n        block: autoformatBlock,\n        mark: autoformatMark,\n        text: autoformatText,\n      };\n\n      if (\n        autoformatter[mode]?.(editor, {\n          ...(rule as any),\n          text,\n        })\n      ) {\n        return insertTrigger && insertText(text);\n      }\n    }\n\n    insertText(text);\n  };\n\n  return editor;\n};\n","import { createPluginFactory } from '@udecode/plate-core';\nimport { AutoformatPlugin } from './types';\nimport { withAutoformat } from './withAutoformat';\n\nexport const KEY_AUTOFORMAT = 'autoformat';\n\n/**\n * @see {@link withAutoformat}\n */\nexport const createAutoformatPlugin = createPluginFactory<AutoformatPlugin>({\n  key: KEY_AUTOFORMAT,\n  withOverrides: withAutoformat,\n  options: {\n    rules: [],\n  },\n});\n","import { AutoformatRule } from '../types';\n\nexport const autoformatArrow: AutoformatRule[] = [\n  {\n    mode: 'text',\n    match: '->',\n    format: '→',\n  },\n  {\n    mode: 'text',\n    match: '<-',\n    format: '←',\n  },\n  {\n    mode: 'text',\n    match: '=>',\n    format: '⇒',\n  },\n  {\n    mode: 'text',\n    match: ['<=', '≤='],\n    format: '⇐',\n  },\n];\n","import { AutoformatRule } from '../types';\n\nexport const autoformatLegal: AutoformatRule[] = [\n  {\n    mode: 'text',\n    match: ['(tm)', '(TM)'],\n    format: '™',\n  },\n  {\n    mode: 'text',\n    match: ['(r)', '(R)'],\n    format: '®',\n  },\n\n  {\n    mode: 'text',\n    match: ['(c)', '(C)'],\n    format: '©',\n  },\n];\n\nexport const autoformatLegalHtml: AutoformatRule[] = [\n  {\n    mode: 'text',\n    match: '&trade;',\n    format: '™',\n  },\n  {\n    mode: 'text',\n    match: '&reg;',\n    format: '®',\n  },\n  {\n    mode: 'text',\n    match: '&copy;',\n    format: '©',\n  },\n  {\n    mode: 'text',\n    match: '&sect;',\n    format: '§',\n  },\n];\n","import { AutoformatRule } from '../types';\n\nexport const autoformatPunctuation: AutoformatRule[] = [\n  {\n    mode: 'text',\n    match: '--',\n    format: '\\u2014',\n  },\n  {\n    mode: 'text',\n    match: '...',\n    format: '…',\n  },\n  {\n    mode: 'text',\n    match: '>>',\n    format: '»',\n  },\n  {\n    mode: 'text',\n    match: '<<',\n    format: '«',\n  },\n];\n","import { AutoformatRule } from '../types';\n\nexport const autoformatSmartQuotes: AutoformatRule[] = [\n  {\n    mode: 'text',\n    match: '\"',\n    format: ['“', '”'],\n  },\n  {\n    mode: 'text',\n    match: \"'\",\n    format: ['‘', '’'],\n  },\n];\n","import { AutoformatRule } from '../../types';\n\nexport const autoformatComparison: AutoformatRule[] = [\n  {\n    mode: 'text',\n    match: '!>',\n    format: '≯',\n  },\n  {\n    mode: 'text',\n    match: '!<',\n    format: '≮',\n  },\n  {\n    mode: 'text',\n    match: '>=',\n    format: '≥',\n  },\n  {\n    mode: 'text',\n    match: '<=',\n    format: '≤',\n  },\n  {\n    mode: 'text',\n    match: '!>=',\n    format: '≱',\n  },\n  {\n    mode: 'text',\n    match: '!<=',\n    format: '≰',\n  },\n];\n","import { AutoformatRule } from '../../types';\n\nexport const autoformatEquality: AutoformatRule[] = [\n  {\n    mode: 'text',\n    match: '!=',\n    format: '≠',\n  },\n  {\n    mode: 'text',\n    match: '==',\n    format: '≡',\n  },\n  {\n    mode: 'text',\n    match: ['!==', '≠='],\n    format: '≢',\n  },\n  {\n    mode: 'text',\n    match: '~=',\n    format: '≈',\n  },\n  {\n    mode: 'text',\n    match: '!~=',\n    format: '≉',\n  },\n];\n","import { AutoformatRule } from '../../types';\n\nexport const autoformatFraction: AutoformatRule[] = [\n  {\n    mode: 'text',\n    match: '1/2',\n    format: '½',\n  },\n  {\n    mode: 'text',\n    match: '1/3',\n    format: '⅓',\n  },\n  {\n    mode: 'text',\n    match: '1/4',\n    format: '¼',\n  },\n  {\n    mode: 'text',\n    match: '1/5',\n    format: '⅕',\n  },\n  {\n    mode: 'text',\n    match: '1/6',\n    format: '⅙',\n  },\n  {\n    mode: 'text',\n    match: '1/7',\n    format: '⅐',\n  },\n  {\n    mode: 'text',\n    match: '1/8',\n    format: '⅛',\n  },\n  {\n    mode: 'text',\n    match: '1/9',\n    format: '⅑',\n  },\n  {\n    mode: 'text',\n    match: '1/10',\n    format: '⅒',\n  },\n  {\n    mode: 'text',\n    match: '2/3',\n    format: '⅔',\n  },\n  {\n    mode: 'text',\n    match: '2/5',\n    format: '⅖',\n  },\n  {\n    mode: 'text',\n    match: '3/4',\n    format: '¾',\n  },\n  {\n    mode: 'text',\n    match: '3/5',\n    format: '⅗',\n  },\n  {\n    mode: 'text',\n    match: '3/8',\n    format: '⅜',\n  },\n  {\n    mode: 'text',\n    match: '4/5',\n    format: '⅘',\n  },\n  {\n    mode: 'text',\n    match: '5/6',\n    format: '⅚',\n  },\n  {\n    mode: 'text',\n    match: '5/8',\n    format: '⅝',\n  },\n  {\n    mode: 'text',\n    match: '7/8',\n    format: '⅞',\n  },\n];\n","import { AutoformatRule } from '../../types';\n\nexport const autoformatDivision: AutoformatRule[] = [\n  {\n    mode: 'text',\n    match: '//',\n    format: '÷',\n  },\n];\n\nexport const autoformatOperation: AutoformatRule[] = [\n  {\n    mode: 'text',\n    match: '+-',\n    format: '±',\n  },\n  {\n    mode: 'text',\n    match: '%%',\n    format: '‰',\n  },\n  {\n    mode: 'text',\n    match: ['%%%', '‰%'],\n    format: '‱',\n  },\n  ...autoformatDivision,\n];\n","import { AutoformatRule } from '../../types';\n\nexport const autoformatSubscriptNumbers: AutoformatRule[] = [\n  {\n    mode: 'text',\n    match: '~0',\n    format: '₀',\n  },\n  {\n    mode: 'text',\n    match: '~1',\n    format: '₁',\n  },\n  {\n    mode: 'text',\n    match: '~2',\n    format: '₂',\n  },\n  {\n    mode: 'text',\n    match: '~3',\n    format: '₃',\n  },\n  {\n    mode: 'text',\n    match: '~4',\n    format: '₄',\n  },\n  {\n    mode: 'text',\n    match: '~5',\n    format: '₅',\n  },\n  {\n    mode: 'text',\n    match: '~6',\n    format: '₆',\n  },\n  {\n    mode: 'text',\n    match: '~7',\n    format: '₇',\n  },\n  {\n    mode: 'text',\n    match: '~8',\n    format: '₈',\n  },\n  {\n    mode: 'text',\n    match: '~9',\n    format: '₉',\n  },\n];\n\nexport const autoformatSubscriptSymbols: AutoformatRule[] = [\n  {\n    mode: 'text',\n    match: '~+',\n    format: '₊',\n  },\n  {\n    mode: 'text',\n    match: '~-',\n    format: '₋',\n  },\n];\n","import { AutoformatRule } from '../../types';\n\nexport const autoformatSuperscriptNumbers: AutoformatRule[] = [\n  {\n    mode: 'text',\n    match: '^0',\n    format: '⁰',\n  },\n  {\n    mode: 'text',\n    match: '^1',\n    format: '¹',\n  },\n  {\n    mode: 'text',\n    match: '^2',\n    format: '²',\n  },\n  {\n    mode: 'text',\n    match: '^3',\n    format: '³',\n  },\n  {\n    mode: 'text',\n    match: '^4',\n    format: '⁴',\n  },\n  {\n    mode: 'text',\n    match: '^5',\n    format: '⁵',\n  },\n  {\n    mode: 'text',\n    match: '^6',\n    format: '⁶',\n  },\n  {\n    mode: 'text',\n    match: '^7',\n    format: '⁷',\n  },\n  {\n    mode: 'text',\n    match: '^8',\n    format: '⁸',\n  },\n  {\n    mode: 'text',\n    match: '^9',\n    format: '⁹',\n  },\n];\n\nexport const autoformatSuperscriptSymbols: AutoformatRule[] = [\n  {\n    mode: 'text',\n    match: '^o',\n    format: '°',\n  },\n  {\n    mode: 'text',\n    match: '^+',\n    format: '⁺',\n  },\n  {\n    mode: 'text',\n    match: '^-',\n    format: '⁻',\n  },\n];\n","import { autoformatComparison } from './autoformatComparison';\nimport { autoformatEquality } from './autoformatEquality';\nimport { autoformatFraction } from './autoformatFraction';\nimport { autoformatOperation } from './autoformatOperation';\nimport {\n  autoformatSubscriptNumbers,\n  autoformatSubscriptSymbols,\n} from './autoformatSubscript';\nimport {\n  autoformatSuperscriptNumbers,\n  autoformatSuperscriptSymbols,\n} from './autoformatSuperscript';\n\nexport const autoformatMath = [\n  ...autoformatComparison,\n  ...autoformatEquality,\n  ...autoformatOperation,\n  ...autoformatFraction,\n  ...autoformatSuperscriptSymbols,\n  ...autoformatSubscriptSymbols,\n  ...autoformatSuperscriptNumbers,\n  ...autoformatSubscriptNumbers,\n];\n"]},"metadata":{},"sourceType":"module"}