{"ast":null,"code":"import { getNode, isElement, setNodes, insertNodes, createPluginFactory } from '@udecode/plate-core';\nimport { Node, Transforms } from 'slate';\n\nconst withNormalizeTypes = (editor, {\n  options: {\n    rules,\n    onError\n  }\n}) => {\n  const {\n    normalizeNode\n  } = editor;\n\n  editor.normalizeNode = ([currentNode, currentPath]) => {\n    if (!currentPath.length) {\n      const endCurrentNormalizationPass = rules.some(({\n        strictType,\n        type,\n        path\n      }) => {\n        const node = getNode(editor, path);\n\n        if (node) {\n          if (strictType && isElement(node) && node.type !== strictType) {\n            setNodes(editor, {\n              type: strictType\n            }, {\n              at: path\n            });\n            return true;\n          }\n        } else {\n          try {\n            insertNodes(editor, {\n              type: strictType !== null && strictType !== void 0 ? strictType : type,\n              children: [{\n                text: ''\n              }]\n            }, {\n              at: path\n            });\n            return true;\n          } catch (err) {\n            onError === null || onError === void 0 ? void 0 : onError(err);\n          }\n        }\n\n        return false;\n      });\n\n      if (endCurrentNormalizationPass) {\n        return;\n      }\n    }\n\n    return normalizeNode([currentNode, currentPath]);\n  };\n\n  return editor;\n};\n\nconst KEY_NORMALIZE_TYPES = 'normalizeTypes';\n/**\r\n * @see {@link withNormalizeTypes}\r\n */\n\nconst createNormalizeTypesPlugin = createPluginFactory({\n  key: KEY_NORMALIZE_TYPES,\n  withOverrides: withNormalizeTypes,\n  options: {\n    rules: []\n  }\n});\n/**\r\n * Checks if `value` is classified as an `Array` object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\r\n * @example\r\n *\r\n * _.isArray([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isArray(document.body.children);\r\n * // => false\r\n *\r\n * _.isArray('abc');\r\n * // => false\r\n *\r\n * _.isArray(_.noop);\r\n * // => false\r\n */\n\nvar isArray = Array.isArray;\nvar isArray_1 = isArray;\n/**\r\n * Casts `value` as an array if it's not one.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.4.0\r\n * @category Lang\r\n * @param {*} value The value to inspect.\r\n * @returns {Array} Returns the cast array.\r\n * @example\r\n *\r\n * _.castArray(1);\r\n * // => [1]\r\n *\r\n * _.castArray({ 'a': 1 });\r\n * // => [{ 'a': 1 }]\r\n *\r\n * _.castArray('abc');\r\n * // => ['abc']\r\n *\r\n * _.castArray(null);\r\n * // => [null]\r\n *\r\n * _.castArray(undefined);\r\n * // => [undefined]\r\n *\r\n * _.castArray();\r\n * // => []\r\n *\r\n * var array = [1, 2, 3];\r\n * console.log(_.castArray(array) === array);\r\n * // => true\r\n */\n\nfunction castArray() {\n  if (!arguments.length) {\n    return [];\n  }\n\n  var value = arguments[0];\n  return isArray_1(value) ? value : [value];\n}\n\nvar castArray_1 = castArray;\n/**\r\n * Remove nodes with empty text.\r\n */\n\nconst withRemoveEmptyNodes = (editor, {\n  options: {\n    types: _types\n  }\n}) => {\n  const types = castArray_1(_types);\n  const {\n    normalizeNode\n  } = editor;\n\n  editor.normalizeNode = ([node, path]) => {\n    if (isElement(node) && node.type && types.includes(node.type) && Node.string(node) === '') {\n      Transforms.removeNodes(editor, {\n        at: path\n      });\n      return;\n    }\n\n    normalizeNode([node, path]);\n  };\n\n  return editor;\n};\n/**\r\n * @see {@link withRemoveEmptyNodes}\r\n */\n\n\nconst createRemoveEmptyNodesPlugin = createPluginFactory({\n  key: 'removeEmptyNodes',\n  withOverrides: withRemoveEmptyNodes\n});\nexport { KEY_NORMALIZE_TYPES, createNormalizeTypesPlugin, createRemoveEmptyNodesPlugin, withNormalizeTypes, withRemoveEmptyNodes };","map":{"version":3,"sources":["../src/withNormalizeTypes.ts","../src/createNormalizeTypesPlugin.ts","../../../../node_modules/lodash/isArray.js","../../../../node_modules/lodash/castArray.js","../src/withRemoveEmptyNodes.ts","../src/createRemoveEmptyNodesPlugin.ts"],"names":["withNormalizeTypes","options","onError","normalizeNode","editor","currentPath","endCurrentNormalizationPass","path","node","getNode","strictType","isElement","setNodes","type","at","insertNodes","children","text","KEY_NORMALIZE_TYPES","createNormalizeTypesPlugin","createPluginFactory","key","withOverrides","rules","isArray","withRemoveEmptyNodes","types","_types","castArray","Node","Transforms","createRemoveEmptyNodesPlugin"],"mappings":"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","sourcesContent":["import {\n  getNode,\n  insertNodes,\n  isElement,\n  setNodes,\n  TElement,\n  WithOverride,\n} from '@udecode/plate-core';\nimport { NormalizeTypesPlugin } from './createNormalizeTypesPlugin';\n\nexport const withNormalizeTypes: WithOverride<{}, NormalizeTypesPlugin> = (\n  editor,\n  { options: { rules, onError } }\n) => {\n  const { normalizeNode } = editor;\n\n  editor.normalizeNode = ([currentNode, currentPath]) => {\n    if (!currentPath.length) {\n      const endCurrentNormalizationPass = rules!.some(\n        ({ strictType, type, path }) => {\n          const node = getNode(editor, path);\n\n          if (node) {\n            if (strictType && isElement(node) && node.type !== strictType) {\n              setNodes<TElement>(\n                editor,\n                { type: strictType },\n                {\n                  at: path,\n                }\n              );\n              return true;\n            }\n          } else {\n            try {\n              insertNodes<TElement>(\n                editor,\n                {\n                  type: strictType ?? type!,\n                  children: [{ text: '' }],\n                },\n                { at: path }\n              );\n              return true;\n            } catch (err) {\n              onError?.(err);\n            }\n          }\n\n          return false;\n        }\n      );\n\n      if (endCurrentNormalizationPass) {\n        return;\n      }\n    }\n\n    return normalizeNode([currentNode, currentPath]);\n  };\n\n  return editor;\n};\n","import { createPluginFactory, ErrorHandler } from '@udecode/plate-core';\nimport { Path } from 'slate';\nimport { withNormalizeTypes } from './withNormalizeTypes';\n\ninterface Rule {\n  /**\n   * Force the type of the node at the given path\n   */\n  strictType?: string;\n  /**\n   * Type of the inserted node at the given path if `strictType` is not provided\n   */\n  type?: string;\n  /**\n   * Path where the rule applies\n   */\n  path: Path;\n}\n\nexport interface NormalizeTypesPlugin extends ErrorHandler {\n  /**\n   * Set of rules for the types.\n   * For each rule, provide a `path` and either `strictType` or `type`.\n   * If there is no node existing at `path`:\n   * insert a node with `strictType`.\n   * If there is a node existing at `path` but its type is not `strictType` or `type`:\n   * set the node type to `strictType` or `type`.\n   */\n  rules?: Rule[];\n}\n\nexport const KEY_NORMALIZE_TYPES = 'normalizeTypes';\n\n/**\n * @see {@link withNormalizeTypes}\n */\nexport const createNormalizeTypesPlugin = createPluginFactory<NormalizeTypesPlugin>(\n  {\n    key: KEY_NORMALIZE_TYPES,\n    withOverrides: withNormalizeTypes,\n    options: {\n      rules: [],\n    },\n  }\n);\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var isArray = require('./isArray');\n\n/**\n * Casts `value` as an array if it's not one.\n *\n * @static\n * @memberOf _\n * @since 4.4.0\n * @category Lang\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast array.\n * @example\n *\n * _.castArray(1);\n * // => [1]\n *\n * _.castArray({ 'a': 1 });\n * // => [{ 'a': 1 }]\n *\n * _.castArray('abc');\n * // => ['abc']\n *\n * _.castArray(null);\n * // => [null]\n *\n * _.castArray(undefined);\n * // => [undefined]\n *\n * _.castArray();\n * // => []\n *\n * var array = [1, 2, 3];\n * console.log(_.castArray(array) === array);\n * // => true\n */\nfunction castArray() {\n  if (!arguments.length) {\n    return [];\n  }\n  var value = arguments[0];\n  return isArray(value) ? value : [value];\n}\n\nmodule.exports = castArray;\n","import { isElement, WithOverride } from '@udecode/plate-core';\nimport castArray from 'lodash/castArray';\nimport { Node, NodeEntry, Transforms } from 'slate';\nimport { RemoveEmptyNodesPlugin } from './createRemoveEmptyNodesPlugin';\n\n/**\n * Remove nodes with empty text.\n */\nexport const withRemoveEmptyNodes: WithOverride<{}, RemoveEmptyNodesPlugin> = (\n  editor,\n  { options: { types: _types } }\n) => {\n  const types = castArray(_types);\n\n  const { normalizeNode } = editor;\n\n  editor.normalizeNode = ([node, path]: NodeEntry) => {\n    if (\n      isElement(node) &&\n      node.type &&\n      types.includes(node.type) &&\n      Node.string(node) === ''\n    ) {\n      Transforms.removeNodes(editor, { at: path });\n      return;\n    }\n\n    normalizeNode([node, path]);\n  };\n\n  return editor;\n};\n","import { createPluginFactory } from '@udecode/plate-core';\nimport { withRemoveEmptyNodes } from './withRemoveEmptyNodes';\n\nexport interface RemoveEmptyNodesPlugin {\n  types?: string | string[];\n}\n\n/**\n * @see {@link withRemoveEmptyNodes}\n */\nexport const createRemoveEmptyNodesPlugin = createPluginFactory<RemoveEmptyNodesPlugin>(\n  {\n    key: 'removeEmptyNodes',\n    withOverrides: withRemoveEmptyNodes,\n  }\n);\n"]},"metadata":{},"sourceType":"module"}