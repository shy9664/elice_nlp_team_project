{"ast":null,"code":"import { getParent, getPluginType, getAbove, isCollapsed, getNode, match, isRangeAcrossBlocks, someNode, wrapNodes, findDescendant, getLastChildPath, moveChildren, setNodes, ELEMENT_DEFAULT, unwrapNodes, isLastChild, insertNodes, getNodes, isBlockTextEmptyAfterSelection, isFirstChild, isExpanded, getPreviousPath, deleteFragment, findNode, isSelectionAtBlockStart, mockPlugin, isSelectionAtBlockEnd, getBlockAbove, getText, getChildren, isBlockAboveEmpty, getPlugin, insertEmptyElement, isElement, createPluginFactory, KEY_DESERIALIZE_HTML, onKeyDownToggleElement } from '@udecode/plate-core';\nimport { Path, Range, Editor, Transforms, Node } from 'slate';\nimport { onKeyDownResetNode, SIMULATE_BACKSPACE } from '@udecode/plate-reset-node';\n/**\r\n * Checks if `value` is classified as an `Array` object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\r\n * @example\r\n *\r\n * _.isArray([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isArray(document.body.children);\r\n * // => false\r\n *\r\n * _.isArray('abc');\r\n * // => false\r\n *\r\n * _.isArray(_.noop);\r\n * // => false\r\n */\n\nvar isArray = Array.isArray;\nvar isArray_1 = isArray;\n/**\r\n * Casts `value` as an array if it's not one.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.4.0\r\n * @category Lang\r\n * @param {*} value The value to inspect.\r\n * @returns {Array} Returns the cast array.\r\n * @example\r\n *\r\n * _.castArray(1);\r\n * // => [1]\r\n *\r\n * _.castArray({ 'a': 1 });\r\n * // => [{ 'a': 1 }]\r\n *\r\n * _.castArray('abc');\r\n * // => ['abc']\r\n *\r\n * _.castArray(null);\r\n * // => [null]\r\n *\r\n * _.castArray(undefined);\r\n * // => [undefined]\r\n *\r\n * _.castArray();\r\n * // => []\r\n *\r\n * var array = [1, 2, 3];\r\n * console.log(_.castArray(array) === array);\r\n * // => true\r\n */\n\nfunction castArray() {\n  if (!arguments.length) {\n    return [];\n  }\n\n  var value = arguments[0];\n  return isArray_1(value) ? value : [value];\n}\n\nvar castArray_1 = castArray;\n\nfunction unwrapExports(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar lib = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  /**\r\n   * Constants.\r\n   */\n\n  var IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n  var MODIFIERS = {\n    alt: 'altKey',\n    control: 'ctrlKey',\n    meta: 'metaKey',\n    shift: 'shiftKey'\n  };\n  var ALIASES = {\n    add: '+',\n    break: 'pause',\n    cmd: 'meta',\n    command: 'meta',\n    ctl: 'control',\n    ctrl: 'control',\n    del: 'delete',\n    down: 'arrowdown',\n    esc: 'escape',\n    ins: 'insert',\n    left: 'arrowleft',\n    mod: IS_MAC ? 'meta' : 'control',\n    opt: 'alt',\n    option: 'alt',\n    return: 'enter',\n    right: 'arrowright',\n    space: ' ',\n    spacebar: ' ',\n    up: 'arrowup',\n    win: 'meta',\n    windows: 'meta'\n  };\n  var CODES = {\n    backspace: 8,\n    tab: 9,\n    enter: 13,\n    shift: 16,\n    control: 17,\n    alt: 18,\n    pause: 19,\n    capslock: 20,\n    escape: 27,\n    ' ': 32,\n    pageup: 33,\n    pagedown: 34,\n    end: 35,\n    home: 36,\n    arrowleft: 37,\n    arrowup: 38,\n    arrowright: 39,\n    arrowdown: 40,\n    insert: 45,\n    delete: 46,\n    meta: 91,\n    numlock: 144,\n    scrolllock: 145,\n    ';': 186,\n    '=': 187,\n    ',': 188,\n    '-': 189,\n    '.': 190,\n    '/': 191,\n    '`': 192,\n    '[': 219,\n    '\\\\': 220,\n    ']': 221,\n    '\\'': 222\n  };\n\n  for (var f = 1; f < 20; f++) {\n    CODES['f' + f] = 111 + f;\n  }\n  /**\r\n   * Is hotkey?\r\n   */\n\n\n  function isHotkey(hotkey, options, event) {\n    if (options && !('byKey' in options)) {\n      event = options;\n      options = null;\n    }\n\n    if (!Array.isArray(hotkey)) {\n      hotkey = [hotkey];\n    }\n\n    var array = hotkey.map(function (string) {\n      return parseHotkey(string, options);\n    });\n\n    var check = function check(e) {\n      return array.some(function (object) {\n        return compareHotkey(object, e);\n      });\n    };\n\n    var ret = event == null ? check : check(event);\n    return ret;\n  }\n\n  function isCodeHotkey(hotkey, event) {\n    return isHotkey(hotkey, event);\n  }\n\n  function isKeyHotkey(hotkey, event) {\n    return isHotkey(hotkey, {\n      byKey: true\n    }, event);\n  }\n  /**\r\n   * Parse.\r\n   */\n\n\n  function parseHotkey(hotkey, options) {\n    var byKey = options && options.byKey;\n    var ret = {}; // Special case to handle the `+` key since we use it as a separator.\n\n    hotkey = hotkey.replace('++', '+add');\n    var values = hotkey.split('+');\n    var length = values.length; // Ensure that all the modifiers are set to false unless the hotkey has them.\n\n    for (var k in MODIFIERS) {\n      ret[MODIFIERS[k]] = false;\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var value = _step.value;\n        var optional = value.endsWith('?') && value.length > 1;\n\n        if (optional) {\n          value = value.slice(0, -1);\n        }\n\n        var name = toKeyName(value);\n        var modifier = MODIFIERS[name];\n\n        if (length === 1 || !modifier) {\n          if (byKey) {\n            ret.key = name;\n          } else {\n            ret.which = toKeyCode(value);\n          }\n        }\n\n        if (modifier) {\n          ret[modifier] = optional ? null : true;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return ret;\n  }\n  /**\r\n   * Compare.\r\n   */\n\n\n  function compareHotkey(object, event) {\n    for (var key in object) {\n      var expected = object[key];\n      var actual = void 0;\n\n      if (expected == null) {\n        continue;\n      }\n\n      if (key === 'key' && event.key != null) {\n        actual = event.key.toLowerCase();\n      } else if (key === 'which') {\n        actual = expected === 91 && event.which === 93 ? 91 : event.which;\n      } else {\n        actual = event[key];\n      }\n\n      if (actual == null && expected === false) {\n        continue;\n      }\n\n      if (actual !== expected) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\r\n   * Utils.\r\n   */\n\n\n  function toKeyCode(name) {\n    name = toKeyName(name);\n    var code = CODES[name] || name.toUpperCase().charCodeAt(0);\n    return code;\n  }\n\n  function toKeyName(name) {\n    name = name.toLowerCase();\n    name = ALIASES[name] || name;\n    return name;\n  }\n  /**\r\n   * Export.\r\n   */\n\n\n  exports.default = isHotkey;\n  exports.isHotkey = isHotkey;\n  exports.isCodeHotkey = isCodeHotkey;\n  exports.isKeyHotkey = isKeyHotkey;\n  exports.parseHotkey = parseHotkey;\n  exports.compareHotkey = compareHotkey;\n  exports.toKeyCode = toKeyCode;\n  exports.toKeyName = toKeyName;\n});\nvar isHotkey = unwrapExports(lib);\nlib.isHotkey;\nlib.isCodeHotkey;\nlib.isKeyHotkey;\nlib.parseHotkey;\nlib.compareHotkey;\nlib.toKeyCode;\nlib.toKeyName;\n/**\r\n * Is the list nested, i.e. its parent is a list item.\r\n */\n\nconst isListNested = (editor, listPath) => {\n  var _getParent;\n\n  const listParentNode = (_getParent = getParent(editor, listPath)) === null || _getParent === void 0 ? void 0 : _getParent[0];\n  return (listParentNode === null || listParentNode === void 0 ? void 0 : listParentNode.type) === getPluginType(editor, ELEMENT_LI);\n};\n\nconst getListTypes = editor => {\n  return [getPluginType(editor, ELEMENT_OL), getPluginType(editor, ELEMENT_UL)];\n};\n/**\r\n * Find the highest end list that can be deleted.\r\n * Its path should be different to diffListPath.\r\n * If the highest end list 2+ items, return liPath.\r\n * Get the parent list until:\r\n * - the list has less than 2 items.\r\n * - its path is not equals to diffListPath.\r\n */\n\n\nconst getHighestEmptyList = (editor, {\n  diffListPath,\n  liPath\n}) => {\n  const list = getAbove(editor, {\n    at: liPath,\n    match: {\n      type: getListTypes(editor)\n    }\n  });\n  if (!list) return;\n  const [listNode, listPath] = list;\n\n  if (!diffListPath || !Path.equals(listPath, diffListPath)) {\n    if (listNode.children.length < 2) {\n      const liParent = getAbove(editor, {\n        at: listPath,\n        match: {\n          type: getPluginType(editor, ELEMENT_LI)\n        }\n      });\n\n      if (liParent) {\n        return getHighestEmptyList(editor, {\n          liPath: liParent[1],\n          diffListPath\n        }) || listPath;\n      }\n    }\n\n    return liPath;\n  }\n};\n/**\r\n * Returns the nearest li and ul / ol wrapping node entries for a given path (default = selection)\r\n */\n\n\nconst getListItemEntry = (editor, {\n  at = editor.selection\n} = {}) => {\n  const liType = getPluginType(editor, ELEMENT_LI);\n\n  let _at;\n\n  if (Range.isRange(at) && !isCollapsed(at)) {\n    _at = at.focus.path;\n  } else if (Range.isRange(at)) {\n    _at = at.anchor.path;\n  } else {\n    _at = at;\n  }\n\n  if (_at) {\n    const node = getNode(editor, _at);\n\n    if (node) {\n      const listItem = getAbove(editor, {\n        at: _at,\n        match: {\n          type: liType\n        }\n      });\n\n      if (listItem) {\n        const list = getParent(editor, listItem[1]);\n        return {\n          list,\n          listItem\n        };\n      }\n    }\n  }\n};\n/**\r\n * Searches upward for the root list element\r\n */\n\n\nconst getListRoot = (editor, at = editor.selection) => {\n  if (!at) return;\n  const parentList = getAbove(editor, {\n    at,\n    match: {\n      type: [getPluginType(editor, ELEMENT_UL), getPluginType(editor, ELEMENT_OL)]\n    }\n  });\n\n  if (parentList) {\n    var _getListRoot;\n\n    const [, parentListPath] = parentList;\n    return (_getListRoot = getListRoot(editor, parentListPath)) !== null && _getListRoot !== void 0 ? _getListRoot : parentList;\n  }\n};\n/**\r\n * Is there a list child in the node.\r\n */\n\n\nconst hasListChild = (editor, node) => node.children.some(n => match(n, {\n  type: getListTypes(editor)\n}));\n/**\r\n * Is selection across blocks with list items\r\n */\n\n\nconst isAcrossListItems = editor => {\n  const {\n    selection\n  } = editor;\n\n  if (!selection || isCollapsed(selection)) {\n    return false;\n  }\n\n  const isAcrossBlocks = isRangeAcrossBlocks(editor);\n  if (!isAcrossBlocks) return false;\n  return someNode(editor, {\n    match: {\n      type: getPluginType(editor, ELEMENT_LI)\n    }\n  });\n};\n\nconst moveListItemDown = (editor, {\n  list,\n  listItem\n}) => {\n  const [listNode] = list;\n  const [, listItemPath] = listItem;\n  let previousListItemPath;\n\n  try {\n    previousListItemPath = Path.previous(listItemPath);\n  } catch (e) {\n    return;\n  } // Previous sibling is the new parent\n\n\n  const previousSiblingItem = Editor.node(editor, previousListItemPath);\n\n  if (previousSiblingItem) {\n    const [previousNode, previousPath] = previousSiblingItem;\n    const sublist = previousNode.children.find(n => match(n, {\n      type: getListTypes(editor)\n    }));\n    const newPath = previousPath.concat(sublist ? [1, sublist.children.length] : [1]);\n    Editor.withoutNormalizing(editor, () => {\n      if (!sublist) {\n        // Create new sublist\n        wrapNodes(editor, {\n          type: listNode.type,\n          children: []\n        }, {\n          at: listItemPath\n        });\n      } // Move the current item to the sublist\n\n\n      Transforms.moveNodes(editor, {\n        at: listItemPath,\n        to: newPath\n      });\n    });\n  }\n};\n/**\r\n * Move the list items of the sublist of `fromListItem` to `toList` (if `fromListItem` is defined).\r\n * Move the list items of `fromList` to `toList` (if `fromList` is defined).\r\n */\n\n\nconst moveListItemsToList = (editor, {\n  fromList,\n  fromListItem,\n  fromStartIndex,\n  to: _to,\n  toList,\n  toListIndex = null,\n  deleteFromList = true\n}) => {\n  let fromListPath;\n  let moved;\n  Editor.withoutNormalizing(editor, () => {\n    if (fromListItem) {\n      const fromListItemSublist = findDescendant(editor, {\n        at: fromListItem[1],\n        match: {\n          type: getListTypes(editor)\n        }\n      });\n      if (!fromListItemSublist) return 0;\n      fromListPath = fromListItemSublist === null || fromListItemSublist === void 0 ? void 0 : fromListItemSublist[1];\n    } else if (fromList) {\n      // eslint-disable-next-line prefer-destructuring\n      fromListPath = fromList[1];\n    } else {\n      return;\n    }\n\n    let to = null;\n    if (_to) to = _to;\n\n    if (toList) {\n      if (toListIndex !== null) to = toList[1].concat([toListIndex]);else {\n        const lastChildPath = getLastChildPath(toList);\n        to = Path.next(lastChildPath);\n      }\n    }\n\n    if (!to) return;\n    moved = moveChildren(editor, {\n      at: fromListPath,\n      to,\n      fromStartIndex\n    }); // Remove the empty list\n\n    if (deleteFromList) {\n      Transforms.delete(editor, {\n        at: fromListPath\n      });\n    }\n  });\n  return moved;\n};\n\nconst unwrapList = (editor, {\n  at\n} = {}) => {\n  Editor.withoutNormalizing(editor, () => {\n    do {\n      setNodes(editor, {\n        type: getPluginType(editor, ELEMENT_DEFAULT)\n      });\n      unwrapNodes(editor, {\n        at,\n        match: {\n          type: getPluginType(editor, ELEMENT_LI)\n        },\n        split: true\n      });\n      unwrapNodes(editor, {\n        at,\n        match: {\n          type: [getPluginType(editor, ELEMENT_UL), getPluginType(editor, ELEMENT_OL)]\n        },\n        split: true\n      });\n    } while (getAbove(editor, {\n      match: {\n        type: getListTypes(editor),\n        at\n      }\n    }));\n  });\n};\n/**\r\n * Move a list item up.\r\n */\n\n\nconst moveListItemUp = (editor, {\n  list,\n  listItem\n}) => {\n  const move = () => {\n    const [listNode, listPath] = list;\n    const [liNode, liPath] = listItem;\n    const liParent = getAbove(editor, {\n      at: listPath,\n      match: {\n        type: getPluginType(editor, ELEMENT_LI)\n      }\n    });\n\n    if (!liParent) {\n      let toListPath;\n\n      try {\n        toListPath = Path.next(listPath);\n      } catch (err) {\n        return;\n      }\n\n      const condA = hasListChild(editor, liNode);\n      const condB = !isLastChild(list, liPath);\n\n      if (condA || condB) {\n        // Insert a new list next to `list`\n        insertNodes(editor, {\n          type: listNode.type,\n          children: []\n        }, {\n          at: toListPath\n        });\n      }\n\n      if (condA) {\n        const toListNode = getNode(editor, toListPath);\n        if (!toListNode) return; // Move li sub-lis to the new list\n\n        moveListItemsToList(editor, {\n          fromListItem: listItem,\n          toList: [toListNode, toListPath]\n        });\n      } // If there is siblings li, move them to the new list\n\n\n      if (condB) {\n        const toListNode = getNode(editor, toListPath);\n        if (!toListNode) return; // Move next lis to the new list\n\n        moveListItemsToList(editor, {\n          fromList: list,\n          fromStartIndex: liPath[liPath.length - 1] + 1,\n          toList: [toListNode, toListPath],\n          deleteFromList: false\n        });\n      } // Finally, unwrap the list\n\n\n      unwrapList(editor, {\n        at: liPath.concat(0)\n      });\n      return true;\n    }\n\n    const [, liParentPath] = liParent;\n    const toListPath = liPath.concat([1]); // If li has next siblings, we need to move them.\n\n    if (!isLastChild(list, liPath)) {\n      // If li has no sublist, insert one.\n      if (!hasListChild(editor, liNode)) {\n        insertNodes(editor, {\n          type: listNode.type,\n          children: []\n        }, {\n          at: toListPath\n        });\n      }\n\n      const toListNode = getNode(editor, toListPath);\n      if (!toListNode) return; // Move next siblings to li sublist.\n\n      moveListItemsToList(editor, {\n        fromListItem: liParent,\n        toList: [toListNode, toListPath],\n        fromStartIndex: liPath[liPath.length - 1] + 1,\n        deleteFromList: false\n      });\n    }\n\n    const movedUpLiPath = Path.next(liParentPath); // Move li one level up: next to the li parent.\n\n    Transforms.moveNodes(editor, {\n      at: liPath,\n      to: movedUpLiPath\n    });\n    return true;\n  };\n\n  let moved = false;\n  Editor.withoutNormalizing(editor, () => {\n    moved = move();\n  });\n  return moved;\n};\n\nconst moveListItems = (editor, {\n  increase = true,\n  at = (() => {\n    var _editor$selection;\n\n    return (_editor$selection = editor.selection) !== null && _editor$selection !== void 0 ? _editor$selection : undefined;\n  })()\n} = {}) => {\n  // Get the selected lic\n  const [...lics] = getNodes(editor, {\n    at,\n    match: {\n      type: getPluginType(editor, ELEMENT_LIC)\n    }\n  });\n  if (!lics.length) return;\n  const highestLicPaths = [];\n  const highestLicPathRefs = []; // Filter out the nested lic, we just need to move the highest ones\n\n  lics.forEach(lic => {\n    const licPath = lic[1];\n    const liPath = Path.parent(licPath);\n    const isAncestor = highestLicPaths.some(path => {\n      const highestLiPath = Path.parent(path);\n      return Path.isAncestor(highestLiPath, liPath);\n    });\n\n    if (!isAncestor) {\n      highestLicPaths.push(licPath);\n      highestLicPathRefs.push(Editor.pathRef(editor, licPath));\n    }\n  });\n  const licPathRefsToMove = increase ? highestLicPathRefs : highestLicPathRefs.reverse();\n  Editor.withoutNormalizing(editor, () => {\n    licPathRefsToMove.forEach(licPathRef => {\n      const licPath = licPathRef.unref();\n      if (!licPath) return;\n      const listItem = getParent(editor, licPath);\n      if (!listItem) return;\n      const listEntry = getParent(editor, listItem[1]);\n\n      if (increase) {\n        moveListItemDown(editor, {\n          list: listEntry,\n          listItem: listItem\n        });\n      } else if (listEntry && isListNested(editor, listEntry[1])) {\n        moveListItemUp(editor, {\n          list: listEntry,\n          listItem: listItem\n        });\n      }\n    });\n  });\n};\n\nconst indentListItems = editor => {\n  moveListItems(editor, {\n    increase: true\n  });\n};\n/**\r\n * Insert list item if selection in li>p.\r\n * TODO: test\r\n */\n\n\nconst insertListItem = editor => {\n  const liType = getPluginType(editor, ELEMENT_LI);\n  const licType = getPluginType(editor, ELEMENT_LIC);\n\n  if (!editor.selection) {\n    return false;\n  }\n\n  const licEntry = getAbove(editor, {\n    match: {\n      type: licType\n    }\n  });\n  if (!licEntry) return false;\n  const [, paragraphPath] = licEntry;\n  const listItemEntry = getParent(editor, paragraphPath);\n  if (!listItemEntry) return false;\n  const [listItemNode, listItemPath] = listItemEntry;\n  if (listItemNode.type !== liType) return false;\n  let success = false;\n  Editor.withoutNormalizing(editor, () => {\n    if (!Range.isCollapsed(editor.selection)) {\n      Transforms.delete(editor);\n    }\n\n    const isStart = Editor.isStart(editor, editor.selection.focus, paragraphPath);\n    const isEnd = isBlockTextEmptyAfterSelection(editor);\n    const nextParagraphPath = Path.next(paragraphPath);\n    const nextListItemPath = Path.next(listItemPath);\n    /**\r\n     * If start, insert a list item before\r\n     */\n\n    if (isStart) {\n      insertNodes(editor, {\n        type: liType,\n        children: [{\n          type: licType,\n          children: [{\n            text: ''\n          }]\n        }]\n      }, {\n        at: listItemPath\n      });\n      success = true;\n      return;\n    }\n    /**\r\n     * If not end, split nodes, wrap a list item on the new paragraph and move it to the next list item\r\n     */\n\n\n    if (!isEnd) {\n      Editor.withoutNormalizing(editor, () => {\n        Transforms.splitNodes(editor);\n        wrapNodes(editor, {\n          type: liType,\n          children: []\n        }, {\n          at: nextParagraphPath\n        });\n        Transforms.moveNodes(editor, {\n          at: nextParagraphPath,\n          to: nextListItemPath\n        });\n        Transforms.select(editor, nextListItemPath);\n        Transforms.collapse(editor, {\n          edge: 'start'\n        });\n      });\n    } else {\n      /**\r\n       * If end, insert a list item after and select it\r\n       */\n      const marks = Editor.marks(editor) || {};\n      insertNodes(editor, {\n        type: liType,\n        children: [{\n          type: licType,\n          children: [{\n            text: '',\n            ...marks\n          }]\n        }]\n      }, {\n        at: nextListItemPath\n      });\n      Transforms.select(editor, nextListItemPath);\n    }\n    /**\r\n     * If there is a list in the list item, move it to the next list item\r\n     */\n\n\n    if (listItemNode.children.length > 1) {\n      Transforms.moveNodes(editor, {\n        at: nextParagraphPath,\n        to: nextListItemPath.concat(1)\n      });\n    }\n\n    success = true;\n  });\n  return success;\n};\n/**\r\n * Move fromListItem sublist list items to the end of `toListItem` sublist.\r\n * If there is no `toListItem` sublist, insert one.\r\n */\n\n\nconst moveListItemSublistItemsToListItemSublist = (editor, {\n  fromListItem,\n  toListItem,\n  start\n}) => {\n  const [, fromListItemPath] = fromListItem;\n  const [, toListItemPath] = toListItem;\n  let moved = 0;\n  Editor.withoutNormalizing(editor, () => {\n    const fromListItemSublist = findDescendant(editor, {\n      at: fromListItemPath,\n      match: {\n        type: getListTypes(editor)\n      }\n    });\n    if (!fromListItemSublist) return 0;\n    const [, fromListItemSublistPath] = fromListItemSublist;\n    const toListItemSublist = findDescendant(editor, {\n      at: toListItemPath,\n      match: {\n        type: getListTypes(editor)\n      }\n    });\n    let to;\n\n    if (!toListItemSublist) {\n      const fromList = getParent(editor, fromListItemPath);\n      if (!fromList) return 0;\n      const [fromListNode] = fromList;\n      const fromListType = fromListNode.type;\n      const toListItemSublistPath = toListItemPath.concat([1]);\n      insertNodes(editor, {\n        type: fromListType,\n        children: []\n      }, {\n        at: toListItemSublistPath\n      });\n      to = toListItemSublistPath.concat([0]);\n    } else if (start) {\n      const [, toListItemSublistPath] = toListItemSublist;\n      to = toListItemSublistPath.concat([0]);\n    } else {\n      to = Path.next(getLastChildPath(toListItemSublist));\n    }\n\n    moved = moveChildren(editor, {\n      at: fromListItemSublistPath,\n      to\n    }); // Remove the empty list\n\n    Transforms.delete(editor, {\n      at: fromListItemSublistPath\n    });\n  });\n  return moved;\n};\n\nconst moveListSiblingsAfterCursor = (editor, {\n  at,\n  to\n}) => {\n  const offset = at[at.length - 1];\n  at = Path.parent(at);\n  const listNode = Node.get(editor, at);\n  const listEntry = [listNode, at];\n\n  if (!match(listNode, {\n    type: getListTypes(editor)\n  }) || Path.isParent(at, to) // avoid moving nodes within its own list\n  ) {\n      return 0;\n    }\n\n  return moveChildren(editor, {\n    at: listEntry,\n    to,\n    fromStartIndex: offset + 1\n  });\n};\n/**\r\n * If list is not nested and if li is not the first child, move li up.\r\n */\n\n\nconst removeFirstListItem = (editor, {\n  list,\n  listItem\n}) => {\n  const [, listPath] = list;\n  const [, listItemPath] = listItem;\n\n  if (!isListNested(editor, listPath) && !isFirstChild(listItemPath)) {\n    moveListItemUp(editor, {\n      list,\n      listItem\n    });\n    return true;\n  }\n\n  return false;\n};\n/**\r\n * Remove list item and move its sublist to list if any.\r\n */\n\n\nconst removeListItem = (editor, {\n  list,\n  listItem,\n  reverse = true\n}) => {\n  const [liNode, liPath] = listItem; // Stop if the list item has no sublist\n\n  if (isExpanded(editor.selection) || !hasListChild(editor, liNode)) {\n    return false;\n  }\n\n  const previousLiPath = getPreviousPath(liPath);\n  let success = false;\n  Editor.withoutNormalizing(editor, () => {\n    /**\r\n     * If there is a previous li, we need to move sub-lis to the previous li.\r\n     * As we need to delete first, we will:\r\n     * 1. insert a temporary li: tempLi\r\n     * 2. move sub-lis to tempLi\r\n     * 3. delete\r\n     * 4. move sub-lis from tempLi to the previous li.\r\n     * 5. remove tempLi\r\n     */\n    if (previousLiPath) {\n      const previousLi = Editor.node(editor, previousLiPath); // 1\n\n      let tempLiPath = Path.next(liPath);\n      insertNodes(editor, {\n        type: getPluginType(editor, ELEMENT_LI),\n        children: [{\n          type: getPluginType(editor, ELEMENT_LIC),\n          children: [{\n            text: ''\n          }]\n        }]\n      }, {\n        at: tempLiPath\n      });\n      const tempLi = Editor.node(editor, tempLiPath);\n      const tempLiPathRef = Editor.pathRef(editor, tempLi[1]); // 2\n\n      moveListItemSublistItemsToListItemSublist(editor, {\n        fromListItem: listItem,\n        toListItem: tempLi\n      }); // 3\n\n      deleteFragment(editor, {\n        reverse\n      });\n      tempLiPath = tempLiPathRef.unref(); // 4\n\n      moveListItemSublistItemsToListItemSublist(editor, {\n        fromListItem: [tempLi[0], tempLiPath],\n        toListItem: previousLi\n      }); // 5\n\n      Transforms.removeNodes(editor, {\n        at: tempLiPath\n      });\n      success = true;\n      return;\n    } // If it's the first li, move the sublist to the parent list\n\n\n    moveListItemsToList(editor, {\n      fromListItem: listItem,\n      toList: list,\n      toListIndex: 1\n    });\n  });\n  return success;\n};\n\nconst toggleList = (editor, {\n  type\n}) => Editor.withoutNormalizing(editor, () => {\n  if (!editor.selection) {\n    return;\n  }\n\n  if (isCollapsed(editor.selection) || !isRangeAcrossBlocks(editor)) {\n    // selection is collapsed\n    const res = getListItemEntry(editor);\n\n    if (res) {\n      const {\n        list\n      } = res;\n\n      if (list[0].type !== type) {\n        setNodes(editor, {\n          type\n        }, {\n          at: editor.selection,\n          match: n => getListTypes(editor).includes(n.type),\n          mode: 'lowest'\n        });\n      } else {\n        unwrapList(editor);\n      }\n    } else {\n      const list = {\n        type,\n        children: []\n      };\n      wrapNodes(editor, list);\n      const nodes = [...getNodes(editor, {\n        match: {\n          type: getPluginType(editor, ELEMENT_DEFAULT)\n        }\n      })];\n      setNodes(editor, {\n        type: getPluginType(editor, ELEMENT_LIC)\n      });\n      const listItem = {\n        type: getPluginType(editor, ELEMENT_LI),\n        children: []\n      };\n\n      for (const [, path] of nodes) {\n        wrapNodes(editor, listItem, {\n          at: path\n        });\n      }\n    }\n  } else {\n    // selection is a range\n    const [startPoint, endPoint] = Range.edges(editor.selection);\n    const commonEntry = Node.common(editor, startPoint.path, endPoint.path);\n\n    if (getListTypes(editor).includes(commonEntry[0].type) || commonEntry[0].type === getPluginType(editor, ELEMENT_LI)) {\n      if (commonEntry[0].type !== type) {\n        const startList = findNode(editor, {\n          at: Range.start(editor.selection),\n          match: {\n            type: getListTypes(editor)\n          },\n          mode: 'lowest'\n        });\n        const endList = findNode(editor, {\n          at: Range.end(editor.selection),\n          match: {\n            type: getListTypes(editor)\n          },\n          mode: 'lowest'\n        });\n        const rangeLength = Math.min(startList[1].length, endList[1].length);\n        setNodes(editor, {\n          type\n        }, {\n          at: editor.selection,\n          match: (n, path) => getListTypes(editor).includes(n.type) && path.length >= rangeLength,\n          mode: 'all'\n        });\n      } else {\n        unwrapList(editor);\n      }\n    } else {\n      const rootPathLength = commonEntry[1].length;\n      const nodes = Array.from(getNodes(editor, {\n        mode: 'all'\n      })).filter(([, path]) => path.length === rootPathLength + 1).reverse();\n      nodes.forEach(n => {\n        if (getListTypes(editor).includes(n[0].type)) {\n          setNodes(editor, {\n            type\n          }, {\n            at: n[1]\n          });\n        } else {\n          setNodes(editor, {\n            type: getPluginType(editor, ELEMENT_LIC)\n          }, {\n            at: n[1]\n          });\n          const listItem = {\n            type: getPluginType(editor, ELEMENT_LI),\n            children: []\n          };\n          wrapNodes(editor, listItem, {\n            at: n[1]\n          });\n          const list = {\n            type,\n            children: []\n          };\n          wrapNodes(editor, list, {\n            at: n[1]\n          });\n        }\n      });\n    }\n  }\n});\n\nconst unindentListItems = (editor, options = {}) => moveListItems(editor, { ...options,\n  increase: false\n});\n\nconst onKeyDownList = (editor, {\n  type,\n  options: {\n    hotkey\n  }\n}) => e => {\n  if (e.key === 'Tab' && editor.selection) {\n    const listSelected = getAbove(editor, {\n      at: editor.selection,\n      match: {\n        type\n      }\n    });\n\n    if (listSelected) {\n      e.preventDefault();\n      moveListItems(editor, {\n        increase: !e.shiftKey\n      });\n      return;\n    }\n  }\n\n  if (!hotkey) return;\n  const hotkeys = castArray_1(hotkey);\n\n  for (const _hotkey of hotkeys) {\n    if (isHotkey(_hotkey)(e)) {\n      toggleList(editor, {\n        type: type\n      });\n    }\n  }\n};\n\nconst deleteBackwardList = (editor, unit) => {\n  const res = getListItemEntry(editor, {});\n  let moved = false;\n\n  if (res) {\n    const {\n      list,\n      listItem\n    } = res;\n\n    if (isSelectionAtBlockStart(editor, {\n      match: node => node.type === ELEMENT_LI\n    })) {\n      Editor.withoutNormalizing(editor, () => {\n        moved = removeFirstListItem(editor, {\n          list,\n          listItem\n        });\n        if (moved) return true;\n        moved = removeListItem(editor, {\n          list,\n          listItem\n        });\n        if (moved) return true;\n\n        if (isFirstChild(listItem[1]) && !isListNested(editor, list[1])) {\n          onKeyDownResetNode(editor, mockPlugin({\n            options: {\n              rules: [{\n                types: [getPluginType(editor, ELEMENT_LI)],\n                defaultType: getPluginType(editor, ELEMENT_DEFAULT),\n                hotkey: 'backspace',\n                predicate: () => isSelectionAtBlockStart(editor),\n                onReset: e => unwrapList(e)\n              }]\n            }\n          }))(SIMULATE_BACKSPACE);\n          moved = true;\n          return;\n        }\n\n        deleteFragment(editor, {\n          unit,\n          reverse: true\n        });\n        moved = true;\n      });\n    }\n  }\n\n  return moved;\n};\n\nconst pathToEntry = (editor, path) => Editor.node(editor, path);\n\nconst selectionIsNotInAListHandler = editor => {\n  const pointAfterSelection = Editor.after(editor, editor.selection.focus.path);\n\n  if (pointAfterSelection) {\n    // there is a block after it\n    const nextSiblingListRes = getListItemEntry(editor, {\n      at: pointAfterSelection\n    });\n\n    if (nextSiblingListRes) {\n      // the next block is a list\n      const {\n        listItem\n      } = nextSiblingListRes;\n      const parentBlockEntity = getBlockAbove(editor, {\n        at: editor.selection.anchor\n      });\n\n      if (!getText(editor, parentBlockEntity[1])) {\n        // the selected block is empty\n        Transforms.removeNodes(editor);\n        return true;\n      }\n\n      if (hasListChild(editor, listItem[0])) {\n        // the next block has children, so we have to move the first item up\n        const sublistRes = getListItemEntry(editor, {\n          at: [...listItem[1], 1, 0, 0]\n        });\n        moveListItemUp(editor, sublistRes);\n      }\n    }\n  }\n\n  return false;\n};\n\nconst selectionIsInAListHandler = (editor, res) => {\n  const {\n    listItem\n  } = res; // if it has no children\n\n  if (!hasListChild(editor, listItem[0])) {\n    const liType = getPluginType(editor, ELEMENT_LI);\n    const liWithSiblings = Array.from(Editor.nodes(editor, {\n      at: listItem[1],\n      mode: 'lowest',\n      match: (node, path) => {\n        var _getNode;\n\n        if (path.length === 0) {\n          return false;\n        }\n\n        const isNodeLi = node.type === liType;\n        const isSiblingOfNodeLi = ((_getNode = getNode(editor, Path.next(path))) === null || _getNode === void 0 ? void 0 : _getNode.type) === liType;\n        return isNodeLi && isSiblingOfNodeLi;\n      }\n    }), entry => entry[1])[0];\n\n    if (!liWithSiblings) {\n      // there are no more list item in the list\n      const pointAfterListItem = Editor.after(editor, listItem[1]);\n\n      if (pointAfterListItem) {\n        // there is a block after it\n        const nextSiblingListRes = getListItemEntry(editor, {\n          at: pointAfterListItem\n        });\n\n        if (nextSiblingListRes) {\n          // it is a list so we merge the lists\n          const listRoot = getListRoot(editor, listItem[1]);\n          moveListItemsToList(editor, {\n            fromList: nextSiblingListRes.list,\n            toList: listRoot,\n            deleteFromList: true\n          });\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    const siblingListItem = pathToEntry(editor, Path.next(liWithSiblings));\n    const siblingList = Editor.parent(editor, siblingListItem[1]);\n\n    if (removeListItem(editor, {\n      list: siblingList,\n      listItem: siblingListItem,\n      reverse: false\n    })) {\n      return true;\n    } // if (skipDefaultDelete) return skipDefaultDelete;\n\n\n    return false;\n  } // if it has children\n\n\n  const nestedList = pathToEntry(editor, Path.next([...listItem[1], 0]));\n  const nestedListItem = getChildren(nestedList)[0];\n\n  if (removeFirstListItem(editor, {\n    list: nestedList,\n    listItem: nestedListItem\n  })) {\n    return true;\n  }\n\n  if (removeListItem(editor, {\n    list: nestedList,\n    listItem: nestedListItem\n  })) {\n    return true;\n  }\n\n  return false;\n};\n\nconst deleteForwardList = editor => {\n  let skipDefaultDelete = false;\n\n  if (!(editor !== null && editor !== void 0 && editor.selection)) {\n    return skipDefaultDelete;\n  }\n\n  if (!isSelectionAtBlockEnd(editor)) {\n    return skipDefaultDelete;\n  }\n\n  Editor.withoutNormalizing(editor, () => {\n    const res = getListItemEntry(editor, {});\n\n    if (!res) {\n      skipDefaultDelete = selectionIsNotInAListHandler(editor);\n      return;\n    }\n\n    skipDefaultDelete = selectionIsInAListHandler(editor, res);\n  });\n  return skipDefaultDelete;\n};\n\nconst deleteFragmentList = editor => {\n  let deleted = false;\n  Editor.withoutNormalizing(editor, () => {\n    // Selection should be across list items\n    if (!isAcrossListItems(editor)) return;\n    /**\r\n     * Check if the end li can be deleted (if it has no sublist).\r\n     * Store the path ref to delete it after deleteFragment.\r\n     */\n\n    const end = Editor.end(editor, editor.selection);\n    const liEnd = getAbove(editor, {\n      at: end,\n      match: {\n        type: getPluginType(editor, ELEMENT_LI)\n      }\n    });\n    const liEndCanBeDeleted = liEnd && !hasListChild(editor, liEnd[0]);\n    const liEndPathRef = liEndCanBeDeleted ? Editor.pathRef(editor, liEnd[1]) : undefined;\n    /**\r\n     * Delete fragment and move end block children to start block\r\n     */\n\n    deleteFragment(editor);\n    const start = Editor.start(editor, editor.selection);\n    const liStart = getAbove(editor, {\n      at: start,\n      match: {\n        type: getPluginType(editor, ELEMENT_LI)\n      }\n    });\n\n    if (liEndPathRef) {\n      const liEndPath = liEndPathRef.unref();\n      const listStart = liStart && getParent(editor, liStart[1]);\n      const deletePath = getHighestEmptyList(editor, {\n        liPath: liEndPath,\n        diffListPath: listStart === null || listStart === void 0 ? void 0 : listStart[1]\n      });\n\n      if (deletePath) {\n        Transforms.removeNodes(editor, {\n          at: deletePath\n        });\n      }\n\n      deleted = true;\n    }\n  });\n  return deleted;\n};\n\nconst insertBreakList = editor => {\n  if (!editor.selection) return;\n  const res = getListItemEntry(editor, {});\n  let moved; // If selection is in a li\n\n  if (res) {\n    const {\n      list,\n      listItem\n    } = res; // If selected li is empty, move it up.\n\n    if (isBlockAboveEmpty(editor)) {\n      moved = moveListItemUp(editor, {\n        list,\n        listItem\n      });\n      if (moved) return true;\n    }\n  }\n\n  const didReset = onKeyDownResetNode(editor, mockPlugin({\n    options: {\n      rules: [{\n        types: [getPluginType(editor, ELEMENT_LI)],\n        defaultType: getPluginType(editor, ELEMENT_DEFAULT),\n        predicate: () => !moved && isBlockAboveEmpty(editor),\n        onReset: _editor => unwrapList(_editor)\n      }]\n    }\n  }))(SIMULATE_BACKSPACE);\n  if (didReset) return true;\n  /**\r\n   * If selection is in li > p, insert li.\r\n   */\n\n  if (!moved) {\n    const inserted = insertListItem(editor);\n    if (inserted) return true;\n  }\n};\n\nconst insertFragmentList = editor => {\n  const {\n    insertFragment\n  } = editor;\n  const li = getPlugin(editor, ELEMENT_LI);\n  const ul = getPlugin(editor, ELEMENT_UL);\n  const ol = getPlugin(editor, ELEMENT_OL);\n\n  const isListRoot = node => [ul.type, ol.type].includes(node.type);\n\n  const getFirstAncestorOfType = (root, entry, {\n    type\n  }) => {\n    let ancestor = Path.parent(entry[1]);\n\n    while (Node.get(root, ancestor).type !== type) {\n      ancestor = Path.parent(ancestor);\n    }\n\n    return [Node.get(root, ancestor), ancestor];\n  };\n  /**\r\n   * Removes the \"empty\" leading lis. Empty in this context means lis only with other lis as children.\r\n   *\r\n   * @returns If argument is not a list root, returns it, otherwise returns ul[] or li[].\r\n   */\n\n\n  const trimList = listRoot => {\n    if (!isListRoot(listRoot)) {\n      return [listRoot];\n    }\n\n    const textEntries = Array.from(Node.texts(listRoot));\n    const commonAncestorEntry = textEntries.reduce((commonAncestor, textEntry) => Path.isAncestor(commonAncestor[1], textEntry[1]) ? commonAncestor : Node.common(listRoot, textEntry[1], commonAncestor[1]), // any list item would do, we grab the first one\n    getFirstAncestorOfType(listRoot, textEntries[0], li));\n    return isListRoot(commonAncestorEntry[0]) ? commonAncestorEntry[0].children : [commonAncestorEntry[0]];\n  };\n\n  return fragment => {\n    const liEntry = findNode(editor, {\n      match: {\n        type: li.type\n      },\n      mode: 'lowest'\n    });\n\n    if (liEntry) {\n      const [, liPath] = liEntry; // FIXME: fork insertFragment for edge cases\n\n      return Transforms.insertNodes(editor, fragment.flatMap(node => trimList(node)), {\n        at: Path.next(liPath),\n        select: true\n      });\n    }\n\n    const filtered = isListRoot(fragment[0]) ? [{\n      text: ''\n    }, ...fragment] : fragment;\n    return insertFragment(filtered);\n  };\n};\n/**\r\n * Recursively get all the:\r\n * - block children\r\n * - inline children except those at excludeDepth\r\n */\n\n\nconst getDeepInlineChildren = (editor, {\n  children\n}) => {\n  const inlineChildren = [];\n\n  for (const child of children) {\n    if (Editor.isBlock(editor, child[0])) {\n      inlineChildren.push(...getDeepInlineChildren(editor, {\n        children: getChildren(child)\n      }));\n    } else {\n      inlineChildren.push(child);\n    }\n  }\n\n  return inlineChildren;\n};\n/**\r\n * If the list item has no child: insert an empty list item container.\r\n * Else: move the children that are not valid to the list item container.\r\n */\n\n\nconst normalizeListItem = (editor, {\n  listItem,\n  validLiChildrenTypes = []\n}) => {\n  var _ref;\n\n  let changed = false;\n  const allValidLiChildrenTypes = [getPluginType(editor, ELEMENT_UL), getPluginType(editor, ELEMENT_OL), getPluginType(editor, ELEMENT_LIC), ...validLiChildrenTypes];\n  const [, liPath] = listItem;\n  const liChildren = getChildren(listItem); // Get invalid (type) li children path refs to be moved\n\n  const invalidLiChildrenPathRefs = liChildren.filter(([child]) => !allValidLiChildrenTypes.includes(child.type)).map(([, childPath]) => Editor.pathRef(editor, childPath));\n  const firstLiChild = liChildren[0];\n  const [firstLiChildNode, firstLiChildPath] = (_ref = firstLiChild) !== null && _ref !== void 0 ? _ref : []; // If li has no child or inline child, insert lic\n\n  if (!firstLiChild || !Editor.isBlock(editor, firstLiChildNode)) {\n    insertEmptyElement(editor, getPluginType(editor, ELEMENT_LIC), {\n      at: liPath.concat([0])\n    });\n    return true;\n  } // If first li child is a block but not lic, set it to lic\n\n\n  if (Editor.isBlock(editor, firstLiChildNode) && !match(firstLiChildNode, {\n    type: getPluginType(editor, ELEMENT_LIC)\n  })) {\n    if (match(firstLiChildNode, {\n      type: getListTypes(editor)\n    })) {\n      // the listItem has no lic so we move the children up a level\n      const parent = getParent(editor, listItem[1]);\n      const sublist = firstLiChild;\n      const children = getChildren(firstLiChild).reverse();\n      children.forEach(c => {\n        moveListItemUp(editor, {\n          list: sublist,\n          listItem: c\n        });\n      });\n      Transforms.removeNodes(editor, {\n        at: [...parent[1], 0]\n      });\n      return true;\n    } // Allow block elements listed as valid li children types to be a first child instead of LIC\n\n\n    if (validLiChildrenTypes.includes(firstLiChildNode.type)) {\n      return true;\n    }\n\n    setNodes(editor, {\n      type: getPluginType(editor, ELEMENT_LIC)\n    }, {\n      at: firstLiChildPath\n    });\n    changed = true;\n  }\n\n  const licChildren = getChildren(firstLiChild);\n\n  if (licChildren.length) {\n    var _licChildren;\n\n    const blockPathRefs = [];\n    const inlineChildren = []; // Check that lic has no block children\n\n    for (const licChild of licChildren) {\n      if (!Editor.isBlock(editor, licChild[0])) {\n        break;\n      }\n\n      blockPathRefs.push(Editor.pathRef(editor, licChild[1]));\n      inlineChildren.push(...getDeepInlineChildren(editor, {\n        children: getChildren(licChild)\n      }));\n    }\n\n    const to = Path.next((_licChildren = licChildren[licChildren.length - 1]) === null || _licChildren === void 0 ? void 0 : _licChildren[1]); // Move lic nested inline children to its children\n\n    inlineChildren.reverse().forEach(([, path]) => {\n      Transforms.moveNodes(editor, {\n        at: path,\n        to\n      });\n    }); // Remove lic block children\n\n    blockPathRefs.forEach(pathRef => {\n      const path = pathRef.unref();\n      path && Transforms.removeNodes(editor, {\n        at: path\n      });\n    });\n\n    if (blockPathRefs.length) {\n      changed = true;\n    }\n  }\n\n  if (changed) return true; // Ensure that any text nodes under the list are inside the list item container\n\n  invalidLiChildrenPathRefs.reverse().forEach(ref => {\n    const path = ref.unref();\n    path && Transforms.moveNodes(editor, {\n      at: path,\n      to: firstLiChildPath.concat([0])\n    });\n  });\n  return !!invalidLiChildrenPathRefs.length;\n}; // should be normalized to \"ul -> li -> lic + ul\".\n// In other words, a nested list as a direct children of a list should be moved into a previous list item sibling\n\n\nconst normalizeNestedList = (editor, {\n  nestedListItem\n}) => {\n  const [, path] = nestedListItem;\n  const parentNode = getParent(editor, path);\n  const hasParentList = parentNode && match(parentNode[0], {\n    type: getListTypes(editor)\n  });\n\n  if (!hasParentList) {\n    return false;\n  }\n\n  let previousListItemPath;\n\n  try {\n    previousListItemPath = Path.previous(path);\n  } catch (e) {\n    return false;\n  } // Previous sibling is the new parent\n\n\n  const previousSiblingItem = Editor.node(editor, previousListItemPath);\n\n  if (previousSiblingItem) {\n    const [, previousPath] = previousSiblingItem;\n    const newPath = previousPath.concat([1]); // Move the current item to the sublist\n\n    Transforms.moveNodes(editor, {\n      at: path,\n      to: newPath\n    });\n    return true;\n  }\n};\n/**\r\n * Normalize list node to force the ul>li>p+ul structure.\r\n */\n\n\nconst normalizeList = (editor, {\n  validLiChildrenTypes\n}) => {\n  const {\n    normalizeNode\n  } = editor;\n  const liType = getPluginType(editor, ELEMENT_LI);\n  const licType = getPluginType(editor, ELEMENT_LIC);\n  const defaultType = getPluginType(editor, ELEMENT_DEFAULT);\n  return ([node, path]) => {\n    if (!isElement(node)) return; // remove empty list\n\n    if (match(node, {\n      type: getListTypes(editor)\n    })) {\n      if (!node.children.length || !node.children.find(item => item.type === liType)) {\n        return Transforms.removeNodes(editor, {\n          at: path\n        });\n      }\n\n      const nextPath = Path.next(path);\n      const nextNode = getNode(editor, nextPath); // Has a list afterwards with the same type\n\n      if ((nextNode === null || nextNode === void 0 ? void 0 : nextNode.type) === node.type) {\n        moveListItemsToList(editor, {\n          fromList: [nextNode, nextPath],\n          toList: [node, path],\n          deleteFromList: true\n        });\n      }\n\n      const prevPath = getPreviousPath(path);\n      const prevNode = getNode(editor, prevPath); // Has a list before with the same type\n\n      if ((prevNode === null || prevNode === void 0 ? void 0 : prevNode.type) === node.type) {\n        editor.normalizeNode([prevNode, prevPath]); // early return since this node will no longer exists\n\n        return;\n      }\n\n      if (normalizeNestedList(editor, {\n        nestedListItem: [node, path]\n      })) {\n        return;\n      }\n    }\n\n    if (node.type === getPluginType(editor, ELEMENT_LI)) {\n      if (normalizeListItem(editor, {\n        listItem: [node, path],\n        validLiChildrenTypes\n      })) {\n        return;\n      }\n    } // LIC should have LI parent. If not, set LIC to DEFAULT type.\n\n\n    if (node.type === licType && licType !== defaultType) {\n      var _getParent;\n\n      if (((_getParent = getParent(editor, path)) === null || _getParent === void 0 ? void 0 : _getParent[0].type) !== liType) {\n        setNodes(editor, {\n          type: defaultType\n        }, {\n          at: path\n        });\n        return;\n      }\n    }\n\n    normalizeNode([node, path]);\n  };\n};\n\nconst withList = (editor, {\n  options: {\n    validLiChildrenTypes\n  }\n}) => {\n  const {\n    insertBreak,\n    deleteBackward,\n    deleteForward,\n    deleteFragment\n  } = editor;\n\n  editor.insertBreak = () => {\n    if (insertBreakList(editor)) return;\n    insertBreak();\n  };\n\n  editor.deleteBackward = unit => {\n    if (deleteBackwardList(editor, unit)) return;\n    deleteBackward(unit);\n  };\n\n  editor.deleteForward = unit => {\n    if (deleteForwardList(editor)) return;\n    deleteForward(unit);\n  };\n\n  editor.deleteFragment = () => {\n    if (deleteFragmentList(editor)) return;\n    deleteFragment();\n  };\n\n  editor.insertFragment = insertFragmentList(editor);\n  editor.normalizeNode = normalizeList(editor, {\n    validLiChildrenTypes\n  });\n  return editor;\n};\n\nconst ELEMENT_UL = 'ul';\nconst ELEMENT_OL = 'ol';\nconst ELEMENT_LI = 'li';\nconst ELEMENT_LIC = 'lic';\n/**\r\n * Enables support for bulleted, numbered and to-do lists.\r\n */\n\nconst createListPlugin = createPluginFactory({\n  key: 'list',\n  plugins: [{\n    key: ELEMENT_UL,\n    isElement: true,\n    handlers: {\n      onKeyDown: onKeyDownList\n    },\n    withOverrides: withList,\n    deserializeHtml: {\n      validNodeName: 'UL'\n    }\n  }, {\n    key: ELEMENT_OL,\n    isElement: true,\n    handlers: {\n      onKeyDown: onKeyDownList\n    },\n    deserializeHtml: {\n      validNodeName: 'OL'\n    }\n  }, {\n    key: ELEMENT_LI,\n    isElement: true,\n    deserializeHtml: {\n      validNodeName: 'LI'\n    },\n    then: (editor, {\n      type\n    }) => ({\n      inject: {\n        pluginsByKey: {\n          [KEY_DESERIALIZE_HTML]: {\n            editor: {\n              insertData: {\n                preInsert: () => {\n                  return someNode(editor, {\n                    match: {\n                      type\n                    }\n                  });\n                }\n              }\n            }\n          }\n        }\n      }\n    })\n  }, {\n    key: ELEMENT_LIC,\n    isElement: true\n  }]\n});\nconst ELEMENT_TODO_LI = 'action_item';\nconst createTodoListPlugin = createPluginFactory({\n  key: ELEMENT_TODO_LI,\n  isElement: true,\n  handlers: {\n    onKeyDown: onKeyDownToggleElement\n  },\n  options: {\n    hotkey: ['mod+opt+4', 'mod+shift+4']\n  }\n});\nexport { ELEMENT_LI, ELEMENT_LIC, ELEMENT_OL, ELEMENT_TODO_LI, ELEMENT_UL, createListPlugin, createTodoListPlugin, deleteBackwardList, deleteForwardList, deleteFragmentList, getDeepInlineChildren, getHighestEmptyList, getListItemEntry, getListRoot, getListTypes, hasListChild, indentListItems, insertBreakList, insertFragmentList, insertListItem, isAcrossListItems, isListNested, moveListItemDown, moveListItemSublistItemsToListItemSublist, moveListItemUp, moveListItems, moveListItemsToList, moveListSiblingsAfterCursor, normalizeList, normalizeListItem, normalizeNestedList, onKeyDownList, removeFirstListItem, removeListItem, toggleList, unindentListItems, unwrapList, withList };","map":{"version":3,"sources":["../../../../node_modules/lodash/isArray.js","../../../../node_modules/lodash/castArray.js","../../../../node_modules/is-hotkey/lib/index.js","../src/queries/isListNested.ts","../src/queries/getListTypes.ts","../src/queries/getHighestEmptyList.ts","../src/queries/getListItemEntry.ts","../src/queries/getListRoot.ts","../src/queries/hasListChild.ts","../src/queries/isAcrossListItems.ts","../src/transforms/moveListItemDown.ts","../src/transforms/moveListItemsToList.ts","../src/transforms/unwrapList.ts","../src/transforms/moveListItemUp.ts","../src/transforms/moveListItems.ts","../src/transforms/indentListItems.ts","../src/transforms/insertListItem.ts","../src/transforms/moveListItemSublistItemsToListItemSublist.ts","../src/transforms/moveListSiblingsAfterCursor.ts","../src/transforms/removeFirstListItem.ts","../src/transforms/removeListItem.ts","../src/transforms/toggleList.ts","../src/transforms/unindentListItems.ts","../src/onKeyDownList.ts","../src/deleteBackwardList.ts","../src/deleteForwardList.ts","../src/deleteFragmentList.ts","../src/insertBreakList.ts","../src/insertFragmentList.ts","../src/normalizers/normalizeListItem.ts","../src/normalizers/normalizeNestedList.ts","../src/normalizers/normalizeList.ts","../src/withList.ts","../src/createListPlugin.ts","../src/todo-list/createTodoListPlugin.ts"],"names":["isArray","isListNested","listParentNode","getParent","getPluginType","getListTypes","editor","getHighestEmptyList","liPath","list","getAbove","at","match","type","Path","listNode","liParent","diffListPath","getListItemEntry","selection","liType","Range","isCollapsed","_at","node","getNode","listItem","getListRoot","parentList","hasListChild","n","isAcrossListItems","isAcrossBlocks","isRangeAcrossBlocks","someNode","moveListItemDown","previousListItemPath","previousSiblingItem","Editor","sublist","newPath","previousPath","wrapNodes","children","listItemPath","Transforms","to","moveListItemsToList","toListIndex","deleteFromList","fromListItemSublist","findDescendant","fromListItem","fromListPath","fromList","toList","lastChildPath","getLastChildPath","moved","moveChildren","fromStartIndex","unwrapList","setNodes","unwrapNodes","split","moveListItemUp","move","toListPath","condA","condB","isLastChild","insertNodes","toListNode","movedUpLiPath","moveListItems","increase","getNodes","lics","highestLicPaths","highestLicPathRefs","lic","licPath","isAncestor","path","highestLiPath","licPathRefsToMove","licPathRef","listEntry","indentListItems","insertListItem","licType","licEntry","listItemEntry","listItemNode","success","isStart","isEnd","isBlockTextEmptyAfterSelection","nextParagraphPath","nextListItemPath","text","edge","marks","moveListItemSublistItemsToListItemSublist","start","toListItemSublist","fromListType","fromListNode","toListItemSublistPath","toListItemPath","fromListItemSublistPath","moveListSiblingsAfterCursor","offset","Node","removeFirstListItem","isFirstChild","removeListItem","reverse","isExpanded","previousLiPath","getPreviousPath","previousLi","tempLiPath","tempLi","tempLiPathRef","toListItem","deleteFragment","toggleList","res","mode","nodes","commonEntry","startPoint","endPoint","startList","findNode","endList","rangeLength","Math","rootPathLength","unindentListItems","options","onKeyDownList","hotkey","e","listSelected","shiftKey","hotkeys","_castArray","isHotkey","deleteBackwardList","isSelectionAtBlockStart","ELEMENT_LI","onKeyDownResetNode","mockPlugin","rules","types","defaultType","predicate","onReset","pathToEntry","selectionIsNotInAListHandler","pointAfterSelection","nextSiblingListRes","parentBlockEntity","getBlockAbove","anchor","getText","sublistRes","selectionIsInAListHandler","liWithSiblings","isNodeLi","isSiblingOfNodeLi","entry","pointAfterListItem","listRoot","siblingListItem","siblingList","nestedList","nestedListItem","getChildren","deleteForwardList","skipDefaultDelete","isSelectionAtBlockEnd","deleteFragmentList","deleted","end","liEnd","liEndCanBeDeleted","liEndPathRef","liStart","liEndPath","listStart","deletePath","insertBreakList","isBlockAboveEmpty","didReset","_editor","inserted","insertFragmentList","insertFragment","li","getPlugin","ul","ol","isListRoot","getFirstAncestorOfType","ancestor","trimList","textEntries","Array","commonAncestorEntry","commonAncestor","textEntry","fragment","liEntry","select","filtered","getDeepInlineChildren","inlineChildren","child","normalizeListItem","validLiChildrenTypes","changed","allValidLiChildrenTypes","liChildren","invalidLiChildrenPathRefs","firstLiChild","insertEmptyElement","parent","c","firstLiChildNode","firstLiChildPath","licChildren","blockPathRefs","licChild","pathRef","ref","normalizeNestedList","parentNode","hasParentList","normalizeList","normalizeNode","isElement","item","nextPath","nextNode","prevPath","prevNode","withList","insertBreak","unit","deleteBackward","deleteForward","ELEMENT_UL","ELEMENT_OL","ELEMENT_LIC","createListPlugin","createPluginFactory","key","plugins","handlers","onKeyDown","withOverrides","deserializeHtml","validNodeName","then","inject","pluginsByKey","insertData","preInsert","ELEMENT_TODO_LI","createTodoListPlugin","onKeyDownToggleElement"],"mappings":"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","sourcesContent":["/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var isArray = require('./isArray');\n\n/**\n * Casts `value` as an array if it's not one.\n *\n * @static\n * @memberOf _\n * @since 4.4.0\n * @category Lang\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast array.\n * @example\n *\n * _.castArray(1);\n * // => [1]\n *\n * _.castArray({ 'a': 1 });\n * // => [{ 'a': 1 }]\n *\n * _.castArray('abc');\n * // => ['abc']\n *\n * _.castArray(null);\n * // => [null]\n *\n * _.castArray(undefined);\n * // => [undefined]\n *\n * _.castArray();\n * // => []\n *\n * var array = [1, 2, 3];\n * console.log(_.castArray(array) === array);\n * // => true\n */\nfunction castArray() {\n  if (!arguments.length) {\n    return [];\n  }\n  var value = arguments[0];\n  return isArray(value) ? value : [value];\n}\n\nmodule.exports = castArray;\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Constants.\n */\n\nvar IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n\nvar MODIFIERS = {\n  alt: 'altKey',\n  control: 'ctrlKey',\n  meta: 'metaKey',\n  shift: 'shiftKey'\n};\n\nvar ALIASES = {\n  add: '+',\n  break: 'pause',\n  cmd: 'meta',\n  command: 'meta',\n  ctl: 'control',\n  ctrl: 'control',\n  del: 'delete',\n  down: 'arrowdown',\n  esc: 'escape',\n  ins: 'insert',\n  left: 'arrowleft',\n  mod: IS_MAC ? 'meta' : 'control',\n  opt: 'alt',\n  option: 'alt',\n  return: 'enter',\n  right: 'arrowright',\n  space: ' ',\n  spacebar: ' ',\n  up: 'arrowup',\n  win: 'meta',\n  windows: 'meta'\n};\n\nvar CODES = {\n  backspace: 8,\n  tab: 9,\n  enter: 13,\n  shift: 16,\n  control: 17,\n  alt: 18,\n  pause: 19,\n  capslock: 20,\n  escape: 27,\n  ' ': 32,\n  pageup: 33,\n  pagedown: 34,\n  end: 35,\n  home: 36,\n  arrowleft: 37,\n  arrowup: 38,\n  arrowright: 39,\n  arrowdown: 40,\n  insert: 45,\n  delete: 46,\n  meta: 91,\n  numlock: 144,\n  scrolllock: 145,\n  ';': 186,\n  '=': 187,\n  ',': 188,\n  '-': 189,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '[': 219,\n  '\\\\': 220,\n  ']': 221,\n  '\\'': 222\n};\n\nfor (var f = 1; f < 20; f++) {\n  CODES['f' + f] = 111 + f;\n}\n\n/**\n * Is hotkey?\n */\n\nfunction isHotkey(hotkey, options, event) {\n  if (options && !('byKey' in options)) {\n    event = options;\n    options = null;\n  }\n\n  if (!Array.isArray(hotkey)) {\n    hotkey = [hotkey];\n  }\n\n  var array = hotkey.map(function (string) {\n    return parseHotkey(string, options);\n  });\n  var check = function check(e) {\n    return array.some(function (object) {\n      return compareHotkey(object, e);\n    });\n  };\n  var ret = event == null ? check : check(event);\n  return ret;\n}\n\nfunction isCodeHotkey(hotkey, event) {\n  return isHotkey(hotkey, event);\n}\n\nfunction isKeyHotkey(hotkey, event) {\n  return isHotkey(hotkey, { byKey: true }, event);\n}\n\n/**\n * Parse.\n */\n\nfunction parseHotkey(hotkey, options) {\n  var byKey = options && options.byKey;\n  var ret = {};\n\n  // Special case to handle the `+` key since we use it as a separator.\n  hotkey = hotkey.replace('++', '+add');\n  var values = hotkey.split('+');\n  var length = values.length;\n\n  // Ensure that all the modifiers are set to false unless the hotkey has them.\n\n  for (var k in MODIFIERS) {\n    ret[MODIFIERS[k]] = false;\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var value = _step.value;\n\n      var optional = value.endsWith('?') && value.length > 1;\n\n      if (optional) {\n        value = value.slice(0, -1);\n      }\n\n      var name = toKeyName(value);\n      var modifier = MODIFIERS[name];\n\n      if (length === 1 || !modifier) {\n        if (byKey) {\n          ret.key = name;\n        } else {\n          ret.which = toKeyCode(value);\n        }\n      }\n\n      if (modifier) {\n        ret[modifier] = optional ? null : true;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Compare.\n */\n\nfunction compareHotkey(object, event) {\n  for (var key in object) {\n    var expected = object[key];\n    var actual = void 0;\n\n    if (expected == null) {\n      continue;\n    }\n\n    if (key === 'key' && event.key != null) {\n      actual = event.key.toLowerCase();\n    } else if (key === 'which') {\n      actual = expected === 91 && event.which === 93 ? 91 : event.which;\n    } else {\n      actual = event[key];\n    }\n\n    if (actual == null && expected === false) {\n      continue;\n    }\n\n    if (actual !== expected) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Utils.\n */\n\nfunction toKeyCode(name) {\n  name = toKeyName(name);\n  var code = CODES[name] || name.toUpperCase().charCodeAt(0);\n  return code;\n}\n\nfunction toKeyName(name) {\n  name = name.toLowerCase();\n  name = ALIASES[name] || name;\n  return name;\n}\n\n/**\n * Export.\n */\n\nexports.default = isHotkey;\nexports.isHotkey = isHotkey;\nexports.isCodeHotkey = isCodeHotkey;\nexports.isKeyHotkey = isKeyHotkey;\nexports.parseHotkey = parseHotkey;\nexports.compareHotkey = compareHotkey;\nexports.toKeyCode = toKeyCode;\nexports.toKeyName = toKeyName;","import {\n  getParent,\n  getPluginType,\n  PlateEditor,\n  TElement,\n} from '@udecode/plate-core';\nimport { Path } from 'slate';\nimport { ELEMENT_LI } from '../createListPlugin';\n\n/**\n * Is the list nested, i.e. its parent is a list item.\n */\nexport const isListNested = (editor: PlateEditor, listPath: Path) => {\n  const listParentNode = getParent<TElement>(editor, listPath)?.[0];\n\n  return listParentNode?.type === getPluginType(editor, ELEMENT_LI);\n};\n","import { getPluginType, PlateEditor } from '@udecode/plate-core';\nimport { ELEMENT_OL, ELEMENT_UL } from '../createListPlugin';\n\nexport const getListTypes = (editor: PlateEditor) => {\n  return [getPluginType(editor, ELEMENT_OL), getPluginType(editor, ELEMENT_UL)];\n};\n","import { getAbove, getPluginType, PlateEditor } from '@udecode/plate-core';\nimport { Path } from 'slate';\nimport { ELEMENT_LI } from '../createListPlugin';\nimport { getListTypes } from './getListTypes';\n\n/**\n * Find the highest end list that can be deleted.\n * Its path should be different to diffListPath.\n * If the highest end list 2+ items, return liPath.\n * Get the parent list until:\n * - the list has less than 2 items.\n * - its path is not equals to diffListPath.\n */\nexport const getHighestEmptyList = (\n  editor: PlateEditor,\n  {\n    diffListPath,\n    liPath,\n  }: {\n    liPath: Path;\n    diffListPath?: Path;\n  }\n): Path | undefined => {\n  const list = getAbove(editor, {\n    at: liPath,\n    match: { type: getListTypes(editor) },\n  });\n  if (!list) return;\n  const [listNode, listPath] = list;\n\n  if (!diffListPath || !Path.equals(listPath, diffListPath)) {\n    if (listNode.children.length < 2) {\n      const liParent = getAbove(editor, {\n        at: listPath,\n        match: { type: getPluginType(editor, ELEMENT_LI) },\n      });\n\n      if (liParent) {\n        return (\n          getHighestEmptyList(editor, { liPath: liParent[1], diffListPath }) ||\n          listPath\n        );\n      }\n    }\n    return liPath;\n  }\n};\n","import {\n  getAbove,\n  getNode,\n  getParent,\n  getPluginType,\n  isCollapsed,\n  PlateEditor,\n  TElement,\n} from '@udecode/plate-core';\nimport { Location, NodeEntry, Path, Range } from 'slate';\nimport { ELEMENT_LI } from '../createListPlugin';\n\n/**\n * Returns the nearest li and ul / ol wrapping node entries for a given path (default = selection)\n */\nexport const getListItemEntry = (\n  editor: PlateEditor,\n  { at = editor.selection }: { at?: Location | null } = {}\n): { list: NodeEntry<TElement>; listItem: NodeEntry<TElement> } | undefined => {\n  const liType = getPluginType(editor, ELEMENT_LI);\n\n  let _at: Path;\n\n  if (Range.isRange(at) && !isCollapsed(at)) {\n    _at = at.focus.path;\n  } else if (Range.isRange(at)) {\n    _at = at.anchor.path;\n  } else {\n    _at = at as Path;\n  }\n\n  if (_at) {\n    const node = getNode(editor, _at) as TElement;\n    if (node) {\n      const listItem = getAbove(editor, {\n        at: _at,\n        match: { type: liType },\n      }) as NodeEntry<TElement>;\n\n      if (listItem) {\n        const list = getParent(editor, listItem[1]) as NodeEntry<TElement>;\n\n        return { list, listItem };\n      }\n    }\n  }\n};\n","import { getAbove, getPluginType, PlateEditor } from '@udecode/plate-core';\nimport { Ancestor, NodeEntry, Path, Point, Range } from 'slate';\nimport { ELEMENT_OL, ELEMENT_UL } from '../createListPlugin';\n\n/**\n * Searches upward for the root list element\n */\nexport const getListRoot = (\n  editor: PlateEditor,\n  at: Path | Range | Point | null = editor.selection\n): NodeEntry<Ancestor> | undefined => {\n  if (!at) return;\n\n  const parentList = getAbove(editor, {\n    at,\n    match: {\n      type: [\n        getPluginType(editor, ELEMENT_UL),\n        getPluginType(editor, ELEMENT_OL),\n      ],\n    },\n  });\n\n  if (parentList) {\n    const [, parentListPath] = parentList;\n\n    return getListRoot(editor, parentListPath) ?? parentList;\n  }\n};\n","import { match, PlateEditor } from '@udecode/plate-core';\nimport { Ancestor } from 'slate';\nimport { getListTypes } from './getListTypes';\n\n/**\n * Is there a list child in the node.\n */\nexport const hasListChild = (editor: PlateEditor, node: Ancestor) =>\n  node.children.some((n) => match(n, { type: getListTypes(editor) }));\n","import {\n  getPluginType,\n  isCollapsed,\n  isRangeAcrossBlocks,\n  PlateEditor,\n  someNode,\n} from '@udecode/plate-core';\nimport { ELEMENT_LI } from '../createListPlugin';\n\n/**\n * Is selection across blocks with list items\n */\nexport const isAcrossListItems = (editor: PlateEditor) => {\n  const { selection } = editor;\n\n  if (!selection || isCollapsed(selection)) {\n    return false;\n  }\n\n  const isAcrossBlocks = isRangeAcrossBlocks(editor);\n  if (!isAcrossBlocks) return false;\n\n  return someNode(editor, {\n    match: { type: getPluginType(editor, ELEMENT_LI) },\n  });\n};\n","import { match, PlateEditor, TElement, wrapNodes } from '@udecode/plate-core';\nimport { Ancestor, Editor, Element, NodeEntry, Path, Transforms } from 'slate';\nimport { getListTypes } from '../queries';\n\nexport interface MoveListItemDownOptions {\n  list: NodeEntry<TElement>;\n  listItem: NodeEntry<TElement>;\n}\n\nexport const moveListItemDown = (\n  editor: PlateEditor,\n  { list, listItem }: MoveListItemDownOptions\n) => {\n  const [listNode] = list;\n  const [, listItemPath] = listItem;\n\n  let previousListItemPath: Path;\n\n  try {\n    previousListItemPath = Path.previous(listItemPath);\n  } catch (e) {\n    return;\n  }\n\n  // Previous sibling is the new parent\n  const previousSiblingItem = Editor.node(\n    editor,\n    previousListItemPath\n  ) as NodeEntry<Ancestor>;\n\n  if (previousSiblingItem) {\n    const [previousNode, previousPath] = previousSiblingItem;\n\n    const sublist = previousNode.children.find((n) =>\n      match(n, { type: getListTypes(editor) })\n    ) as Element | undefined;\n    const newPath = previousPath.concat(\n      sublist ? [1, sublist.children.length] : [1]\n    );\n\n    Editor.withoutNormalizing(editor, () => {\n      if (!sublist) {\n        // Create new sublist\n        wrapNodes(\n          editor,\n          { type: listNode.type, children: [] },\n          { at: listItemPath }\n        );\n      }\n\n      // Move the current item to the sublist\n      Transforms.moveNodes(editor, {\n        at: listItemPath,\n        to: newPath,\n      });\n    });\n  }\n};\n","import {\n  findDescendant,\n  getLastChildPath,\n  moveChildren,\n  MoveChildrenOptions,\n  PlateEditor,\n  TElement,\n} from '@udecode/plate-core';\nimport { Editor, NodeEntry, Path, Transforms } from 'slate';\nimport { getListTypes } from '../queries/getListTypes';\n\nexport interface MergeListItemIntoListOptions {\n  /**\n   * List items of the sublist of this node will be moved.\n   */\n  fromListItem?: NodeEntry<TElement>;\n\n  /**\n   * List items of the list will be moved.\n   */\n  fromList?: NodeEntry<TElement>;\n\n  /**\n   * List items will be moved in this list.\n   */\n  toList?: NodeEntry<TElement>;\n\n  fromStartIndex?: MoveChildrenOptions['fromStartIndex'];\n\n  /**\n   * List position where to move the list items.\n   */\n  toListIndex?: number | null;\n\n  to?: Path;\n\n  /**\n   * Delete `fromListItem` sublist if true.\n   * @default true\n   */\n  deleteFromList?: boolean;\n}\n\n/**\n * Move the list items of the sublist of `fromListItem` to `toList` (if `fromListItem` is defined).\n * Move the list items of `fromList` to `toList` (if `fromList` is defined).\n */\nexport const moveListItemsToList = (\n  editor: PlateEditor,\n  {\n    fromList,\n    fromListItem,\n    fromStartIndex,\n    to: _to,\n    toList,\n    toListIndex = null,\n    deleteFromList = true,\n  }: MergeListItemIntoListOptions\n) => {\n  let fromListPath: Path | undefined;\n  let moved;\n\n  Editor.withoutNormalizing(editor, () => {\n    if (fromListItem) {\n      const fromListItemSublist = findDescendant(editor, {\n        at: fromListItem[1],\n        match: {\n          type: getListTypes(editor),\n        },\n      });\n      if (!fromListItemSublist) return 0;\n\n      fromListPath = fromListItemSublist?.[1];\n    } else if (fromList) {\n      // eslint-disable-next-line prefer-destructuring\n      fromListPath = fromList[1];\n    } else {\n      return;\n    }\n\n    let to: Path | null = null;\n\n    if (_to) to = _to;\n    if (toList) {\n      if (toListIndex !== null) to = toList[1].concat([toListIndex]);\n      else {\n        const lastChildPath = getLastChildPath(toList);\n        to = Path.next(lastChildPath);\n      }\n    }\n    if (!to) return;\n\n    moved = moveChildren(editor, {\n      at: fromListPath,\n      to,\n      fromStartIndex,\n    });\n\n    // Remove the empty list\n    if (deleteFromList) {\n      Transforms.delete(editor, { at: fromListPath });\n    }\n  });\n\n  return moved;\n};\n","import {\n  ELEMENT_DEFAULT,\n  getAbove,\n  getPluginType,\n  PlateEditor,\n  setNodes,\n  unwrapNodes,\n} from '@udecode/plate-core';\nimport { Editor, Path } from 'slate';\nimport { ELEMENT_LI, ELEMENT_OL, ELEMENT_UL } from '../createListPlugin';\nimport { getListTypes } from '../queries';\n\nexport const unwrapList = (editor: PlateEditor, { at }: { at?: Path } = {}) => {\n  Editor.withoutNormalizing(editor, () => {\n    do {\n      setNodes(editor, {\n        type: getPluginType(editor, ELEMENT_DEFAULT),\n      });\n\n      unwrapNodes(editor, {\n        at,\n        match: { type: getPluginType(editor, ELEMENT_LI) },\n        split: true,\n      });\n\n      unwrapNodes(editor, {\n        at,\n        match: {\n          type: [\n            getPluginType(editor, ELEMENT_UL),\n            getPluginType(editor, ELEMENT_OL),\n          ],\n        },\n        split: true,\n      });\n    } while (getAbove(editor, { match: { type: getListTypes(editor), at } }));\n  });\n};\n","import {\n  getAbove,\n  getNode,\n  getPluginType,\n  insertNodes,\n  isLastChild,\n  PlateEditor,\n  TElement,\n} from '@udecode/plate-core';\nimport { Editor, NodeEntry, Path, Transforms } from 'slate';\nimport { ELEMENT_LI } from '../createListPlugin';\nimport { hasListChild } from '../queries/hasListChild';\nimport { moveListItemsToList } from './moveListItemsToList';\nimport { unwrapList } from './unwrapList';\n\nexport interface MoveListItemUpOptions {\n  list: NodeEntry<TElement>;\n  listItem: NodeEntry<TElement>;\n}\n\n/**\n * Move a list item up.\n */\nexport const moveListItemUp = (\n  editor: PlateEditor,\n  { list, listItem }: MoveListItemUpOptions\n) => {\n  const move = () => {\n    const [listNode, listPath] = list;\n    const [liNode, liPath] = listItem;\n\n    const liParent = getAbove<TElement>(editor, {\n      at: listPath,\n      match: { type: getPluginType(editor, ELEMENT_LI) },\n    });\n    if (!liParent) {\n      let toListPath;\n      try {\n        toListPath = Path.next(listPath);\n      } catch (err) {\n        return;\n      }\n\n      const condA = hasListChild(editor, liNode);\n      const condB = !isLastChild(list, liPath);\n\n      if (condA || condB) {\n        // Insert a new list next to `list`\n        insertNodes<TElement>(\n          editor,\n          {\n            type: listNode.type,\n            children: [],\n          },\n          { at: toListPath }\n        );\n      }\n\n      if (condA) {\n        const toListNode = getNode<TElement>(editor, toListPath);\n        if (!toListNode) return;\n\n        // Move li sub-lis to the new list\n        moveListItemsToList(editor, {\n          fromListItem: listItem,\n          toList: [toListNode, toListPath],\n        });\n      }\n\n      // If there is siblings li, move them to the new list\n      if (condB) {\n        const toListNode = getNode<TElement>(editor, toListPath);\n        if (!toListNode) return;\n\n        // Move next lis to the new list\n        moveListItemsToList(editor, {\n          fromList: list,\n          fromStartIndex: liPath[liPath.length - 1] + 1,\n          toList: [toListNode, toListPath],\n          deleteFromList: false,\n        });\n      }\n\n      // Finally, unwrap the list\n      unwrapList(editor, { at: liPath.concat(0) });\n\n      return true;\n    }\n    const [, liParentPath] = liParent;\n\n    const toListPath = liPath.concat([1]);\n\n    // If li has next siblings, we need to move them.\n    if (!isLastChild(list, liPath)) {\n      // If li has no sublist, insert one.\n      if (!hasListChild(editor, liNode)) {\n        insertNodes<TElement>(\n          editor,\n          {\n            type: listNode.type,\n            children: [],\n          },\n          { at: toListPath }\n        );\n      }\n\n      const toListNode = getNode<TElement>(editor, toListPath);\n      if (!toListNode) return;\n\n      // Move next siblings to li sublist.\n      moveListItemsToList(editor, {\n        fromListItem: liParent,\n        toList: [toListNode, toListPath],\n        fromStartIndex: liPath[liPath.length - 1] + 1,\n        deleteFromList: false,\n      });\n    }\n\n    const movedUpLiPath = Path.next(liParentPath);\n\n    // Move li one level up: next to the li parent.\n    Transforms.moveNodes(editor, {\n      at: liPath,\n      to: movedUpLiPath,\n    });\n\n    return true;\n  };\n\n  let moved: boolean | undefined = false;\n\n  Editor.withoutNormalizing(editor, () => {\n    moved = move();\n  });\n\n  return moved;\n};\n","import {\n  EditorNodesOptions,\n  getNodes,\n  getParent,\n  getPluginType,\n  PlateEditor,\n} from '@udecode/plate-core';\nimport { Editor, Path, PathRef } from 'slate';\nimport { ELEMENT_LIC } from '../createListPlugin';\nimport { isListNested } from '../queries/isListNested';\nimport { moveListItemDown } from './moveListItemDown';\nimport { moveListItemUp } from './moveListItemUp';\n\nexport type MoveListItemsOptions = {\n  increase?: boolean;\n  at?: EditorNodesOptions['at'];\n};\n\nexport const moveListItems = (\n  editor: PlateEditor,\n  {\n    increase = true,\n    at = editor.selection ?? undefined,\n  }: MoveListItemsOptions = {}\n) => {\n  // Get the selected lic\n  const [...lics] = getNodes(editor, {\n    at,\n    match: {\n      type: getPluginType(editor, ELEMENT_LIC),\n    },\n  });\n\n  if (!lics.length) return;\n\n  const highestLicPaths: Path[] = [];\n  const highestLicPathRefs: PathRef[] = [];\n\n  // Filter out the nested lic, we just need to move the highest ones\n  lics.forEach((lic) => {\n    const licPath = lic[1];\n    const liPath = Path.parent(licPath);\n\n    const isAncestor = highestLicPaths.some((path) => {\n      const highestLiPath = Path.parent(path);\n\n      return Path.isAncestor(highestLiPath, liPath);\n    });\n    if (!isAncestor) {\n      highestLicPaths.push(licPath);\n      highestLicPathRefs.push(Editor.pathRef(editor, licPath));\n    }\n  });\n\n  const licPathRefsToMove = increase\n    ? highestLicPathRefs\n    : highestLicPathRefs.reverse();\n\n  Editor.withoutNormalizing(editor, () => {\n    licPathRefsToMove.forEach((licPathRef) => {\n      const licPath = licPathRef.unref();\n      if (!licPath) return;\n\n      const listItem = getParent(editor, licPath);\n      if (!listItem) return;\n      const listEntry = getParent(editor, listItem[1]);\n\n      if (increase) {\n        moveListItemDown(editor, {\n          list: listEntry as any,\n          listItem: listItem as any,\n        });\n      } else if (listEntry && isListNested(editor, listEntry[1])) {\n        moveListItemUp(editor, {\n          list: listEntry as any,\n          listItem: listItem as any,\n        });\n      }\n    });\n  });\n};\n","import { PlateEditor } from '@udecode/plate-core';\nimport { moveListItems } from './moveListItems';\n\nexport const indentListItems = (editor: PlateEditor) => {\n  moveListItems(editor, { increase: true });\n};\n","import {\n  getAbove,\n  getParent,\n  getPluginType,\n  insertNodes,\n  isBlockTextEmptyAfterSelection,\n  PlateEditor,\n  TElement,\n  wrapNodes,\n} from '@udecode/plate-core';\nimport { Editor, Path, Range, Transforms } from 'slate';\nimport { ELEMENT_LI, ELEMENT_LIC } from '../createListPlugin';\n\n/**\n * Insert list item if selection in li>p.\n * TODO: test\n */\nexport const insertListItem = (editor: PlateEditor): boolean => {\n  const liType = getPluginType(editor, ELEMENT_LI);\n  const licType = getPluginType(editor, ELEMENT_LIC);\n\n  if (!editor.selection) {\n    return false;\n  }\n\n  const licEntry = getAbove(editor, { match: { type: licType } });\n  if (!licEntry) return false;\n  const [, paragraphPath] = licEntry;\n\n  const listItemEntry = getParent(editor, paragraphPath);\n  if (!listItemEntry) return false;\n  const [listItemNode, listItemPath] = listItemEntry;\n\n  if (listItemNode.type !== liType) return false;\n\n  let success = false;\n\n  Editor.withoutNormalizing(editor, () => {\n    if (!Range.isCollapsed(editor.selection!)) {\n      Transforms.delete(editor);\n    }\n\n    const isStart = Editor.isStart(\n      editor,\n      editor.selection!.focus,\n      paragraphPath\n    );\n    const isEnd = isBlockTextEmptyAfterSelection(editor);\n\n    const nextParagraphPath = Path.next(paragraphPath);\n    const nextListItemPath = Path.next(listItemPath);\n\n    /**\n     * If start, insert a list item before\n     */\n    if (isStart) {\n      insertNodes<TElement>(\n        editor,\n        {\n          type: liType,\n          children: [{ type: licType, children: [{ text: '' }] }],\n        },\n        { at: listItemPath }\n      );\n\n      success = true;\n\n      return;\n    }\n\n    /**\n     * If not end, split nodes, wrap a list item on the new paragraph and move it to the next list item\n     */\n    if (!isEnd) {\n      Editor.withoutNormalizing(editor, () => {\n        Transforms.splitNodes(editor);\n        wrapNodes(\n          editor,\n          {\n            type: liType,\n            children: [],\n          },\n          { at: nextParagraphPath }\n        );\n        Transforms.moveNodes(editor, {\n          at: nextParagraphPath,\n          to: nextListItemPath,\n        });\n        Transforms.select(editor, nextListItemPath);\n        Transforms.collapse(editor, {\n          edge: 'start',\n        });\n      });\n    } else {\n      /**\n       * If end, insert a list item after and select it\n       */\n      const marks = Editor.marks(editor) || {};\n      insertNodes<TElement>(\n        editor,\n        {\n          type: liType,\n          children: [{ type: licType, children: [{ text: '', ...marks }] }],\n        },\n        { at: nextListItemPath }\n      );\n      Transforms.select(editor, nextListItemPath);\n    }\n\n    /**\n     * If there is a list in the list item, move it to the next list item\n     */\n    if (listItemNode.children.length > 1) {\n      Transforms.moveNodes(editor, {\n        at: nextParagraphPath,\n        to: nextListItemPath.concat(1),\n      });\n    }\n\n    success = true;\n  });\n\n  return success;\n};\n","import {\n  findDescendant,\n  getLastChildPath,\n  getParent,\n  insertNodes,\n  moveChildren,\n  PlateEditor,\n  TElement,\n} from '@udecode/plate-core';\nimport { Editor, NodeEntry, Path, Transforms } from 'slate';\nimport { getListTypes } from '../queries/getListTypes';\n\nexport interface MoveListItemSublistItemsToListItemSublistOptions {\n  /**\n   * The list item to merge.\n   */\n  fromListItem: NodeEntry<TElement>;\n\n  /**\n   * The list item where to merge.\n   */\n  toListItem: NodeEntry<TElement>;\n\n  /**\n   * Move to the start of the list instead of the end.\n   */\n  start?: boolean;\n}\n\n/**\n * Move fromListItem sublist list items to the end of `toListItem` sublist.\n * If there is no `toListItem` sublist, insert one.\n */\nexport const moveListItemSublistItemsToListItemSublist = (\n  editor: PlateEditor,\n  {\n    fromListItem,\n    toListItem,\n    start,\n  }: MoveListItemSublistItemsToListItemSublistOptions\n) => {\n  const [, fromListItemPath] = fromListItem;\n  const [, toListItemPath] = toListItem;\n  let moved = 0;\n\n  Editor.withoutNormalizing(editor, () => {\n    const fromListItemSublist = findDescendant<TElement>(editor, {\n      at: fromListItemPath,\n      match: {\n        type: getListTypes(editor),\n      },\n    });\n    if (!fromListItemSublist) return 0;\n\n    const [, fromListItemSublistPath] = fromListItemSublist;\n\n    const toListItemSublist = findDescendant<TElement>(editor, {\n      at: toListItemPath,\n      match: {\n        type: getListTypes(editor),\n      },\n    });\n\n    let to: Path;\n\n    if (!toListItemSublist) {\n      const fromList = getParent(editor, fromListItemPath);\n      if (!fromList) return 0;\n      const [fromListNode] = fromList;\n\n      const fromListType = fromListNode.type;\n\n      const toListItemSublistPath = toListItemPath.concat([1]);\n\n      insertNodes<TElement>(\n        editor,\n        { type: fromListType, children: [] },\n        { at: toListItemSublistPath }\n      );\n\n      to = toListItemSublistPath.concat([0]);\n    } else if (start) {\n      const [, toListItemSublistPath] = toListItemSublist;\n      to = toListItemSublistPath.concat([0]);\n    } else {\n      to = Path.next(getLastChildPath(toListItemSublist));\n    }\n\n    moved = moveChildren(editor, {\n      at: fromListItemSublistPath,\n      to,\n    });\n\n    // Remove the empty list\n    Transforms.delete(editor, { at: fromListItemSublistPath });\n  });\n\n  return moved;\n};\n","import { match, moveChildren, PlateEditor } from '@udecode/plate-core';\nimport { Node, NodeEntry, Path } from 'slate';\nimport { getListTypes } from '../queries/getListTypes';\n\nexport const moveListSiblingsAfterCursor = (\n  editor: PlateEditor,\n  {\n    at,\n    to,\n  }: {\n    at: Path;\n    to: Path;\n  }\n): number => {\n  const offset = at[at.length - 1];\n  at = Path.parent(at);\n  const listNode = Node.get(editor, at);\n  const listEntry: NodeEntry = [listNode, at];\n\n  if (\n    !match(listNode, { type: getListTypes(editor) }) ||\n    Path.isParent(at, to) // avoid moving nodes within its own list\n  ) {\n    return 0;\n  }\n\n  return moveChildren(editor, {\n    at: listEntry,\n    to,\n    fromStartIndex: offset + 1,\n  });\n};\n","import { isFirstChild, PlateEditor, TElement } from '@udecode/plate-core';\nimport { NodeEntry } from 'slate';\nimport { isListNested } from '../queries/isListNested';\nimport { moveListItemUp } from './moveListItemUp';\n\n/**\n * If list is not nested and if li is not the first child, move li up.\n */\nexport const removeFirstListItem = (\n  editor: PlateEditor,\n  {\n    list,\n    listItem,\n  }: {\n    list: NodeEntry<TElement>;\n    listItem: NodeEntry<TElement>;\n  }\n) => {\n  const [, listPath] = list;\n  const [, listItemPath] = listItem;\n\n  if (!isListNested(editor, listPath) && !isFirstChild(listItemPath)) {\n    moveListItemUp(editor, { list, listItem });\n\n    return true;\n  }\n\n  return false;\n};\n","import {\n  deleteFragment,\n  getPluginType,\n  getPreviousPath,\n  insertNodes,\n  isExpanded,\n  PlateEditor,\n  TElement,\n} from '@udecode/plate-core';\nimport { Editor, NodeEntry, Path, Transforms } from 'slate';\nimport { ELEMENT_LI, ELEMENT_LIC } from '../createListPlugin';\nimport { hasListChild } from '../queries/hasListChild';\nimport { moveListItemsToList } from './moveListItemsToList';\nimport { moveListItemSublistItemsToListItemSublist } from './moveListItemSublistItemsToListItemSublist';\n\nexport interface RemoveListItemOptions {\n  list: NodeEntry<TElement>;\n  listItem: NodeEntry<TElement>;\n  reverse?: boolean;\n}\n\n/**\n * Remove list item and move its sublist to list if any.\n */\nexport const removeListItem = (\n  editor: PlateEditor,\n  { list, listItem, reverse = true }: RemoveListItemOptions\n) => {\n  const [liNode, liPath] = listItem;\n\n  // Stop if the list item has no sublist\n  if (isExpanded(editor.selection) || !hasListChild(editor, liNode)) {\n    return false;\n  }\n\n  const previousLiPath = getPreviousPath(liPath);\n\n  let success = false;\n\n  Editor.withoutNormalizing(editor, () => {\n    /**\n     * If there is a previous li, we need to move sub-lis to the previous li.\n     * As we need to delete first, we will:\n     * 1. insert a temporary li: tempLi\n     * 2. move sub-lis to tempLi\n     * 3. delete\n     * 4. move sub-lis from tempLi to the previous li.\n     * 5. remove tempLi\n     */\n    if (previousLiPath) {\n      const previousLi = Editor.node(\n        editor,\n        previousLiPath\n      ) as NodeEntry<TElement>;\n\n      // 1\n      let tempLiPath = Path.next(liPath);\n      insertNodes<TElement>(\n        editor,\n        {\n          type: getPluginType(editor, ELEMENT_LI),\n          children: [\n            {\n              type: getPluginType(editor, ELEMENT_LIC),\n              children: [{ text: '' }],\n            },\n          ],\n        },\n        { at: tempLiPath }\n      );\n\n      const tempLi = Editor.node(editor, tempLiPath) as NodeEntry<TElement>;\n      const tempLiPathRef = Editor.pathRef(editor, tempLi[1]);\n\n      // 2\n      moveListItemSublistItemsToListItemSublist(editor, {\n        fromListItem: listItem,\n        toListItem: tempLi,\n      });\n\n      // 3\n      deleteFragment(editor, {\n        reverse,\n      });\n\n      tempLiPath = tempLiPathRef.unref()!;\n\n      // 4\n      moveListItemSublistItemsToListItemSublist(editor, {\n        fromListItem: [tempLi[0], tempLiPath],\n        toListItem: previousLi,\n      });\n\n      // 5\n      Transforms.removeNodes(editor, { at: tempLiPath });\n\n      success = true;\n      return;\n    }\n\n    // If it's the first li, move the sublist to the parent list\n    moveListItemsToList(editor, {\n      fromListItem: listItem,\n      toList: list,\n      toListIndex: 1,\n    });\n  });\n\n  return success;\n};\n","import {\n  ELEMENT_DEFAULT,\n  findNode,\n  getNodes,\n  getPluginType,\n  isCollapsed,\n  isRangeAcrossBlocks,\n  PlateEditor,\n  setNodes,\n  TElement,\n  wrapNodes,\n} from '@udecode/plate-core';\nimport { Editor, Node, NodeEntry, Range } from 'slate';\nimport { ELEMENT_LI, ELEMENT_LIC } from '../createListPlugin';\nimport { getListItemEntry, getListTypes } from '../queries';\nimport { unwrapList } from './unwrapList';\n\nexport const toggleList = (editor: PlateEditor, { type }: { type: string }) =>\n  Editor.withoutNormalizing(editor, () => {\n    if (!editor.selection) {\n      return;\n    }\n\n    if (isCollapsed(editor.selection) || !isRangeAcrossBlocks(editor)) {\n      // selection is collapsed\n      const res = getListItemEntry(editor);\n\n      if (res) {\n        const { list } = res;\n        if (list[0].type !== type) {\n          setNodes(\n            editor,\n            { type },\n            {\n              at: editor.selection,\n              match: (n) => getListTypes(editor).includes(n.type),\n              mode: 'lowest',\n            }\n          );\n        } else {\n          unwrapList(editor);\n        }\n      } else {\n        const list = { type, children: [] };\n        wrapNodes(editor, list);\n\n        const nodes = [\n          ...getNodes(editor, {\n            match: { type: getPluginType(editor, ELEMENT_DEFAULT) },\n          }),\n        ];\n        setNodes(editor, { type: getPluginType(editor, ELEMENT_LIC) });\n\n        const listItem = {\n          type: getPluginType(editor, ELEMENT_LI),\n          children: [],\n        };\n\n        for (const [, path] of nodes) {\n          wrapNodes(editor, listItem, {\n            at: path,\n          });\n        }\n      }\n    } else {\n      // selection is a range\n\n      const [startPoint, endPoint] = Range.edges(editor.selection!);\n      const commonEntry = Node.common(editor, startPoint.path, endPoint.path);\n\n      if (\n        getListTypes(editor).includes((commonEntry[0] as TElement).type) ||\n        (commonEntry[0] as TElement).type === getPluginType(editor, ELEMENT_LI)\n      ) {\n        if ((commonEntry[0] as TElement).type !== type) {\n          const startList = findNode(editor, {\n            at: Range.start(editor.selection),\n            match: { type: getListTypes(editor) },\n            mode: 'lowest',\n          });\n          const endList = findNode(editor, {\n            at: Range.end(editor.selection),\n            match: { type: getListTypes(editor) },\n            mode: 'lowest',\n          });\n          const rangeLength = Math.min(\n            startList![1].length,\n            endList![1].length\n          );\n          setNodes(\n            editor,\n            { type },\n            {\n              at: editor.selection,\n              match: (n, path) =>\n                getListTypes(editor).includes(n.type) &&\n                path.length >= rangeLength,\n              mode: 'all',\n            }\n          );\n        } else {\n          unwrapList(editor);\n        }\n      } else {\n        const rootPathLength = commonEntry[1].length;\n        const nodes = (Array.from(\n          getNodes(editor, {\n            mode: 'all',\n          })\n        ) as NodeEntry<TElement>[])\n          .filter(([, path]) => path.length === rootPathLength + 1)\n          .reverse();\n\n        nodes.forEach((n) => {\n          if (getListTypes(editor).includes(n[0].type)) {\n            setNodes(editor, { type }, { at: n[1] });\n          } else {\n            setNodes(\n              editor,\n              { type: getPluginType(editor, ELEMENT_LIC) },\n              { at: n[1] }\n            );\n\n            const listItem = {\n              type: getPluginType(editor, ELEMENT_LI),\n              children: [],\n            };\n            wrapNodes(editor, listItem, {\n              at: n[1],\n            });\n\n            const list = { type, children: [] };\n            wrapNodes(editor, list, { at: n[1] });\n          }\n        });\n      }\n    }\n  });\n","import { PlateEditor } from '@udecode/plate-core';\nimport { moveListItems, MoveListItemsOptions } from './moveListItems';\n\nexport type UnindentListItemsOptions = Omit<MoveListItemsOptions, 'increase'>;\n\nexport const unindentListItems = (\n  editor: PlateEditor,\n  options: UnindentListItemsOptions = {}\n): void => moveListItems(editor, { ...options, increase: false });\n","import { getAbove, HotkeyPlugin, KeyboardHandler } from '@udecode/plate-core';\nimport isHotkey from 'is-hotkey';\nimport { castArray } from 'lodash';\nimport { moveListItems, toggleList } from './transforms';\n\nexport const onKeyDownList: KeyboardHandler<{}, HotkeyPlugin> = (\n  editor,\n  { type, options: { hotkey } }\n) => (e) => {\n  if (e.key === 'Tab' && editor.selection) {\n    const listSelected = getAbove(editor, {\n      at: editor.selection,\n      match: { type },\n    });\n\n    if (listSelected) {\n      e.preventDefault();\n      moveListItems(editor, { increase: !e.shiftKey });\n      return;\n    }\n  }\n\n  if (!hotkey) return;\n\n  const hotkeys = castArray(hotkey);\n\n  for (const _hotkey of hotkeys) {\n    if (isHotkey(_hotkey)(e as any)) {\n      toggleList(editor, { type: type! });\n    }\n  }\n};\n","import {\n  deleteFragment,\n  ELEMENT_DEFAULT,\n  getPluginType,\n  isFirstChild,\n  isSelectionAtBlockStart,\n  mockPlugin,\n  PlateEditor,\n} from '@udecode/plate-core';\nimport {\n  onKeyDownResetNode,\n  ResetNodePlugin,\n  SIMULATE_BACKSPACE,\n} from '@udecode/plate-reset-node';\nimport { Editor } from 'slate';\nimport { getListItemEntry } from './queries/getListItemEntry';\nimport { isListNested } from './queries/isListNested';\nimport { removeFirstListItem } from './transforms/removeFirstListItem';\nimport { removeListItem } from './transforms/removeListItem';\nimport { unwrapList } from './transforms/unwrapList';\nimport { ELEMENT_LI } from './createListPlugin';\n\nexport const deleteBackwardList = (\n  editor: PlateEditor,\n  unit: 'character' | 'word' | 'line' | 'block'\n) => {\n  const res = getListItemEntry(editor, {});\n\n  let moved: boolean | undefined = false;\n\n  if (res) {\n    const { list, listItem } = res;\n\n    if (\n      isSelectionAtBlockStart(editor, {\n        match: (node) => node.type === ELEMENT_LI,\n      })\n    ) {\n      Editor.withoutNormalizing(editor, () => {\n        moved = removeFirstListItem(editor, { list, listItem });\n        if (moved) return true;\n\n        moved = removeListItem(editor, { list, listItem });\n        if (moved) return true;\n\n        if (isFirstChild(listItem[1]) && !isListNested(editor, list[1])) {\n          onKeyDownResetNode(\n            editor,\n            mockPlugin<ResetNodePlugin>({\n              options: {\n                rules: [\n                  {\n                    types: [getPluginType(editor, ELEMENT_LI)],\n                    defaultType: getPluginType(editor, ELEMENT_DEFAULT),\n                    hotkey: 'backspace',\n                    predicate: () => isSelectionAtBlockStart(editor),\n                    onReset: (e) => unwrapList(e),\n                  },\n                ],\n              },\n            })\n          )(SIMULATE_BACKSPACE);\n          moved = true;\n          return;\n        }\n\n        deleteFragment(editor, {\n          unit,\n          reverse: true,\n        });\n        moved = true;\n      });\n    }\n  }\n\n  return moved;\n};\n","import {\n  getBlockAbove,\n  getChildren,\n  getNode,\n  getPluginType,\n  getText,\n  isSelectionAtBlockEnd,\n  PlateEditor,\n  TDescendant,\n  TElement,\n} from '@udecode/plate-core';\nimport { Editor, Node, NodeEntry, Path, Transforms } from 'slate';\nimport { ELEMENT_LI } from './createListPlugin';\nimport { getListItemEntry, getListRoot, hasListChild } from './queries';\nimport {\n  moveListItemsToList,\n  moveListItemUp,\n  removeFirstListItem,\n  removeListItem,\n} from './transforms';\n\nconst pathToEntry = <T extends Node>(\n  editor: PlateEditor,\n  path: Path\n): NodeEntry<T> => Editor.node(editor, path) as NodeEntry<T>;\n\nconst selectionIsNotInAListHandler = (editor: PlateEditor): boolean => {\n  const pointAfterSelection = Editor.after(\n    editor,\n    editor.selection!.focus.path\n  );\n\n  if (pointAfterSelection) {\n    // there is a block after it\n    const nextSiblingListRes = getListItemEntry(editor, {\n      at: pointAfterSelection,\n    });\n\n    if (nextSiblingListRes) {\n      // the next block is a list\n      const { listItem } = nextSiblingListRes;\n      const parentBlockEntity = getBlockAbove(editor, {\n        at: editor.selection!.anchor,\n      });\n\n      if (!getText(editor, parentBlockEntity![1])) {\n        // the selected block is empty\n        Transforms.removeNodes(editor);\n\n        return true;\n      }\n\n      if (hasListChild(editor, listItem[0])) {\n        // the next block has children, so we have to move the first item up\n        const sublistRes = getListItemEntry(editor, {\n          at: [...listItem[1], 1, 0, 0],\n        });\n\n        moveListItemUp(editor, sublistRes!);\n      }\n    }\n  }\n\n  return false;\n};\n\nconst selectionIsInAListHandler = (\n  editor: PlateEditor,\n  res: { list: NodeEntry<TElement>; listItem: NodeEntry<TElement> }\n): boolean => {\n  const { listItem } = res;\n\n  // if it has no children\n  if (!hasListChild(editor, listItem[0])) {\n    const liType = getPluginType(editor, ELEMENT_LI);\n    const liWithSiblings = Array.from(\n      Editor.nodes(editor, {\n        at: listItem[1],\n        mode: 'lowest',\n        match: (node: TDescendant, path) => {\n          if (path.length === 0) {\n            return false;\n          }\n\n          const isNodeLi = node.type === liType;\n          const isSiblingOfNodeLi =\n            (getNode(editor, Path.next(path)) as TDescendant)?.type === liType;\n\n          return isNodeLi && isSiblingOfNodeLi;\n        },\n      }),\n      (entry) => entry[1]\n    )[0];\n\n    if (!liWithSiblings) {\n      // there are no more list item in the list\n      const pointAfterListItem = Editor.after(editor, listItem[1]);\n\n      if (pointAfterListItem) {\n        // there is a block after it\n        const nextSiblingListRes = getListItemEntry(editor, {\n          at: pointAfterListItem,\n        });\n\n        if (nextSiblingListRes) {\n          // it is a list so we merge the lists\n          const listRoot = getListRoot(\n            editor,\n            listItem[1]\n          ) as NodeEntry<TElement>;\n\n          moveListItemsToList(editor, {\n            fromList: nextSiblingListRes.list,\n            toList: listRoot,\n            deleteFromList: true,\n          });\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    const siblingListItem: NodeEntry<TDescendant> = pathToEntry(\n      editor,\n      Path.next(liWithSiblings)\n    );\n\n    const siblingList: NodeEntry<TDescendant> = Editor.parent(\n      editor,\n      siblingListItem[1]\n    );\n\n    if (\n      removeListItem(editor, {\n        list: siblingList,\n        listItem: siblingListItem,\n        reverse: false,\n      })\n    ) {\n      return true;\n    }\n\n    // if (skipDefaultDelete) return skipDefaultDelete;\n\n    return false;\n  }\n\n  // if it has children\n  const nestedList = pathToEntry<TDescendant>(\n    editor,\n    Path.next([...listItem[1], 0])\n  );\n  const nestedListItem = getChildren<TDescendant>(nestedList)[0];\n\n  if (\n    removeFirstListItem(editor, {\n      list: nestedList,\n      listItem: nestedListItem,\n    })\n  ) {\n    return true;\n  }\n\n  if (\n    removeListItem(editor, {\n      list: nestedList,\n      listItem: nestedListItem,\n    })\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const deleteForwardList = (editor: PlateEditor) => {\n  let skipDefaultDelete = false;\n\n  if (!editor?.selection) {\n    return skipDefaultDelete;\n  }\n\n  if (!isSelectionAtBlockEnd(editor)) {\n    return skipDefaultDelete;\n  }\n\n  Editor.withoutNormalizing(editor, () => {\n    const res = getListItemEntry(editor, {});\n\n    if (!res) {\n      skipDefaultDelete = selectionIsNotInAListHandler(editor);\n      return;\n    }\n\n    skipDefaultDelete = selectionIsInAListHandler(editor, res);\n  });\n\n  return skipDefaultDelete;\n};\n","import {\n  deleteFragment,\n  getAbove,\n  getParent,\n  getPluginType,\n  PlateEditor,\n} from '@udecode/plate-core';\nimport { Editor, Range, Transforms } from 'slate';\nimport { getHighestEmptyList } from './queries/getHighestEmptyList';\nimport { hasListChild } from './queries/hasListChild';\nimport { isAcrossListItems } from './queries/isAcrossListItems';\nimport { ELEMENT_LI } from './createListPlugin';\n\nexport const deleteFragmentList = (editor: PlateEditor) => {\n  let deleted = false;\n\n  Editor.withoutNormalizing(editor, () => {\n    // Selection should be across list items\n    if (!isAcrossListItems(editor)) return;\n\n    /**\n     * Check if the end li can be deleted (if it has no sublist).\n     * Store the path ref to delete it after deleteFragment.\n     */\n    const end = Editor.end(editor, editor.selection as Range);\n    const liEnd = getAbove(editor, {\n      at: end,\n      match: { type: getPluginType(editor, ELEMENT_LI) },\n    });\n    const liEndCanBeDeleted = liEnd && !hasListChild(editor, liEnd[0]);\n    const liEndPathRef = liEndCanBeDeleted\n      ? Editor.pathRef(editor, liEnd![1])\n      : undefined;\n\n    /**\n     * Delete fragment and move end block children to start block\n     */\n    deleteFragment(editor);\n\n    const start = Editor.start(editor, editor.selection as Range);\n    const liStart = getAbove(editor, {\n      at: start,\n      match: { type: getPluginType(editor, ELEMENT_LI) },\n    });\n\n    if (liEndPathRef) {\n      const liEndPath = liEndPathRef.unref()!;\n\n      const listStart = liStart && getParent(editor, liStart[1]);\n\n      const deletePath = getHighestEmptyList(editor, {\n        liPath: liEndPath,\n        diffListPath: listStart?.[1],\n      });\n\n      if (deletePath) {\n        Transforms.removeNodes(editor, { at: deletePath });\n      }\n\n      deleted = true;\n    }\n  });\n\n  return deleted;\n};\n","import {\n  ELEMENT_DEFAULT,\n  getPluginType,\n  isBlockAboveEmpty,\n  mockPlugin,\n  PlateEditor,\n} from '@udecode/plate-core';\nimport {\n  onKeyDownResetNode,\n  ResetNodePlugin,\n  SIMULATE_BACKSPACE,\n} from '@udecode/plate-reset-node';\nimport { getListItemEntry } from './queries/getListItemEntry';\nimport { insertListItem } from './transforms/insertListItem';\nimport { moveListItemUp } from './transforms/moveListItemUp';\nimport { unwrapList } from './transforms/unwrapList';\nimport { ELEMENT_LI } from './createListPlugin';\n\nexport const insertBreakList = (editor: PlateEditor) => {\n  if (!editor.selection) return;\n\n  const res = getListItemEntry(editor, {});\n  let moved: boolean | undefined;\n\n  // If selection is in a li\n  if (res) {\n    const { list, listItem } = res;\n\n    // If selected li is empty, move it up.\n    if (isBlockAboveEmpty(editor)) {\n      moved = moveListItemUp(editor, {\n        list,\n        listItem,\n      });\n\n      if (moved) return true;\n    }\n  }\n\n  const didReset = onKeyDownResetNode(\n    editor,\n    mockPlugin<ResetNodePlugin>({\n      options: {\n        rules: [\n          {\n            types: [getPluginType(editor, ELEMENT_LI)],\n            defaultType: getPluginType(editor, ELEMENT_DEFAULT),\n            predicate: () => !moved && isBlockAboveEmpty(editor),\n            onReset: (_editor) => unwrapList(_editor as PlateEditor),\n          },\n        ],\n      },\n    })\n  )(SIMULATE_BACKSPACE as any);\n  if (didReset) return true;\n\n  /**\n   * If selection is in li > p, insert li.\n   */\n  if (!moved) {\n    const inserted = insertListItem(editor);\n    if (inserted) return true;\n  }\n};\n","import {\n  findNode,\n  getPlugin,\n  PlateEditor,\n  PlatePlugin,\n  TDescendant,\n} from '@udecode/plate-core';\nimport { Node, NodeEntry, Path, Transforms } from 'slate';\nimport { ELEMENT_LI, ELEMENT_OL, ELEMENT_UL } from './createListPlugin';\n\nexport const insertFragmentList = (editor: PlateEditor) => {\n  const { insertFragment } = editor;\n\n  const li = getPlugin(editor, ELEMENT_LI);\n  const ul = getPlugin(editor, ELEMENT_UL);\n  const ol = getPlugin(editor, ELEMENT_OL);\n\n  const isListRoot = (node: TDescendant): boolean =>\n    [ul.type, ol.type].includes(node.type);\n\n  const getFirstAncestorOfType = (\n    root: TDescendant,\n    entry: NodeEntry,\n    { type }: PlatePlugin\n  ): NodeEntry<TDescendant> => {\n    let ancestor: Path = Path.parent(entry[1]);\n    while ((Node.get(root, ancestor) as TDescendant).type !== type) {\n      ancestor = Path.parent(ancestor);\n    }\n\n    return [Node.get(root, ancestor), ancestor];\n  };\n\n  /**\n   * Removes the \"empty\" leading lis. Empty in this context means lis only with other lis as children.\n   *\n   * @returns If argument is not a list root, returns it, otherwise returns ul[] or li[].\n   */\n  const trimList = <T extends TDescendant>(listRoot: T): T[] => {\n    if (!isListRoot(listRoot)) {\n      return [listRoot];\n    }\n\n    const textEntries = Array.from(Node.texts(listRoot));\n\n    const commonAncestorEntry = textEntries.reduce<NodeEntry<TDescendant>>(\n      (commonAncestor, textEntry) =>\n        Path.isAncestor(commonAncestor[1], textEntry[1])\n          ? commonAncestor\n          : Node.common(listRoot, textEntry[1], commonAncestor[1]),\n      // any list item would do, we grab the first one\n      getFirstAncestorOfType(listRoot, textEntries[0], li)\n    );\n\n    return isListRoot(commonAncestorEntry[0])\n      ? commonAncestorEntry[0].children\n      : [commonAncestorEntry[0]];\n  };\n\n  return (fragment: TDescendant[]) => {\n    const liEntry = findNode(editor, {\n      match: { type: li.type },\n      mode: 'lowest',\n    });\n\n    if (liEntry) {\n      const [, liPath] = liEntry;\n\n      // FIXME: fork insertFragment for edge cases\n      return Transforms.insertNodes(\n        editor,\n        fragment.flatMap((node) => trimList(node)),\n        { at: Path.next(liPath), select: true }\n      );\n    }\n\n    const filtered: TDescendant[] = isListRoot(fragment[0])\n      ? [{ text: '' }, ...fragment]\n      : fragment;\n\n    return insertFragment(filtered);\n  };\n};\n","import {\n  getChildren,\n  getParent,\n  getPluginType,\n  insertEmptyElement,\n  match,\n  PlateEditor,\n  setNodes,\n  TDescendant,\n  TElement,\n} from '@udecode/plate-core';\nimport { Editor, NodeEntry, Path, PathRef, Transforms } from 'slate';\nimport { ELEMENT_LIC, ELEMENT_OL, ELEMENT_UL } from '../createListPlugin';\nimport { getListTypes } from '../queries';\nimport { moveListItemUp } from '../transforms';\nimport { ListPlugin } from '../types';\n\n/**\n * Recursively get all the:\n * - block children\n * - inline children except those at excludeDepth\n */\nexport const getDeepInlineChildren = (\n  editor: PlateEditor,\n  {\n    children,\n  }: {\n    children: NodeEntry<TDescendant>[];\n  }\n) => {\n  const inlineChildren: NodeEntry<TDescendant>[] = [];\n\n  for (const child of children) {\n    if (Editor.isBlock(editor, child[0])) {\n      inlineChildren.push(\n        ...getDeepInlineChildren(editor, {\n          children: getChildren(child),\n        })\n      );\n    } else {\n      inlineChildren.push(child);\n    }\n  }\n\n  return inlineChildren;\n};\n\n/**\n * If the list item has no child: insert an empty list item container.\n * Else: move the children that are not valid to the list item container.\n */\nexport const normalizeListItem = (\n  editor: PlateEditor,\n  {\n    listItem,\n    validLiChildrenTypes = [],\n  }: { listItem: NodeEntry<TElement> } & ListPlugin\n) => {\n  let changed = false;\n\n  const allValidLiChildrenTypes = [\n    getPluginType(editor, ELEMENT_UL),\n    getPluginType(editor, ELEMENT_OL),\n    getPluginType(editor, ELEMENT_LIC),\n    ...validLiChildrenTypes,\n  ];\n\n  const [, liPath] = listItem;\n  const liChildren = getChildren(listItem);\n\n  // Get invalid (type) li children path refs to be moved\n  const invalidLiChildrenPathRefs = liChildren\n    .filter(([child]) => !allValidLiChildrenTypes.includes(child.type))\n    .map(([, childPath]) => Editor.pathRef(editor, childPath));\n\n  const firstLiChild: NodeEntry<any> | undefined = liChildren[0];\n  const [firstLiChildNode, firstLiChildPath] =\n    (firstLiChild as NodeEntry<TElement>) ?? [];\n\n  // If li has no child or inline child, insert lic\n  if (!firstLiChild || !Editor.isBlock(editor, firstLiChildNode)) {\n    insertEmptyElement(editor, getPluginType(editor, ELEMENT_LIC), {\n      at: liPath.concat([0]),\n    });\n    return true;\n  }\n\n  // If first li child is a block but not lic, set it to lic\n  if (\n    Editor.isBlock(editor, firstLiChildNode) &&\n    !match(firstLiChildNode as any, {\n      type: getPluginType(editor, ELEMENT_LIC),\n    })\n  ) {\n    if (\n      match(firstLiChildNode as any, {\n        type: getListTypes(editor),\n      })\n    ) {\n      // the listItem has no lic so we move the children up a level\n      const parent = getParent(editor, listItem[1]);\n      const sublist = firstLiChild;\n      const children = getChildren(firstLiChild).reverse();\n      children.forEach((c) => {\n        moveListItemUp(editor, { list: sublist, listItem: c });\n      });\n\n      Transforms.removeNodes(editor, { at: [...parent![1], 0] });\n\n      return true;\n    }\n\n    // Allow block elements listed as valid li children types to be a first child instead of LIC\n    if (validLiChildrenTypes.includes(firstLiChildNode.type)) {\n      return true;\n    }\n\n    setNodes<TElement>(\n      editor,\n      {\n        type: getPluginType(editor, ELEMENT_LIC),\n      },\n      {\n        at: firstLiChildPath,\n      }\n    );\n\n    changed = true;\n  }\n\n  const licChildren = getChildren(firstLiChild);\n\n  if (licChildren.length) {\n    const blockPathRefs: PathRef[] = [];\n    const inlineChildren: NodeEntry[] = [];\n\n    // Check that lic has no block children\n    for (const licChild of licChildren) {\n      if (!Editor.isBlock(editor, licChild[0])) {\n        break;\n      }\n\n      blockPathRefs.push(Editor.pathRef(editor, licChild[1]));\n\n      inlineChildren.push(\n        ...getDeepInlineChildren(editor, {\n          children: getChildren(licChild),\n        })\n      );\n    }\n\n    const to = Path.next(licChildren[licChildren.length - 1]?.[1]);\n\n    // Move lic nested inline children to its children\n    inlineChildren.reverse().forEach(([, path]) => {\n      Transforms.moveNodes(editor, {\n        at: path,\n        to,\n      });\n    });\n\n    // Remove lic block children\n    blockPathRefs.forEach((pathRef) => {\n      const path = pathRef.unref();\n\n      path &&\n        Transforms.removeNodes(editor, {\n          at: path,\n        });\n    });\n\n    if (blockPathRefs.length) {\n      changed = true;\n    }\n  }\n\n  if (changed) return true;\n\n  // Ensure that any text nodes under the list are inside the list item container\n  invalidLiChildrenPathRefs.reverse().forEach((ref) => {\n    const path = ref.unref();\n\n    path &&\n      Transforms.moveNodes(editor, {\n        at: path,\n        to: firstLiChildPath.concat([0]),\n      });\n  });\n\n  return !!invalidLiChildrenPathRefs.length;\n};\n","import { getParent, match, PlateEditor, TElement } from '@udecode/plate-core';\nimport { Ancestor, Editor, NodeEntry, Path, Transforms } from 'slate';\nimport { getListTypes } from '../queries';\n\n// When pasting from e.g. Google Docs, the structure of nested lists like \"ul -> ul\"\n// should be normalized to \"ul -> li -> lic + ul\".\n// In other words, a nested list as a direct children of a list should be moved into a previous list item sibling\nexport const normalizeNestedList = (\n  editor: PlateEditor,\n  { nestedListItem }: { nestedListItem: NodeEntry<TElement> }\n) => {\n  const [, path] = nestedListItem;\n\n  const parentNode = getParent(editor, path);\n  const hasParentList =\n    parentNode && match(parentNode[0], { type: getListTypes(editor) });\n  if (!hasParentList) {\n    return false;\n  }\n\n  let previousListItemPath: Path;\n  try {\n    previousListItemPath = Path.previous(path);\n  } catch (e) {\n    return false;\n  }\n\n  // Previous sibling is the new parent\n  const previousSiblingItem = Editor.node(\n    editor,\n    previousListItemPath\n  ) as NodeEntry<Ancestor>;\n\n  if (previousSiblingItem) {\n    const [, previousPath] = previousSiblingItem;\n    const newPath = previousPath.concat([1]);\n\n    // Move the current item to the sublist\n    Transforms.moveNodes(editor, {\n      at: path,\n      to: newPath,\n    });\n\n    return true;\n  }\n};\n","import {\n  ELEMENT_DEFAULT,\n  getNode,\n  getParent,\n  getPluginType,\n  getPreviousPath,\n  isElement,\n  match,\n  PlateEditor,\n  setNodes,\n  TDescendant,\n  TElement,\n} from '@udecode/plate-core';\nimport { Descendant, NodeEntry, Path, Transforms } from 'slate';\nimport { ELEMENT_LI, ELEMENT_LIC } from '../createListPlugin';\nimport { getListTypes } from '../queries/getListTypes';\nimport { moveListItemsToList } from '../transforms';\nimport { ListPlugin } from '../types';\nimport { normalizeListItem } from './normalizeListItem';\nimport { normalizeNestedList } from './normalizeNestedList';\n\n/**\n * Normalize list node to force the ul>li>p+ul structure.\n */\nexport const normalizeList = (\n  editor: PlateEditor,\n  { validLiChildrenTypes }: ListPlugin\n) => {\n  const { normalizeNode } = editor;\n  const liType = getPluginType(editor, ELEMENT_LI);\n  const licType = getPluginType(editor, ELEMENT_LIC);\n  const defaultType = getPluginType(editor, ELEMENT_DEFAULT);\n\n  return ([node, path]: NodeEntry) => {\n    if (!isElement(node)) return;\n\n    // remove empty list\n    if (match(node, { type: getListTypes(editor) })) {\n      if (\n        !node.children.length ||\n        !node.children.find(\n          (item: Descendant) => (item as TDescendant).type === liType\n        )\n      ) {\n        return Transforms.removeNodes(editor, { at: path });\n      }\n\n      const nextPath = Path.next(path);\n      const nextNode = getNode(editor, nextPath) as TElement | null;\n\n      // Has a list afterwards with the same type\n      if (nextNode?.type === node.type) {\n        moveListItemsToList(editor, {\n          fromList: [nextNode, nextPath],\n          toList: [node, path],\n          deleteFromList: true,\n        });\n      }\n\n      const prevPath = getPreviousPath(path) as Path;\n      const prevNode = getNode(editor, prevPath) as TElement | null;\n\n      // Has a list before with the same type\n      if (prevNode?.type === node.type) {\n        editor.normalizeNode([prevNode, prevPath]);\n\n        // early return since this node will no longer exists\n        return;\n      }\n\n      if (normalizeNestedList(editor, { nestedListItem: [node, path] })) {\n        return;\n      }\n    }\n\n    if (node.type === getPluginType(editor, ELEMENT_LI)) {\n      if (\n        normalizeListItem(editor, {\n          listItem: [node, path],\n          validLiChildrenTypes,\n        })\n      ) {\n        return;\n      }\n    }\n\n    // LIC should have LI parent. If not, set LIC to DEFAULT type.\n    if (node.type === licType && licType !== defaultType) {\n      if (getParent(editor, path)?.[0].type !== liType) {\n        setNodes(editor, { type: defaultType }, { at: path });\n        return;\n      }\n    }\n\n    normalizeNode([node, path]);\n  };\n};\n","import { WithOverride } from '@udecode/plate-core';\nimport { deleteBackwardList } from './deleteBackwardList';\nimport { deleteForwardList } from './deleteForwardList';\nimport { deleteFragmentList } from './deleteFragmentList';\nimport { insertBreakList } from './insertBreakList';\nimport { insertFragmentList } from './insertFragmentList';\nimport { normalizeList } from './normalizers';\nimport { ListPlugin } from './types';\n\nexport const withList: WithOverride<{}, ListPlugin> = (\n  editor,\n  { options: { validLiChildrenTypes } }\n) => {\n  const { insertBreak, deleteBackward, deleteForward, deleteFragment } = editor;\n\n  editor.insertBreak = () => {\n    if (insertBreakList(editor)) return;\n\n    insertBreak();\n  };\n\n  editor.deleteBackward = (unit) => {\n    if (deleteBackwardList(editor, unit)) return;\n\n    deleteBackward(unit);\n  };\n\n  editor.deleteForward = (unit) => {\n    if (deleteForwardList(editor)) return;\n\n    deleteForward(unit);\n  };\n\n  editor.deleteFragment = () => {\n    if (deleteFragmentList(editor)) return;\n\n    deleteFragment();\n  };\n\n  editor.insertFragment = insertFragmentList(editor);\n\n  editor.normalizeNode = normalizeList(editor, { validLiChildrenTypes });\n\n  return editor;\n};\n","import {\n  createPluginFactory,\n  KEY_DESERIALIZE_HTML,\n  PlatePlugin,\n  someNode,\n} from '@udecode/plate-core';\nimport { onKeyDownList } from './onKeyDownList';\nimport { ListPlugin } from './types';\nimport { withList } from './withList';\n\nexport const ELEMENT_UL = 'ul';\nexport const ELEMENT_OL = 'ol';\nexport const ELEMENT_LI = 'li';\nexport const ELEMENT_LIC = 'lic';\n\n/**\n * Enables support for bulleted, numbered and to-do lists.\n */\nexport const createListPlugin = createPluginFactory({\n  key: 'list',\n  plugins: [\n    {\n      key: ELEMENT_UL,\n      isElement: true,\n      handlers: {\n        onKeyDown: onKeyDownList,\n      },\n      withOverrides: withList,\n      deserializeHtml: { validNodeName: 'UL' },\n    } as PlatePlugin<{}, ListPlugin>,\n    {\n      key: ELEMENT_OL,\n      isElement: true,\n      handlers: {\n        onKeyDown: onKeyDownList,\n      },\n      deserializeHtml: { validNodeName: 'OL' },\n    } as PlatePlugin<{}, ListPlugin>,\n    {\n      key: ELEMENT_LI,\n      isElement: true,\n      deserializeHtml: { validNodeName: 'LI' },\n      then: (editor, { type }) => ({\n        inject: {\n          pluginsByKey: {\n            [KEY_DESERIALIZE_HTML]: {\n              editor: {\n                insertData: {\n                  preInsert: () => {\n                    return someNode(editor, { match: { type } });\n                  },\n                },\n              },\n            },\n          },\n        },\n      }),\n    },\n    {\n      key: ELEMENT_LIC,\n      isElement: true,\n    },\n  ],\n});\n","import {\n  createPluginFactory,\n  HotkeyPlugin,\n  onKeyDownToggleElement,\n} from '@udecode/plate-core';\n\nexport const ELEMENT_TODO_LI = 'action_item';\n\nexport const createTodoListPlugin = createPluginFactory<HotkeyPlugin>({\n  key: ELEMENT_TODO_LI,\n  isElement: true,\n  handlers: {\n    onKeyDown: onKeyDownToggleElement,\n  },\n  options: {\n    hotkey: ['mod+opt+4', 'mod+shift+4'],\n  },\n});\n"]},"metadata":{},"sourceType":"module"}