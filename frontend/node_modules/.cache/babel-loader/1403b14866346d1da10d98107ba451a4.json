{"ast":null,"code":"import { KEY_ALIGN } from '@udecode/plate-alignment';\nimport { MARK_BOLD, MARK_ITALIC } from '@udecode/plate-basic-marks';\nimport { ELEMENT_CODE_BLOCK, deserializeHtmlCodeBlock } from '@udecode/plate-code-block';\nimport { isHtmlElement, isHtmlComment, parseHtmlElement, isHtmlText, createPluginFactory, KEY_DESERIALIZE_HTML } from '@udecode/plate-core';\nimport { ELEMENT_H1, ELEMENT_H2, ELEMENT_H3 } from '@udecode/plate-heading';\nimport { ELEMENT_IMAGE } from '@udecode/plate-image';\nimport { KEY_INDENT } from '@udecode/plate-indent';\nimport { ListStyleType, KEY_LIST_STYLE_TYPE } from '@udecode/plate-indent-list';\nimport { ELEMENT_PARAGRAPH } from '@udecode/plate-paragraph';\n/**\r\n * Is the element a block element?\r\n */\n\nconst isHtmlBlockElement = element => {\n  const blockRegex = /^(address|blockquote|body|center|dir|div|dl|fieldset|form|h[1-6]|hr|isindex|menu|noframes|noscript|ol|p|pre|table|ul|dd|dt|frameset|li|tbody|td|tfoot|th|thead|tr|html)$/i;\n  return blockRegex.test(element.nodeName);\n};\n/**\r\n * Depth-first pre-order tree traverse the given HTML node and calls the given callback for each node.\r\n * see: https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)\r\n *\r\n * @param callback returns a boolean indicating whether traversal should be continued\r\n */\n\n\nconst traverseHtmlNode = (node, callback) => {\n  const keepTraversing = callback(node);\n\n  if (!keepTraversing) {\n    return;\n  }\n\n  let child = node.firstChild;\n\n  while (child) {\n    const currentChild = child;\n    const previousChild = child.previousSibling;\n    child = child.nextSibling;\n    traverseHtmlNode(currentChild, callback);\n\n    if ( // An unwrap was made. Need to compute the next child again.\n    !currentChild.previousSibling && !currentChild.nextSibling && !currentChild.parentNode && child && previousChild !== child.previousSibling && child.parentNode) {\n      if (previousChild) {\n        child = previousChild.nextSibling;\n      } else {\n        child = node.firstChild;\n      }\n    } else if ( // A list was created. Need to compute the next child again.\n    !currentChild.previousSibling && !currentChild.nextSibling && !currentChild.parentNode && child && !child.previousSibling && !child.nextSibling && !child.parentNode) {\n      if (previousChild) {\n        if (previousChild.nextSibling) {\n          child = previousChild.nextSibling.nextSibling;\n        } else {\n          child = null;\n        }\n      } else if (node.firstChild) {\n        child = node.firstChild.nextSibling;\n      }\n    }\n  }\n};\n/**\r\n * Traverse the HTML elements of the given HTML node.\r\n * @param rootNode The root HTML node to traverse.\r\n * @param callback The callback to call for each HTML element.\r\n */\n\n\nconst traverseHtmlElements = (rootNode, callback) => {\n  traverseHtmlNode(rootNode, node => {\n    if (!isHtmlElement(node)) {\n      return true;\n    }\n\n    return callback(node);\n  });\n};\n/**\r\n * Set HTML blocks mark styles to a new child span element if any.\r\n * This allows Plate to use block marks.\r\n */\n\n\nconst copyBlockMarksToSpanChild = rootNode => {\n  traverseHtmlElements(rootNode, element => {\n    const el = element;\n    const styleAttribute = element.getAttribute('style');\n    if (!styleAttribute) return true;\n\n    if (isHtmlBlockElement(el)) {\n      const {\n        style: {\n          backgroundColor,\n          color,\n          fontFamily,\n          fontSize,\n          fontStyle,\n          fontWeight,\n          textDecoration\n        }\n      } = el;\n\n      if (backgroundColor || color || fontFamily || fontSize || fontStyle || fontWeight || textDecoration) {\n        const span = document.createElement('span');\n\n        if (!['initial', 'inherit'].includes(color)) {\n          span.style.color = color;\n        }\n\n        span.style.fontFamily = fontFamily;\n        span.style.fontSize = fontSize;\n\n        if (!['normal', 'initial', 'inherit'].includes(color)) {\n          span.style.fontStyle = fontStyle;\n        }\n\n        if (!['normal', 400].includes(fontWeight)) {\n          span.style.fontWeight = fontWeight;\n        }\n\n        span.style.textDecoration = textDecoration;\n        span.innerHTML = el.innerHTML;\n        element.innerHTML = span.outerHTML;\n      }\n    }\n\n    return true;\n  });\n};\n/**\r\n * Traverse HTML comments.\r\n */\n\n\nconst traverseHtmlComments = (rootNode, callback) => {\n  traverseHtmlNode(rootNode, node => {\n    if (!isHtmlComment(node)) {\n      return true;\n    }\n\n    return callback(node);\n  });\n};\n/**\r\n * Removes HTML nodes between HTML comments.\r\n */\n\n\nconst removeHtmlNodesBetweenComments = (rootNode, start, end) => {\n  const isClosingComment = node => isHtmlComment(node) && node.data === end;\n\n  traverseHtmlComments(rootNode, comment => {\n    if (comment.data === start) {\n      let node = comment.nextSibling;\n      comment.remove();\n\n      while (node && !isClosingComment(node)) {\n        const {\n          nextSibling\n        } = node;\n        node.remove();\n        node = nextSibling;\n      }\n\n      if (node && isClosingComment(node)) {\n        node.remove();\n      }\n    }\n\n    return true;\n  });\n};\n/**\r\n * Remove HTML nodes between comments in the next sibling after BR.\r\n */\n\n\nconst cleanDocxBrComments = rootNode => {\n  traverseHtmlElements(rootNode, element => {\n    if (element.tagName !== 'BR') {\n      return true;\n    }\n\n    if (element.nextSibling && isHtmlComment(element.nextSibling) && element.nextSibling.data === '[if !supportLineBreakNewLine]') {\n      removeHtmlNodesBetweenComments(element.nextSibling, '[if !supportLineBreakNewLine]', '[endif]');\n    }\n\n    return false;\n  });\n};\n\nconst CARRIAGE_RETURN = '\\u000D';\nconst LINE_FEED = '\\u000A';\nconst NO_BREAK_SPACE = '\\u00A0';\nconst SPACE = '\\u0020';\nconst TAB = '\\u0009';\nconst ZERO_WIDTH_SPACE = '\\u200B';\n\nconst isHtmlOpEmpty = element => element.nodeName === 'O:P' && element.textContent === NO_BREAK_SPACE;\n\nconst isHtmlElementEmpty = element => element.children.length === 1 && element.firstElementChild !== null && (isHtmlOpEmpty(element.firstElementChild) || isHtmlElementEmpty(element.firstElementChild));\n/**\r\n * Remove paragraph innerHTML if its child is 'O:P' with NO_BREAK_SPACE.\r\n */\n\n\nconst cleanDocxEmptyParagraphs = rootNode => {\n  traverseHtmlElements(rootNode, element => {\n    if (element.tagName === 'P' && isHtmlElementEmpty(element)) {\n      element.innerHTML = '';\n    }\n\n    return true;\n  });\n};\n/**\r\n * Is element a docx footnote.\r\n */\n\n\nconst isDocxFootnote = element => {\n  return element.tagName === 'SPAN' && element.classList.contains('MsoFootnoteReference');\n};\n/**\r\n * Gets \"4\" from \"[4]\", \"A\" from \"[A]\", etc.\r\n */\n\n\nconst extractFootnoteNumber = footnote => {\n  return (footnote.textContent || '').trim().replace(/[[\\]]/g, '');\n};\n/**\r\n * Replace docx footnotes with sup element.\r\n */\n\n\nconst cleanDocxFootnotes = rootNode => {\n  traverseHtmlElements(rootNode, element => {\n    if (isDocxFootnote(element)) {\n      const footnoteReplacement = document.createElement('sup');\n      footnoteReplacement.textContent = extractFootnoteNumber(element);\n\n      if (element.parentElement) {\n        element.parentElement.replaceChild(footnoteReplacement, element);\n      }\n\n      return true;\n    }\n\n    return true;\n  });\n};\n\nfunction unwrapExports(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar assertString_1 = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.default = assertString;\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function _typeof(obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function _typeof(obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function assertString(input) {\n    var isString = typeof input === 'string' || input instanceof String;\n\n    if (!isString) {\n      var invalidType = _typeof(input);\n\n      if (input === null) invalidType = 'null';else if (invalidType === 'object') invalidType = input.constructor.name;\n      throw new TypeError(\"Expected a string but received a \".concat(invalidType));\n    }\n  }\n\n  module.exports = exports.default;\n  module.exports.default = exports.default;\n});\nunwrapExports(assertString_1);\nvar merge_1 = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.default = merge;\n\n  function merge() {\n    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var defaults = arguments.length > 1 ? arguments[1] : undefined;\n\n    for (var key in defaults) {\n      if (typeof obj[key] === 'undefined') {\n        obj[key] = defaults[key];\n      }\n    }\n\n    return obj;\n  }\n\n  module.exports = exports.default;\n  module.exports.default = exports.default;\n});\nunwrapExports(merge_1);\nvar isFQDN_1 = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.default = isFQDN;\n\n  var _assertString = _interopRequireDefault(assertString_1);\n\n  var _merge = _interopRequireDefault(merge_1);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  var default_fqdn_options = {\n    require_tld: true,\n    allow_underscores: false,\n    allow_trailing_dot: false,\n    allow_numeric_tld: false,\n    allow_wildcard: false\n  };\n\n  function isFQDN(str, options) {\n    (0, _assertString.default)(str);\n    options = (0, _merge.default)(options, default_fqdn_options);\n    /* Remove the optional trailing dot before checking validity */\n\n    if (options.allow_trailing_dot && str[str.length - 1] === '.') {\n      str = str.substring(0, str.length - 1);\n    }\n    /* Remove the optional wildcard before checking validity */\n\n\n    if (options.allow_wildcard === true && str.indexOf('*.') === 0) {\n      str = str.substring(2);\n    }\n\n    var parts = str.split('.');\n    var tld = parts[parts.length - 1];\n\n    if (options.require_tld) {\n      // disallow fqdns without tld\n      if (parts.length < 2) {\n        return false;\n      }\n\n      if (!/^([a-z\\u00A1-\\u00A8\\u00AA-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {\n        return false;\n      } // disallow spaces\n\n\n      if (/\\s/.test(tld)) {\n        return false;\n      }\n    } // reject numeric TLDs\n\n\n    if (!options.allow_numeric_tld && /^\\d+$/.test(tld)) {\n      return false;\n    }\n\n    return parts.every(function (part) {\n      if (part.length > 63) {\n        return false;\n      }\n\n      if (!/^[a-z_\\u00a1-\\uffff0-9-]+$/i.test(part)) {\n        return false;\n      } // disallow full-width chars\n\n\n      if (/[\\uff01-\\uff5e]/.test(part)) {\n        return false;\n      } // disallow parts starting or ending with hyphen\n\n\n      if (/^-|-$/.test(part)) {\n        return false;\n      }\n\n      if (!options.allow_underscores && /_/.test(part)) {\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  module.exports = exports.default;\n  module.exports.default = exports.default;\n});\nunwrapExports(isFQDN_1);\nvar isIP_1 = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.default = isIP;\n\n  var _assertString = _interopRequireDefault(assertString_1);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n  /**\r\n  11.3.  Examples\r\n  \r\n     The following addresses\r\n  \r\n               fe80::1234 (on the 1st link of the node)\r\n               ff02::5678 (on the 5th link of the node)\r\n               ff08::9abc (on the 10th organization of the node)\r\n  \r\n     would be represented as follows:\r\n  \r\n               fe80::1234%1\r\n               ff02::5678%5\r\n               ff08::9abc%10\r\n  \r\n     (Here we assume a natural translation from a zone index to the\r\n     <zone_id> part, where the Nth zone of any scope is translated into\r\n     \"N\".)\r\n  \r\n     If we use interface names as <zone_id>, those addresses could also be\r\n     represented as follows:\r\n  \r\n              fe80::1234%ne0\r\n              ff02::5678%pvc1.3\r\n              ff08::9abc%interface10\r\n  \r\n     where the interface \"ne0\" belongs to the 1st link, \"pvc1.3\" belongs\r\n     to the 5th link, and \"interface10\" belongs to the 10th organization.\r\n   * * */\n\n\n  var IPv4SegmentFormat = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';\n  var IPv4AddressFormat = \"(\".concat(IPv4SegmentFormat, \"[.]){3}\").concat(IPv4SegmentFormat);\n  var IPv4AddressRegExp = new RegExp(\"^\".concat(IPv4AddressFormat, \"$\"));\n  var IPv6SegmentFormat = '(?:[0-9a-fA-F]{1,4})';\n  var IPv6AddressRegExp = new RegExp('^(' + \"(?:\".concat(IPv6SegmentFormat, \":){7}(?:\").concat(IPv6SegmentFormat, \"|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){6}(?:\").concat(IPv4AddressFormat, \"|:\").concat(IPv6SegmentFormat, \"|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){5}(?::\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,2}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){4}(?:(:\").concat(IPv6SegmentFormat, \"){0,1}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,3}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){3}(?:(:\").concat(IPv6SegmentFormat, \"){0,2}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,4}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){2}(?:(:\").concat(IPv6SegmentFormat, \"){0,3}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,5}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){1}(?:(:\").concat(IPv6SegmentFormat, \"){0,4}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,6}|:)|\") + \"(?::((?::\".concat(IPv6SegmentFormat, \"){0,5}:\").concat(IPv4AddressFormat, \"|(?::\").concat(IPv6SegmentFormat, \"){1,7}|:))\") + ')(%[0-9a-zA-Z-.:]{1,})?$');\n\n  function isIP(str) {\n    var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    (0, _assertString.default)(str);\n    version = String(version);\n\n    if (!version) {\n      return isIP(str, 4) || isIP(str, 6);\n    }\n\n    if (version === '4') {\n      if (!IPv4AddressRegExp.test(str)) {\n        return false;\n      }\n\n      var parts = str.split('.').sort(function (a, b) {\n        return a - b;\n      });\n      return parts[3] <= 255;\n    }\n\n    if (version === '6') {\n      return !!IPv6AddressRegExp.test(str);\n    }\n\n    return false;\n  }\n\n  module.exports = exports.default;\n  module.exports.default = exports.default;\n});\nunwrapExports(isIP_1);\nvar isURL_1 = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.default = isURL;\n\n  var _assertString = _interopRequireDefault(assertString_1);\n\n  var _isFQDN = _interopRequireDefault(isFQDN_1);\n\n  var _isIP = _interopRequireDefault(isIP_1);\n\n  var _merge = _interopRequireDefault(merge_1);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n  /*\r\n  options for isURL method\r\n  \r\n  require_protocol - if set as true isURL will return false if protocol is not present in the URL\r\n  require_valid_protocol - isURL will check if the URL's protocol is present in the protocols option\r\n  protocols - valid protocols can be modified with this option\r\n  require_host - if set as false isURL will not check if host is present in the URL\r\n  require_port - if set as true isURL will check if port is present in the URL\r\n  allow_protocol_relative_urls - if set as true protocol relative URLs will be allowed\r\n  validate_length - if set as false isURL will skip string length validation (IE maximum is 2083)\r\n  \r\n  */\n\n\n  var default_url_options = {\n    protocols: ['http', 'https', 'ftp'],\n    require_tld: true,\n    require_protocol: false,\n    require_host: true,\n    require_port: false,\n    require_valid_protocol: true,\n    allow_underscores: false,\n    allow_trailing_dot: false,\n    allow_protocol_relative_urls: false,\n    allow_fragments: true,\n    allow_query_components: true,\n    validate_length: true\n  };\n  var wrapped_ipv6 = /^\\[([^\\]]+)\\](?::([0-9]+))?$/;\n\n  function isRegExp(obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n  }\n\n  function checkHost(host, matches) {\n    for (var i = 0; i < matches.length; i++) {\n      var match = matches[i];\n\n      if (host === match || isRegExp(match) && match.test(host)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function isURL(url, options) {\n    (0, _assertString.default)(url);\n\n    if (!url || /[\\s<>]/.test(url)) {\n      return false;\n    }\n\n    if (url.indexOf('mailto:') === 0) {\n      return false;\n    }\n\n    options = (0, _merge.default)(options, default_url_options);\n\n    if (options.validate_length && url.length >= 2083) {\n      return false;\n    }\n\n    if (!options.allow_fragments && url.includes('#')) {\n      return false;\n    }\n\n    if (!options.allow_query_components && (url.includes('?') || url.includes('&'))) {\n      return false;\n    }\n\n    var protocol, auth, host, hostname, port, port_str, split, ipv6;\n    split = url.split('#');\n    url = split.shift();\n    split = url.split('?');\n    url = split.shift();\n    split = url.split('://');\n\n    if (split.length > 1) {\n      protocol = split.shift().toLowerCase();\n\n      if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {\n        return false;\n      }\n    } else if (options.require_protocol) {\n      return false;\n    } else if (url.substr(0, 2) === '//') {\n      if (!options.allow_protocol_relative_urls) {\n        return false;\n      }\n\n      split[0] = url.substr(2);\n    }\n\n    url = split.join('://');\n\n    if (url === '') {\n      return false;\n    }\n\n    split = url.split('/');\n    url = split.shift();\n\n    if (url === '' && !options.require_host) {\n      return true;\n    }\n\n    split = url.split('@');\n\n    if (split.length > 1) {\n      if (options.disallow_auth) {\n        return false;\n      }\n\n      if (split[0] === '') {\n        return false;\n      }\n\n      auth = split.shift();\n\n      if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {\n        return false;\n      }\n\n      var _auth$split = auth.split(':'),\n          _auth$split2 = _slicedToArray(_auth$split, 2),\n          user = _auth$split2[0],\n          password = _auth$split2[1];\n\n      if (user === '' && password === '') {\n        return false;\n      }\n    }\n\n    hostname = split.join('@');\n    port_str = null;\n    ipv6 = null;\n    var ipv6_match = hostname.match(wrapped_ipv6);\n\n    if (ipv6_match) {\n      host = '';\n      ipv6 = ipv6_match[1];\n      port_str = ipv6_match[2] || null;\n    } else {\n      split = hostname.split(':');\n      host = split.shift();\n\n      if (split.length) {\n        port_str = split.join(':');\n      }\n    }\n\n    if (port_str !== null && port_str.length > 0) {\n      port = parseInt(port_str, 10);\n\n      if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {\n        return false;\n      }\n    } else if (options.require_port) {\n      return false;\n    }\n\n    if (options.host_whitelist) {\n      return checkHost(host, options.host_whitelist);\n    }\n\n    if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {\n      return false;\n    }\n\n    host = host || ipv6;\n\n    if (options.host_blacklist && checkHost(host, options.host_blacklist)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  module.exports = exports.default;\n  module.exports.default = exports.default;\n});\nvar isURL = unwrapExports(isURL_1);\n\nconst getRtfImageHex = imageData => {\n  const [, bliptagData = ''] = imageData.split('bliptag');\n  const bracketSplit = bliptagData.split('}');\n\n  if (bracketSplit.length < 2) {\n    return null;\n  }\n\n  const [beforeBracket, afterBracket] = bracketSplit;\n\n  if (bracketSplit.length > 2 && beforeBracket.includes('blipuid')) {\n    return afterBracket.split(SPACE).join('');\n  }\n\n  const spaceSplit = beforeBracket.split(SPACE);\n\n  if (spaceSplit.length < 2) {\n    return null;\n  }\n\n  return spaceSplit.slice(1).join('');\n};\n\nconst getRtfImageMimeType = imageData => {\n  const [bliptagMeta] = imageData.split('bliptag');\n\n  if (bliptagMeta.includes('pngblip')) {\n    return 'image/png';\n  }\n\n  if (bliptagMeta.includes('jpegblip')) {\n    return 'image/jpeg';\n  }\n\n  return null;\n};\n\nconst END_OF_ID_SEQUENCE_CHARACTERS = ['\\\\', '{', CARRIAGE_RETURN, LINE_FEED, SPACE];\n\nconst getRtfImageSpid = (imageData, spidPrefix) => {\n  const indexes = END_OF_ID_SEQUENCE_CHARACTERS.map(character => imageData.indexOf(character));\n  const foundIndexes = indexes.filter(index => index !== -1);\n  const idLength = Math.min(imageData.length, ...foundIndexes);\n  const id = imageData.substring(0, idLength);\n  return id ? `${spidPrefix}${id}` : null;\n};\n\nconst getRtfImagesByType = (rtf, spidPrefix, type) => {\n  const [, ...images] = rtf.split(type);\n  return images.reduce((rtfImages, image) => {\n    const [, imageData = ''] = image.split('shplid');\n    const spid = getRtfImageSpid(imageData, spidPrefix);\n    const mimeType = getRtfImageMimeType(imageData);\n    const hex = getRtfImageHex(imageData);\n\n    if (spid && mimeType && hex) {\n      rtfImages.push({\n        hex,\n        mimeType,\n        spid\n      });\n    }\n\n    return rtfImages;\n  }, []);\n};\n\nconst getRtfImagesMap = rtf => {\n  const rtfImagesMap = {};\n  const shppictRtfImages = getRtfImagesByType(rtf, 'i', '\\\\shppict');\n\n  for (const shppictRtfImage of shppictRtfImages) {\n    rtfImagesMap[shppictRtfImage.spid] = shppictRtfImage;\n  }\n\n  const shpRtfImages = getRtfImagesByType(rtf, 's', '\\\\shp');\n\n  for (const shpRtfImage of shpRtfImages) {\n    rtfImagesMap[shpRtfImage.spid] = shpRtfImage;\n  }\n\n  return rtfImagesMap;\n};\n\nconst acceptNode = () => NodeFilter.FILTER_ACCEPT;\n\nconst getHtmlComments = node => {\n  const comments = [];\n  const iterator = document.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {\n    acceptNode\n  });\n  let currentNode = iterator.nextNode();\n\n  while (currentNode) {\n    if (currentNode.nodeValue) {\n      comments.push(currentNode.nodeValue);\n    }\n\n    currentNode = iterator.nextNode();\n  }\n\n  return comments;\n};\n\nconst getVShapes = document => {\n  const comments = getHtmlComments(document);\n  return comments.reduce((vShapesMap, comment) => {\n    try {\n      const xmlDocument = new DOMParser().parseFromString(comment, 'text/html');\n      const vShapes = Array.from(xmlDocument.getElementsByTagName('V:SHAPE'));\n      vShapes.forEach(vShape => {\n        const {\n          id\n        } = vShape;\n        const spid = vShape.getAttribute('o:spid');\n\n        if (typeof id === 'string' && typeof spid === 'string') {\n          vShapesMap[id] = spid;\n        }\n      });\n    } catch (error) {// Cannot parse as XML, we're not interested in this comment\n    }\n\n    return vShapesMap;\n  }, {});\n};\n\nconst normalizeSpid = spid => {\n  const [,, id] = spid.split('_');\n  return id;\n};\n\nconst getVShapeSpid = (document, element) => {\n  if (element.tagName === 'IMG') {\n    const vShapeId = element.getAttribute('v:shapes');\n    const vShapes = getVShapes(document);\n\n    if (!vShapeId) {\n      return null;\n    }\n\n    const vShapeSpid = vShapes[vShapeId];\n\n    if (vShapeSpid) {\n      return normalizeSpid(vShapeSpid);\n    }\n\n    if (element.parentElement && element.parentElement.parentElement && element.parentElement.parentElement.innerHTML.indexOf('msEquation') >= 0) {\n      return null;\n    }\n\n    return normalizeSpid(vShapeId);\n  }\n\n  if (!element.parentElement) {\n    return null;\n  }\n\n  const spid = element.parentElement.getAttribute('o:spid');\n\n  if (spid) {\n    return normalizeSpid(spid);\n  }\n\n  return spid;\n};\n\nconst hexToBase64 = hex => {\n  const hexPairs = hex.match(/\\w{2}/g) || [];\n  const binary = hexPairs.map(hexPair => String.fromCharCode(parseInt(hexPair, 16)));\n  return btoa(binary.join(''));\n};\n/**\r\n * Clean docx image elements.\r\n */\n\n\nconst cleanDocxImageElements = (document, rtf, rootNode) => {\n  if (!rtf) {\n    return;\n  }\n\n  traverseHtmlElements(rootNode, element => {\n    if (!['IMG', 'V:IMAGEDATA'].includes(element.tagName)) {\n      return true;\n    }\n\n    if (element.tagName === 'IMG') {\n      const src = element.getAttribute('src');\n\n      if (!src || !src.startsWith('file://')) {\n        return true;\n      }\n\n      const alt = element.getAttribute('alt');\n\n      if (typeof alt === 'string' && isURL(alt, {\n        require_protocol: true\n      })) {\n        element.setAttribute('src', alt);\n        return true;\n      }\n    }\n\n    const vShapeSpid = getVShapeSpid(document, element);\n\n    if (!vShapeSpid) {\n      return true;\n    }\n\n    const rtfImagesMap = getRtfImagesMap(rtf);\n    const rtfImage = rtfImagesMap[vShapeSpid];\n\n    if (!rtfImage) {\n      // We fould some kind of vshape (perhaps a drawing) that we don't know\n      // how to recover from RTF. So we just skip it.\n      element.remove();\n      return true;\n    }\n\n    const dataUri = `data:${rtfImage.mimeType};base64,${hexToBase64(rtfImage.hex)}`;\n\n    if (element.tagName === 'IMG') {\n      element.setAttribute('src', dataUri);\n    } else if (element.parentNode && element.parentNode.parentNode) {\n      const imageElement = document.createElement('img');\n      imageElement.setAttribute('src', dataUri);\n      element.parentNode.parentNode.replaceChild(imageElement, element.parentNode);\n    }\n\n    return true;\n  });\n};\n/**\r\n * Clean elements style mso-list to mso-list:Ignore\r\n */\n\n\nconst cleanDocxListElements = rootNode => {\n  traverseHtmlElements(rootNode, element => {\n    const styleAttribute = element.getAttribute('style');\n\n    if (styleAttribute) {\n      element.setAttribute('style', styleAttribute.replace(/mso-list:\\s*Ignore/gim, 'mso-list:Ignore'));\n    }\n\n    return true;\n  });\n};\n\nconst getDocxListContentHtml = rootElement => {\n  const clonedElement = rootElement.cloneNode(true);\n  removeHtmlNodesBetweenComments(clonedElement, '[if !supportLists]', '[endif]');\n  traverseHtmlElements(clonedElement, element => {\n    const styleAttribute = element.getAttribute('style');\n\n    if (styleAttribute === 'mso-list:Ignore') {\n      element.remove();\n    }\n\n    return true;\n  });\n  return clonedElement.innerHTML;\n};\n\nconst getDocxListIndent = element => {\n  const styleAttribute = element.getAttribute('style') || '';\n  const matches = styleAttribute.match(/level(\\d+)/im);\n\n  if (matches && matches.length >= 1) {\n    const [, level] = matches;\n    return parseInt(level, 10);\n  }\n\n  return 1;\n};\n\nconst isDocxBookmark = element => {\n  const styleAttribute = element.getAttribute('style');\n  return (styleAttribute || '').startsWith('mso-bookmark') && !element.textContent;\n};\n\nconst isDocxList = element => {\n  const styleAttribute = element.getAttribute('style');\n\n  if (!styleAttribute) {\n    return false;\n  }\n\n  const hasMsoListInStyle = /mso-list:\\s*l/gim.test(styleAttribute);\n\n  if (!hasMsoListInStyle) {\n    return false;\n  }\n\n  const hasMsoListIgnoreChild = Boolean(element.querySelector('[style=\"mso-list:Ignore\"]'));\n\n  if (hasMsoListIgnoreChild) {\n    return true;\n  }\n\n  return element.outerHTML.includes('<!--[if !supportLists]-->');\n};\n\nconst getDocxListNode = element => {\n  return element.querySelector('[style=\"mso-list:Ignore\"]') || element.querySelector('span[lang]');\n};\n\nconst isOlSymbol = symbol => {\n  return /[0-9a-np-z]\\S/g.test(symbol.toLowerCase());\n};\n\nconst isDocxOl = element => {\n  const listNode = getDocxListNode(element);\n\n  if (!listNode) {\n    return false;\n  }\n\n  return isOlSymbol(listNode.textContent || '');\n};\n\nconst docxListToList = element => {\n  const listLevel = getDocxListIndent(element);\n  let listHtml = '';\n  let nextSibling = element;\n\n  while (nextSibling) {\n    if (isDocxBookmark(nextSibling)) {\n      nextSibling = nextSibling.nextElementSibling;\n      continue;\n    }\n\n    if (!isDocxList(nextSibling)) {\n      break;\n    }\n\n    const nextListLevel = getDocxListIndent(nextSibling);\n\n    if (nextListLevel < listLevel) {\n      // Lower level found. Current list is done.\n      break;\n    }\n\n    if (nextListLevel > listLevel) {\n      const nestedList = docxListToList(nextSibling);\n\n      if (nestedList.list) {\n        listHtml += nestedList.list.outerHTML;\n      }\n\n      nextSibling = nestedList.nextSibling;\n      continue;\n    }\n\n    listHtml += `<li>${getDocxListContentHtml(nextSibling)}</li>`;\n    const currentElement = nextSibling;\n    nextSibling = currentElement.nextElementSibling;\n    currentElement.remove();\n  }\n\n  const listTagName = isDocxOl(element) ? 'ol' : 'ul';\n  const list = parseHtmlElement(`<${listTagName}>${listHtml}</${listTagName}>`);\n  return {\n    list,\n    nextSibling\n  };\n};\n\nconst cleanDocxListElementsToList = rootNode => {\n  traverseHtmlElements(rootNode, element => {\n    const styleAttribute = element.getAttribute('style');\n\n    if (styleAttribute) {\n      element.setAttribute('style', styleAttribute.replace(/mso-list:\\s*Ignore/gim, 'mso-list:Ignore'));\n    }\n\n    return true;\n  });\n  traverseHtmlElements(rootNode, element => {\n    if (!isDocxList(element)) {\n      return true;\n    }\n\n    const {\n      parentElement,\n      previousSibling\n    } = element;\n\n    if (!parentElement) {\n      return true;\n    }\n\n    const {\n      list\n    } = docxListToList(element);\n\n    if (!list) {\n      return true;\n    }\n\n    const beforeElement = previousSibling ? previousSibling.nextSibling : parentElement.firstChild;\n\n    if (beforeElement) {\n      parentElement.insertBefore(list, beforeElement);\n    } else {\n      parentElement.appendChild(list);\n    }\n\n    return false;\n  });\n};\n/**\r\n * Replace `element` tag name by `tagName`.\r\n * Attributes, innerHTML and parent relationship is kept.\r\n */\n\n\nconst replaceTagName = (element, tagName) => {\n  const newElement = document.createElement(tagName);\n  newElement.innerHTML = element.innerHTML;\n\n  for (const {\n    name\n  } of element.attributes) {\n    const value = element.getAttribute(name);\n\n    if (value) {\n      newElement.setAttribute(name, value);\n    }\n  }\n\n  if (element.parentNode) {\n    element.parentNode.replaceChild(newElement, element);\n  }\n\n  return newElement;\n};\n/**\r\n * Replace p.MsoQuote elements with blockquote.\r\n */\n\n\nconst cleanDocxQuotes = rootNode => {\n  traverseHtmlElements(rootNode, element => {\n    if (element.parentNode && element.tagName === 'P' && element.classList.contains('MsoQuote')) {\n      replaceTagName(element, 'blockquote');\n    }\n\n    return true;\n  });\n};\n\nconst generateSpaces = count => Array.from({\n  length: count\n}, () => SPACE).join('');\n\nconst generateTabs = count => Array.from({\n  length: count\n}, () => TAB).join('');\n/**\r\n * Replace the element with spaces if its style includes 'mso-spacerun: yes'.\r\n */\n\n\nconst cleanDocxSpacerun = element => {\n  const styleAttribute = element.getAttribute('style');\n\n  if (!(styleAttribute && ['mso-spacerun:yes', 'mso-spacerun: yes'].includes(styleAttribute))) {\n    return;\n  }\n\n  const spacesCount = (element.textContent || '').length;\n  const replacementNode = document.createTextNode(generateSpaces(spacesCount));\n\n  if (element.parentNode) {\n    element.parentNode.replaceChild(replacementNode, element);\n  }\n};\n/**\r\n * Replace element with tabs if its style starts with 'mso-tab-count'.\r\n */\n\n\nconst cleanDocxTabCount = element => {\n  const styleAttribute = element.getAttribute('style') || '';\n\n  if (!styleAttribute.startsWith('mso-tab-count:')) {\n    return;\n  }\n\n  const [, countString] = styleAttribute.split(':');\n  const count = parseInt(countString, 10);\n  const replacementNode = document.createTextNode(generateTabs(count));\n\n  if (element.parentNode) {\n    element.parentNode.replaceChild(replacementNode, element);\n  }\n};\n/**\r\n * Clean docx spaceruns and tab counts.\r\n */\n\n\nconst cleanDocxSpans = rootNode => {\n  traverseHtmlElements(rootNode, element => {\n    if (element.nodeName !== 'SPAN') {\n      return true;\n    }\n\n    cleanDocxSpacerun(element);\n    cleanDocxTabCount(element);\n    return true;\n  });\n};\n/**\r\n * Replace BR elements with line feeds.\r\n */\n\n\nconst cleanHtmlBrElements = rootNode => {\n  traverseHtmlElements(rootNode, element => {\n    if (element.tagName !== 'BR') {\n      return true;\n    }\n\n    const replacementTextNode = document.createTextNode(LINE_FEED);\n\n    if (element.parentElement) {\n      element.parentElement.replaceChild(replacementTextNode, element);\n    }\n\n    return false;\n  });\n};\n/**\r\n * Replace \\r\\n and \\r with \\n\r\n */\n\n\nconst cleanHtmlCrLf = html => {\n  return html.replace(/(\\r\\n|\\r)/gm, '\\n');\n};\n\nconst ALLOWED_EMPTY_ELEMENTS = ['BR', 'IMG'];\n\nconst isEmpty = element => {\n  return !ALLOWED_EMPTY_ELEMENTS.includes(element.nodeName) && !element.innerHTML.trim();\n};\n\nconst removeIfEmpty = element => {\n  if (isEmpty(element)) {\n    const {\n      parentElement\n    } = element;\n    element.remove();\n\n    if (parentElement) {\n      removeIfEmpty(parentElement);\n    }\n  }\n};\n/**\r\n * Remove empty elements from rootNode.\r\n * Allowed empty elements: BR, IMG.\r\n */\n\n\nconst cleanHtmlEmptyElements = rootNode => {\n  traverseHtmlElements(rootNode, element => {\n    removeIfEmpty(element);\n    return true;\n  });\n};\n/**\r\n * Replace FONT elements with SPAN elements if there is textContent (remove otherwise).\r\n */\n\n\nconst cleanHtmlFontElements = rootNode => {\n  traverseHtmlElements(rootNode, element => {\n    if (element.tagName === 'FONT') {\n      if (element.textContent) {\n        replaceTagName(element, 'span');\n      } else {\n        element.remove();\n      }\n    }\n\n    return true;\n  });\n};\n/**\r\n * If href starts with '#'.\r\n */\n\n\nconst isHtmlFragmentHref = href => href.startsWith('#');\n/**\r\n * Unwrap the given HTML element.\r\n */\n\n\nconst unwrapHtmlElement = element => {\n  element.outerHTML = element.innerHTML;\n};\n/**\r\n * Remove fragment hrefs and spans without inner text.\r\n */\n\n\nconst cleanHtmlLinkElements = rootNode => {\n  traverseHtmlElements(rootNode, element => {\n    if (element.tagName !== 'A') {\n      return true;\n    }\n\n    const href = element.getAttribute('href');\n\n    if (!href || isHtmlFragmentHref(href)) {\n      unwrapHtmlElement(element);\n    }\n\n    if (href && element.querySelector('img')) {\n      for (const span of element.querySelectorAll('span')) {\n        if (!span.innerText) {\n          unwrapHtmlElement(span);\n        }\n      }\n    }\n\n    return true;\n  });\n};\n\nconst traverseHtmlTexts = (rootNode, callback) => {\n  traverseHtmlNode(rootNode, node => {\n    if (!isHtmlText(node)) {\n      return true;\n    }\n\n    return callback(node);\n  });\n};\n\nconst cleanHtmlTextNodes = rootNode => {\n  traverseHtmlTexts(rootNode, textNode => {\n    if (/^\\n\\s*$/.test(textNode.data) && (textNode.previousElementSibling || textNode.nextElementSibling)) {\n      textNode.remove();\n      return true;\n    }\n\n    textNode.data = textNode.data.replace(/\\n\\s*/g, '\\n');\n\n    if (textNode.data.includes(CARRIAGE_RETURN) || textNode.data.includes(LINE_FEED) || textNode.data.includes(NO_BREAK_SPACE)) {\n      const hasSpace = textNode.data.includes(SPACE);\n      const hasNonWhitespace = /\\S/.test(textNode.data);\n      const hasLineFeed = textNode.data.includes(LINE_FEED);\n\n      if (!(hasSpace || hasNonWhitespace) && !hasLineFeed) {\n        if (textNode.data === NO_BREAK_SPACE) {\n          textNode.data = SPACE;\n          return true;\n        }\n\n        textNode.remove();\n        return true;\n      }\n\n      if (textNode.previousSibling && textNode.previousSibling.nodeName === 'BR' && textNode.parentElement) {\n        textNode.parentElement.removeChild(textNode.previousSibling);\n        const matches = textNode.data.match(/^[\\r\\n]+/);\n        const offset = matches ? matches[0].length : 0;\n        textNode.data = textNode.data.substring(offset).replace(new RegExp(LINE_FEED, 'g'), SPACE).replace(new RegExp(CARRIAGE_RETURN, 'g'), SPACE);\n        textNode.data = `\\n${textNode.data}`;\n      } else {\n        textNode.data = textNode.data.replace(new RegExp(LINE_FEED, 'g'), SPACE).replace(new RegExp(CARRIAGE_RETURN, 'g'), SPACE);\n      }\n    }\n\n    return true;\n  });\n};\n\nconst DOCX_INDENT_STEP = 32;\n\nconst getDocxIndent = (element, indentStep = DOCX_INDENT_STEP) => {\n  const el = element;\n  const {\n    marginLeft\n  } = el.style;\n  const marginLeftNumber = parseInt(marginLeft, 10);\n  if (!marginLeftNumber) return 0;\n  return Math.round(marginLeftNumber / indentStep);\n};\n\nconst getTextListStyleType = text => {\n  var _text$match, _text$match2; // text.match(/^\\d+\\s*[-\\\\.)]?\\s+/)?.[0];\n\n\n  if ((_text$match = text.match(/^\\d+[\\\\.]/)) !== null && _text$match !== void 0 && _text$match[0]) {\n    return ListStyleType.Decimal;\n  }\n\n  if ((_text$match2 = text.match(/^[a-z]+\\./)) !== null && _text$match2 !== void 0 && _text$match2[0]) {\n    return ListStyleType.LowerAlpha;\n  }\n};\n/**\r\n * Check if the element contains docx content.\r\n * True if one element has:\r\n * - style including 'mso-'\r\n * - className including 'Mso'\r\n */\n\n\nconst isDocxContent = body => {\n  let result = false;\n  traverseHtmlElements(body, element => {\n    const styleAttribute = element.getAttribute('style') || '';\n    const classList = Array.from(element.classList);\n    const isMsoElement = styleAttribute.includes('mso-') || classList.some(className => className.startsWith('Mso'));\n    result = result || isMsoElement;\n    return !result;\n  });\n  return result;\n};\n/**\r\n * Trim the html and remove zero width spaces,\r\n * then wrap it with a body element.\r\n */\n\n\nconst postCleanHtml = html => {\n  const cleanHtml = html.trim().replace(new RegExp(ZERO_WIDTH_SPACE, 'g'), '');\n  return `<body>${cleanHtml}</body>`;\n};\n/**\r\n * Remove string before <html\r\n */\n\n\nconst removeBeforeHtml = html => {\n  const index = html.indexOf('<html');\n\n  if (index === -1) {\n    return html;\n  }\n\n  return html.substring(index);\n};\n/**\r\n * Remove string after </html>\r\n */\n\n\nconst removeAfterHtml = html => {\n  const index = html.lastIndexOf('</html>');\n\n  if (index === -1) {\n    return html;\n  }\n\n  return html.substring(0, index + '</html>'.length);\n};\n/**\r\n * Remove string before <html and after </html>\r\n */\n\n\nconst removeHtmlSurroundings = html => {\n  return removeBeforeHtml(removeAfterHtml(html));\n};\n\nconst cleaners = [removeHtmlSurroundings, cleanHtmlCrLf];\n/**\r\n * Remove HTML surroundings and clean HTML from CR/LF\r\n */\n\nconst preCleanHtml = html => {\n  return cleaners.reduce((result, clean) => clean(result), html);\n};\n\nconst cleanDocx = (html, rtf) => {\n  const document = new DOMParser().parseFromString(preCleanHtml(html), 'text/html');\n  const {\n    body\n  } = document;\n\n  if (!rtf && !isDocxContent(body)) {\n    return html;\n  }\n\n  cleanDocxFootnotes(body);\n  cleanDocxImageElements(document, rtf, body);\n  cleanHtmlEmptyElements(body);\n  cleanDocxEmptyParagraphs(body);\n  cleanDocxQuotes(body);\n  cleanDocxSpans(body);\n  cleanHtmlTextNodes(body);\n  cleanDocxBrComments(body);\n  cleanHtmlBrElements(body);\n  cleanHtmlLinkElements(body);\n  cleanHtmlFontElements(body);\n  cleanDocxListElements(body);\n  copyBlockMarksToSpanChild(body);\n  return postCleanHtml(body.innerHTML);\n};\n\nconst KEY_DESERIALIZE_DOCX = 'deserializeDocx';\n\nconst getListNode = type => element => {\n  const node = {\n    type\n  };\n\n  if (element.style.textAlign) {\n    node[KEY_ALIGN] = element.style.textAlign;\n  }\n\n  if (element.style.lineHeight) {\n    node.lineHeight = element.style.lineHeight;\n  }\n\n  if (isDocxList(element)) {\n    var _element$textContent, _getTextListStyleType;\n\n    node[KEY_INDENT] = getDocxListIndent(element);\n    const text = (_element$textContent = element.textContent) !== null && _element$textContent !== void 0 ? _element$textContent : '';\n    node[KEY_LIST_STYLE_TYPE] = (_getTextListStyleType = getTextListStyleType(text)) !== null && _getTextListStyleType !== void 0 ? _getTextListStyleType : ListStyleType.Disc;\n    element.innerHTML = getDocxListContentHtml(element);\n  } else {\n    const indent = getDocxIndent(element);\n\n    if (indent) {\n      node[KEY_INDENT] = indent;\n    }\n  }\n\n  return node;\n};\n\nconst createDeserializeDocxPlugin = createPluginFactory({\n  key: KEY_DESERIALIZE_DOCX,\n  inject: {\n    pluginsByKey: {\n      [KEY_DESERIALIZE_HTML]: {\n        editor: {\n          insertData: {\n            transformData: (data, {\n              dataTransfer\n            }) => {\n              const rtf = dataTransfer.getData('text/rtf');\n              return cleanDocx(data, rtf);\n            }\n          }\n        }\n      }\n    }\n  },\n  overrideByKey: {\n    [ELEMENT_PARAGRAPH]: {\n      then: (editor, {\n        type\n      }) => ({\n        deserializeHtml: {\n          query: el => {\n            return !el.classList.contains('SourceCode');\n          },\n          getNode: getListNode(type)\n        }\n      })\n    },\n    [ELEMENT_H1]: {\n      then: (editor, {\n        type\n      }) => ({\n        deserializeHtml: {\n          getNode: getListNode(type)\n        }\n      })\n    },\n    [ELEMENT_H2]: {\n      then: (editor, {\n        type\n      }) => ({\n        deserializeHtml: {\n          getNode: getListNode(type)\n        }\n      })\n    },\n    [ELEMENT_H3]: {\n      then: (editor, {\n        type\n      }) => ({\n        deserializeHtml: {\n          getNode: getListNode(type)\n        }\n      })\n    },\n    [ELEMENT_CODE_BLOCK]: {\n      deserializeHtml: [{\n        validNodeName: 'PRE',\n        ...deserializeHtmlCodeBlock\n      }, {\n        validClassName: 'SourceCode',\n        ...deserializeHtmlCodeBlock\n      }]\n    },\n    // [ELEMENT_TABLE]: {\n    //   deserializeHtml:\n    // },\n    [ELEMENT_IMAGE]: {\n      editor: {\n        insertData: {\n          query: ({\n            dataTransfer\n          }) => {\n            const data = dataTransfer.getData('text/html');\n            const {\n              body\n            } = new DOMParser().parseFromString(data, 'text/html');\n            return !isDocxContent(body);\n          }\n        }\n      }\n    },\n    [MARK_BOLD]: {\n      deserializeHtml: [{\n        validNodeName: ['STRONG', 'B'],\n        query: el => {\n          var _el$children$;\n\n          return !(((_el$children$ = el.children[0]) === null || _el$children$ === void 0 ? void 0 : _el$children$.style.fontWeight) === 'normal');\n        }\n      }, {\n        validStyle: {\n          fontWeight: ['600', '700', 'bold']\n        }\n      }]\n    },\n    [MARK_ITALIC]: {\n      deserializeHtml: [{\n        validNodeName: ['EM', 'I'],\n        query: el => {\n          var _el$children$2;\n\n          return !(el.nodeName === 'EM' && ((_el$children$2 = el.children[0]) === null || _el$children$2 === void 0 ? void 0 : _el$children$2.style.fontStyle) === 'normal');\n        }\n      }, {\n        validStyle: {\n          fontStyle: 'italic'\n        }\n      }]\n    }\n  }\n});\nexport { CARRIAGE_RETURN, KEY_DESERIALIZE_DOCX, LINE_FEED, NO_BREAK_SPACE, SPACE, TAB, ZERO_WIDTH_SPACE, cleanDocx, cleanDocxBrComments, cleanDocxEmptyParagraphs, cleanDocxFootnotes, cleanDocxImageElements, cleanDocxListElements, cleanDocxListElementsToList, cleanDocxQuotes, cleanDocxSpacerun, cleanDocxSpans, cleanDocxTabCount, cleanHtmlBrElements, cleanHtmlCrLf, cleanHtmlEmptyElements, cleanHtmlFontElements, cleanHtmlLinkElements, cleanHtmlTextNodes, copyBlockMarksToSpanChild, createDeserializeDocxPlugin, docxListToList, generateSpaces, generateTabs, getDocxIndent, getDocxListContentHtml, getDocxListIndent, getDocxListNode, getHtmlComments, getRtfImageHex, getRtfImageMimeType, getRtfImageSpid, getRtfImagesByType, getRtfImagesMap, getTextListStyleType, getVShapeSpid, getVShapes, hexToBase64, isDocxBookmark, isDocxContent, isDocxFootnote, isDocxList, isDocxOl, isHtmlBlockElement, isHtmlFragmentHref, isOlSymbol, postCleanHtml, preCleanHtml, removeHtmlNodesBetweenComments, removeHtmlSurroundings, replaceTagName, traverseHtmlComments, traverseHtmlElements, traverseHtmlNode, traverseHtmlTexts, unwrapHtmlElement };","map":{"version":3,"sources":["../src/docx-cleaner/utils/isHtmlBlockElement.ts","../src/docx-cleaner/utils/traverseHtmlNode.ts","../src/docx-cleaner/utils/traverseHtmlElements.ts","../src/docx-cleaner/utils/copyBlockMarksToSpanChild.ts","../src/docx-cleaner/utils/traverseHtmlComments.ts","../src/docx-cleaner/utils/removeHtmlNodesBetweenComments.ts","../src/docx-cleaner/utils/cleanDocxBrComments.ts","../src/docx-cleaner/constants.ts","../src/docx-cleaner/utils/cleanDocxEmptyParagraphs.ts","../src/docx-cleaner/utils/isDocxFootnote.ts","../src/docx-cleaner/utils/cleanDocxFootnotes.ts","../../../../node_modules/validator/lib/util/assertString.js","../../../../node_modules/validator/lib/util/merge.js","../../../../node_modules/validator/lib/isFQDN.js","../../../../node_modules/validator/lib/isIP.js","../../../../node_modules/validator/lib/isURL.js","../src/docx-cleaner/utils/getRtfImageHex.ts","../src/docx-cleaner/utils/getRtfImageMimeType.ts","../src/docx-cleaner/utils/getRtfImageSpid.ts","../src/docx-cleaner/utils/getRtfImagesByType.ts","../src/docx-cleaner/utils/getRtfImagesMap.ts","../src/docx-cleaner/utils/getHtmlComments.ts","../src/docx-cleaner/utils/getVShapes.ts","../src/docx-cleaner/utils/getVShapeSpid.ts","../src/docx-cleaner/utils/hexToBase64.ts","../src/docx-cleaner/utils/cleanDocxImageElements.ts","../src/docx-cleaner/utils/cleanDocxListElements.ts","../src/docx-cleaner/utils/getDocxListContentHtml.ts","../src/docx-cleaner/utils/getDocxListIndent.ts","../src/docx-cleaner/utils/isDocxBookmark.ts","../src/docx-cleaner/utils/isDocxList.ts","../src/docx-cleaner/utils/getDocxListNode.ts","../src/docx-cleaner/utils/isOlSymbol.ts","../src/docx-cleaner/utils/isDocxOl.ts","../src/docx-cleaner/utils/docxListToList.ts","../src/docx-cleaner/utils/cleanDocxListElementsToList.ts","../src/docx-cleaner/utils/replaceTagName.ts","../src/docx-cleaner/utils/cleanDocxQuotes.ts","../src/docx-cleaner/utils/generateSpaces.ts","../src/docx-cleaner/utils/cleanDocxSpacerun.ts","../src/docx-cleaner/utils/cleanDocxTabCount.ts","../src/docx-cleaner/utils/cleanDocxSpans.ts","../src/docx-cleaner/utils/cleanHtmlBrElements.ts","../src/docx-cleaner/utils/cleanHtmlCrLf.ts","../src/docx-cleaner/utils/cleanHtmlEmptyElements.ts","../src/docx-cleaner/utils/cleanHtmlFontElements.ts","../src/docx-cleaner/utils/isHtmlFragmentHref.ts","../src/docx-cleaner/utils/unwrapHtmlElement.ts","../src/docx-cleaner/utils/cleanHtmlLinkElements.ts","../src/docx-cleaner/utils/traverseHtmlTexts.ts","../src/docx-cleaner/utils/cleanHtmlTextNodes.ts","../src/docx-cleaner/utils/getDocxIndent.ts","../src/docx-cleaner/utils/getTextListStyleType.ts","../src/docx-cleaner/utils/isDocxContent.ts","../src/docx-cleaner/utils/postCleanHtml.ts","../src/docx-cleaner/utils/removeHtmlSurroundings.ts","../src/docx-cleaner/utils/preCleanHtml.ts","../src/docx-cleaner/cleanDocx.ts","../src/deserializer/createDeserializeDocxPlugin.ts"],"names":["isHtmlBlockElement","element","blockRegex","traverseHtmlNode","keepTraversing","callback","child","node","currentChild","previousChild","traverseHtmlElements","isHtmlElement","copyBlockMarksToSpanChild","rootNode","el","styleAttribute","style","textDecoration","backgroundColor","span","document","traverseHtmlComments","isHtmlComment","removeHtmlNodesBetweenComments","isClosingComment","comment","nextSibling","cleanDocxBrComments","CARRIAGE_RETURN","LINE_FEED","NO_BREAK_SPACE","SPACE","TAB","ZERO_WIDTH_SPACE","isHtmlOpEmpty","isHtmlElementEmpty","cleanDocxEmptyParagraphs","isDocxFootnote","extractFootnoteNumber","footnote","cleanDocxFootnotes","footnoteReplacement","require$$0","require$$1","require$$2","require$$3","getRtfImageHex","imageData","bliptagData","bracketSplit","beforeBracket","afterBracket","spaceSplit","getRtfImageMimeType","bliptagMeta","END_OF_ID_SEQUENCE_CHARACTERS","getRtfImageSpid","indexes","character","foundIndexes","index","idLength","Math","id","spidPrefix","getRtfImagesByType","rtf","image","spid","mimeType","hex","rtfImages","getRtfImagesMap","rtfImagesMap","shppictRtfImages","shppictRtfImage","shpRtfImages","shpRtfImage","acceptNode","NodeFilter","getHtmlComments","comments","iterator","currentNode","getVShapes","xmlDocument","vShapes","Array","vShape","vShapesMap","normalizeSpid","getVShapeSpid","vShapeId","vShapeSpid","hexToBase64","hexPairs","binary","hexPair","String","parseInt","btoa","cleanDocxImageElements","src","alt","isURL","require_protocol","rtfImage","dataUri","imageElement","cleanDocxListElements","getDocxListContentHtml","rootElement","clonedElement","getDocxListIndent","matches","isDocxBookmark","isDocxList","hasMsoListInStyle","hasMsoListIgnoreChild","Boolean","getDocxListNode","isOlSymbol","symbol","isDocxOl","listNode","docxListToList","listLevel","listHtml","nextListLevel","nestedList","currentElement","listTagName","list","parseHtmlElement","cleanDocxListElementsToList","previousSibling","beforeElement","parentElement","replaceTagName","newElement","name","value","cleanDocxQuotes","generateSpaces","count","length","generateTabs","cleanDocxSpacerun","spacesCount","replacementNode","cleanDocxTabCount","cleanDocxSpans","cleanHtmlBrElements","replacementTextNode","cleanHtmlCrLf","html","ALLOWED_EMPTY_ELEMENTS","isEmpty","removeIfEmpty","cleanHtmlEmptyElements","cleanHtmlFontElements","isHtmlFragmentHref","href","unwrapHtmlElement","cleanHtmlLinkElements","traverseHtmlTexts","isHtmlText","cleanHtmlTextNodes","textNode","hasSpace","hasNonWhitespace","hasLineFeed","offset","data","DOCX_INDENT_STEP","getDocxIndent","indentStep","marginLeft","marginLeftNumber","getTextListStyleType","text","ListStyleType","isDocxContent","body","result","classList","isMsoElement","className","postCleanHtml","cleanHtml","removeBeforeHtml","removeAfterHtml","removeHtmlSurroundings","cleaners","preCleanHtml","clean","cleanDocx","KEY_DESERIALIZE_DOCX","getListNode","type","indent","createDeserializeDocxPlugin","createPluginFactory","key","inject","pluginsByKey","editor","insertData","transformData","dataTransfer","overrideByKey","then","deserializeHtml","query","getNode","validNodeName","deserializeHtmlCodeBlock","validClassName","validStyle","fontWeight","fontStyle"],"mappings":"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","sourcesContent":["/**\n * Is the element a block element?\n */\nexport const isHtmlBlockElement = (element: Element) => {\n  const blockRegex = /^(address|blockquote|body|center|dir|div|dl|fieldset|form|h[1-6]|hr|isindex|menu|noframes|noscript|ol|p|pre|table|ul|dd|dt|frameset|li|tbody|td|tfoot|th|thead|tr|html)$/i;\n\n  return blockRegex.test(element.nodeName);\n};\n","type Callback = (node: Node) => boolean;\n\n/**\n * Depth-first pre-order tree traverse the given HTML node and calls the given callback for each node.\n * see: https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)\n *\n * @param callback returns a boolean indicating whether traversal should be continued\n */\nexport const traverseHtmlNode = (node: Node, callback: Callback): void => {\n  const keepTraversing = callback(node);\n\n  if (!keepTraversing) {\n    return;\n  }\n\n  let child = node.firstChild;\n\n  while (child) {\n    const currentChild = child;\n    const previousChild = child.previousSibling;\n    child = child.nextSibling;\n\n    traverseHtmlNode(currentChild, callback);\n\n    if (\n      // An unwrap was made. Need to compute the next child again.\n      !currentChild.previousSibling &&\n      !currentChild.nextSibling &&\n      !currentChild.parentNode &&\n      child &&\n      previousChild !== child.previousSibling &&\n      child.parentNode\n    ) {\n      if (previousChild) {\n        child = previousChild.nextSibling;\n      } else {\n        child = node.firstChild;\n      }\n    } else if (\n      // A list was created. Need to compute the next child again.\n      !currentChild.previousSibling &&\n      !currentChild.nextSibling &&\n      !currentChild.parentNode &&\n      child &&\n      !child.previousSibling &&\n      !child.nextSibling &&\n      !child.parentNode\n    ) {\n      if (previousChild) {\n        if (previousChild.nextSibling) {\n          child = previousChild.nextSibling.nextSibling;\n        } else {\n          child = null;\n        }\n      } else if (node.firstChild) {\n        child = node.firstChild.nextSibling;\n      }\n    }\n  }\n};\n","import { isHtmlElement } from '@udecode/plate-core';\nimport { traverseHtmlNode } from './traverseHtmlNode';\n\ntype Callback = (node: Element) => boolean;\n\n/**\n * Traverse the HTML elements of the given HTML node.\n * @param rootNode The root HTML node to traverse.\n * @param callback The callback to call for each HTML element.\n */\nexport const traverseHtmlElements = (\n  rootNode: Node,\n  callback: Callback\n): void => {\n  traverseHtmlNode(rootNode, (node) => {\n    if (!isHtmlElement(node)) {\n      return true;\n    }\n\n    return callback(node);\n  });\n};\n","import { isHtmlBlockElement } from './isHtmlBlockElement';\nimport { traverseHtmlElements } from './traverseHtmlElements';\n\n/**\n * Set HTML blocks mark styles to a new child span element if any.\n * This allows Plate to use block marks.\n */\nexport const copyBlockMarksToSpanChild = (rootNode: Node) => {\n  traverseHtmlElements(rootNode, (element) => {\n    const el = element as HTMLElement;\n\n    const styleAttribute = element.getAttribute('style');\n    if (!styleAttribute) return true;\n\n    if (isHtmlBlockElement(el)) {\n      const {\n        style: {\n          backgroundColor,\n          color,\n          fontFamily,\n          fontSize,\n          fontStyle,\n          fontWeight,\n          textDecoration,\n        },\n      } = el;\n\n      if (\n        backgroundColor ||\n        color ||\n        fontFamily ||\n        fontSize ||\n        fontStyle ||\n        fontWeight ||\n        textDecoration\n      ) {\n        const span = document.createElement('span');\n        if (!['initial', 'inherit'].includes(color)) {\n          span.style.color = color;\n        }\n        span.style.fontFamily = fontFamily;\n        span.style.fontSize = fontSize;\n        if (!['normal', 'initial', 'inherit'].includes(color)) {\n          span.style.fontStyle = fontStyle;\n        }\n        if (!['normal', 400].includes(fontWeight)) {\n          span.style.fontWeight = fontWeight;\n        }\n        span.style.textDecoration = textDecoration;\n\n        span.innerHTML = el.innerHTML;\n        element.innerHTML = span.outerHTML;\n      }\n    }\n    return true;\n  });\n};\n","import { isHtmlComment } from '@udecode/plate-core';\nimport { traverseHtmlNode } from './traverseHtmlNode';\n\ntype Callback = (node: Comment) => boolean;\n\n/**\n * Traverse HTML comments.\n */\nexport const traverseHtmlComments = (\n  rootNode: Node,\n  callback: Callback\n): void => {\n  traverseHtmlNode(rootNode, (node) => {\n    if (!isHtmlComment(node)) {\n      return true;\n    }\n\n    return callback(node);\n  });\n};\n","import { isHtmlComment } from '@udecode/plate-core';\nimport { traverseHtmlComments } from './traverseHtmlComments';\n\n/**\n * Removes HTML nodes between HTML comments.\n */\nexport const removeHtmlNodesBetweenComments = (\n  rootNode: Node,\n  start: string,\n  end: string\n): void => {\n  const isClosingComment = (node: Node) =>\n    isHtmlComment(node) && node.data === end;\n\n  traverseHtmlComments(rootNode, (comment) => {\n    if (comment.data === start) {\n      let node = comment.nextSibling;\n\n      comment.remove();\n\n      while (node && !isClosingComment(node)) {\n        const { nextSibling } = node;\n        node.remove();\n        node = nextSibling;\n      }\n\n      if (node && isClosingComment(node)) {\n        node.remove();\n      }\n    }\n\n    return true;\n  });\n};\n","import { isHtmlComment } from '@udecode/plate-core';\nimport { removeHtmlNodesBetweenComments } from './removeHtmlNodesBetweenComments';\nimport { traverseHtmlElements } from './traverseHtmlElements';\n\n/**\n * Remove HTML nodes between comments in the next sibling after BR.\n */\nexport const cleanDocxBrComments = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.tagName !== 'BR') {\n      return true;\n    }\n\n    if (\n      element.nextSibling &&\n      isHtmlComment(element.nextSibling) &&\n      element.nextSibling.data === '[if !supportLineBreakNewLine]'\n    ) {\n      removeHtmlNodesBetweenComments(\n        element.nextSibling,\n        '[if !supportLineBreakNewLine]',\n        '[endif]'\n      );\n    }\n\n    return false;\n  });\n};\n","export const CARRIAGE_RETURN = '\\u000D';\nexport const LINE_FEED = '\\u000A';\nexport const NO_BREAK_SPACE = '\\u00A0';\nexport const SPACE = '\\u0020';\nexport const TAB = '\\u0009';\nexport const ZERO_WIDTH_SPACE = '\\u200B';\n","import { NO_BREAK_SPACE } from '../constants';\nimport { traverseHtmlElements } from './traverseHtmlElements';\n\nconst isHtmlOpEmpty = (element: Element): boolean =>\n  element.nodeName === 'O:P' && element.textContent === NO_BREAK_SPACE;\n\nconst isHtmlElementEmpty = (element: Element): boolean =>\n  element.children.length === 1 &&\n  element.firstElementChild !== null &&\n  (isHtmlOpEmpty(element.firstElementChild) ||\n    isHtmlElementEmpty(element.firstElementChild));\n\n/**\n * Remove paragraph innerHTML if its child is 'O:P' with NO_BREAK_SPACE.\n */\nexport const cleanDocxEmptyParagraphs = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.tagName === 'P' && isHtmlElementEmpty(element)) {\n      element.innerHTML = '';\n    }\n\n    return true;\n  });\n};\n","/**\n * Is element a docx footnote.\n */\nexport const isDocxFootnote = (element: Element): boolean => {\n  return (\n    element.tagName === 'SPAN' &&\n    element.classList.contains('MsoFootnoteReference')\n  );\n};\n","import { isDocxFootnote } from './isDocxFootnote';\nimport { traverseHtmlElements } from './traverseHtmlElements';\n\n/**\n * Gets \"4\" from \"[4]\", \"A\" from \"[A]\", etc.\n */\nconst extractFootnoteNumber = (footnote: Element): string => {\n  return (footnote.textContent || '').trim().replace(/[[\\]]/g, '');\n};\n\n/**\n * Replace docx footnotes with sup element.\n */\nexport const cleanDocxFootnotes = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (isDocxFootnote(element)) {\n      const footnoteReplacement = document.createElement('sup');\n      footnoteReplacement.textContent = extractFootnoteNumber(element);\n\n      if (element.parentElement) {\n        element.parentElement.replaceChild(footnoteReplacement, element);\n      }\n\n      return true;\n    }\n\n    return true;\n  });\n};\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = assertString;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction assertString(input) {\n  var isString = typeof input === 'string' || input instanceof String;\n\n  if (!isString) {\n    var invalidType = _typeof(input);\n\n    if (input === null) invalidType = 'null';else if (invalidType === 'object') invalidType = input.constructor.name;\n    throw new TypeError(\"Expected a string but received a \".concat(invalidType));\n  }\n}\n\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = merge;\n\nfunction merge() {\n  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var defaults = arguments.length > 1 ? arguments[1] : undefined;\n\n  for (var key in defaults) {\n    if (typeof obj[key] === 'undefined') {\n      obj[key] = defaults[key];\n    }\n  }\n\n  return obj;\n}\n\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isFQDN;\n\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\n\nvar _merge = _interopRequireDefault(require(\"./util/merge\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar default_fqdn_options = {\n  require_tld: true,\n  allow_underscores: false,\n  allow_trailing_dot: false,\n  allow_numeric_tld: false,\n  allow_wildcard: false\n};\n\nfunction isFQDN(str, options) {\n  (0, _assertString.default)(str);\n  options = (0, _merge.default)(options, default_fqdn_options);\n  /* Remove the optional trailing dot before checking validity */\n\n  if (options.allow_trailing_dot && str[str.length - 1] === '.') {\n    str = str.substring(0, str.length - 1);\n  }\n  /* Remove the optional wildcard before checking validity */\n\n\n  if (options.allow_wildcard === true && str.indexOf('*.') === 0) {\n    str = str.substring(2);\n  }\n\n  var parts = str.split('.');\n  var tld = parts[parts.length - 1];\n\n  if (options.require_tld) {\n    // disallow fqdns without tld\n    if (parts.length < 2) {\n      return false;\n    }\n\n    if (!/^([a-z\\u00A1-\\u00A8\\u00AA-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {\n      return false;\n    } // disallow spaces\n\n\n    if (/\\s/.test(tld)) {\n      return false;\n    }\n  } // reject numeric TLDs\n\n\n  if (!options.allow_numeric_tld && /^\\d+$/.test(tld)) {\n    return false;\n  }\n\n  return parts.every(function (part) {\n    if (part.length > 63) {\n      return false;\n    }\n\n    if (!/^[a-z_\\u00a1-\\uffff0-9-]+$/i.test(part)) {\n      return false;\n    } // disallow full-width chars\n\n\n    if (/[\\uff01-\\uff5e]/.test(part)) {\n      return false;\n    } // disallow parts starting or ending with hyphen\n\n\n    if (/^-|-$/.test(part)) {\n      return false;\n    }\n\n    if (!options.allow_underscores && /_/.test(part)) {\n      return false;\n    }\n\n    return true;\n  });\n}\n\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isIP;\n\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n11.3.  Examples\n\n   The following addresses\n\n             fe80::1234 (on the 1st link of the node)\n             ff02::5678 (on the 5th link of the node)\n             ff08::9abc (on the 10th organization of the node)\n\n   would be represented as follows:\n\n             fe80::1234%1\n             ff02::5678%5\n             ff08::9abc%10\n\n   (Here we assume a natural translation from a zone index to the\n   <zone_id> part, where the Nth zone of any scope is translated into\n   \"N\".)\n\n   If we use interface names as <zone_id>, those addresses could also be\n   represented as follows:\n\n            fe80::1234%ne0\n            ff02::5678%pvc1.3\n            ff08::9abc%interface10\n\n   where the interface \"ne0\" belongs to the 1st link, \"pvc1.3\" belongs\n   to the 5th link, and \"interface10\" belongs to the 10th organization.\n * * */\nvar IPv4SegmentFormat = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';\nvar IPv4AddressFormat = \"(\".concat(IPv4SegmentFormat, \"[.]){3}\").concat(IPv4SegmentFormat);\nvar IPv4AddressRegExp = new RegExp(\"^\".concat(IPv4AddressFormat, \"$\"));\nvar IPv6SegmentFormat = '(?:[0-9a-fA-F]{1,4})';\nvar IPv6AddressRegExp = new RegExp('^(' + \"(?:\".concat(IPv6SegmentFormat, \":){7}(?:\").concat(IPv6SegmentFormat, \"|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){6}(?:\").concat(IPv4AddressFormat, \"|:\").concat(IPv6SegmentFormat, \"|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){5}(?::\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,2}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){4}(?:(:\").concat(IPv6SegmentFormat, \"){0,1}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,3}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){3}(?:(:\").concat(IPv6SegmentFormat, \"){0,2}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,4}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){2}(?:(:\").concat(IPv6SegmentFormat, \"){0,3}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,5}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){1}(?:(:\").concat(IPv6SegmentFormat, \"){0,4}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,6}|:)|\") + \"(?::((?::\".concat(IPv6SegmentFormat, \"){0,5}:\").concat(IPv4AddressFormat, \"|(?::\").concat(IPv6SegmentFormat, \"){1,7}|:))\") + ')(%[0-9a-zA-Z-.:]{1,})?$');\n\nfunction isIP(str) {\n  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  (0, _assertString.default)(str);\n  version = String(version);\n\n  if (!version) {\n    return isIP(str, 4) || isIP(str, 6);\n  }\n\n  if (version === '4') {\n    if (!IPv4AddressRegExp.test(str)) {\n      return false;\n    }\n\n    var parts = str.split('.').sort(function (a, b) {\n      return a - b;\n    });\n    return parts[3] <= 255;\n  }\n\n  if (version === '6') {\n    return !!IPv6AddressRegExp.test(str);\n  }\n\n  return false;\n}\n\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isURL;\n\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\n\nvar _isFQDN = _interopRequireDefault(require(\"./isFQDN\"));\n\nvar _isIP = _interopRequireDefault(require(\"./isIP\"));\n\nvar _merge = _interopRequireDefault(require(\"./util/merge\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/*\noptions for isURL method\n\nrequire_protocol - if set as true isURL will return false if protocol is not present in the URL\nrequire_valid_protocol - isURL will check if the URL's protocol is present in the protocols option\nprotocols - valid protocols can be modified with this option\nrequire_host - if set as false isURL will not check if host is present in the URL\nrequire_port - if set as true isURL will check if port is present in the URL\nallow_protocol_relative_urls - if set as true protocol relative URLs will be allowed\nvalidate_length - if set as false isURL will skip string length validation (IE maximum is 2083)\n\n*/\nvar default_url_options = {\n  protocols: ['http', 'https', 'ftp'],\n  require_tld: true,\n  require_protocol: false,\n  require_host: true,\n  require_port: false,\n  require_valid_protocol: true,\n  allow_underscores: false,\n  allow_trailing_dot: false,\n  allow_protocol_relative_urls: false,\n  allow_fragments: true,\n  allow_query_components: true,\n  validate_length: true\n};\nvar wrapped_ipv6 = /^\\[([^\\]]+)\\](?::([0-9]+))?$/;\n\nfunction isRegExp(obj) {\n  return Object.prototype.toString.call(obj) === '[object RegExp]';\n}\n\nfunction checkHost(host, matches) {\n  for (var i = 0; i < matches.length; i++) {\n    var match = matches[i];\n\n    if (host === match || isRegExp(match) && match.test(host)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isURL(url, options) {\n  (0, _assertString.default)(url);\n\n  if (!url || /[\\s<>]/.test(url)) {\n    return false;\n  }\n\n  if (url.indexOf('mailto:') === 0) {\n    return false;\n  }\n\n  options = (0, _merge.default)(options, default_url_options);\n\n  if (options.validate_length && url.length >= 2083) {\n    return false;\n  }\n\n  if (!options.allow_fragments && url.includes('#')) {\n    return false;\n  }\n\n  if (!options.allow_query_components && (url.includes('?') || url.includes('&'))) {\n    return false;\n  }\n\n  var protocol, auth, host, hostname, port, port_str, split, ipv6;\n  split = url.split('#');\n  url = split.shift();\n  split = url.split('?');\n  url = split.shift();\n  split = url.split('://');\n\n  if (split.length > 1) {\n    protocol = split.shift().toLowerCase();\n\n    if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {\n      return false;\n    }\n  } else if (options.require_protocol) {\n    return false;\n  } else if (url.substr(0, 2) === '//') {\n    if (!options.allow_protocol_relative_urls) {\n      return false;\n    }\n\n    split[0] = url.substr(2);\n  }\n\n  url = split.join('://');\n\n  if (url === '') {\n    return false;\n  }\n\n  split = url.split('/');\n  url = split.shift();\n\n  if (url === '' && !options.require_host) {\n    return true;\n  }\n\n  split = url.split('@');\n\n  if (split.length > 1) {\n    if (options.disallow_auth) {\n      return false;\n    }\n\n    if (split[0] === '') {\n      return false;\n    }\n\n    auth = split.shift();\n\n    if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {\n      return false;\n    }\n\n    var _auth$split = auth.split(':'),\n        _auth$split2 = _slicedToArray(_auth$split, 2),\n        user = _auth$split2[0],\n        password = _auth$split2[1];\n\n    if (user === '' && password === '') {\n      return false;\n    }\n  }\n\n  hostname = split.join('@');\n  port_str = null;\n  ipv6 = null;\n  var ipv6_match = hostname.match(wrapped_ipv6);\n\n  if (ipv6_match) {\n    host = '';\n    ipv6 = ipv6_match[1];\n    port_str = ipv6_match[2] || null;\n  } else {\n    split = hostname.split(':');\n    host = split.shift();\n\n    if (split.length) {\n      port_str = split.join(':');\n    }\n  }\n\n  if (port_str !== null && port_str.length > 0) {\n    port = parseInt(port_str, 10);\n\n    if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {\n      return false;\n    }\n  } else if (options.require_port) {\n    return false;\n  }\n\n  if (options.host_whitelist) {\n    return checkHost(host, options.host_whitelist);\n  }\n\n  if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {\n    return false;\n  }\n\n  host = host || ipv6;\n\n  if (options.host_blacklist && checkHost(host, options.host_blacklist)) {\n    return false;\n  }\n\n  return true;\n}\n\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","import { SPACE } from '../constants';\n\nexport const getRtfImageHex = (imageData: string): string | null => {\n  const [, bliptagData = ''] = imageData.split('bliptag');\n  const bracketSplit = bliptagData.split('}');\n\n  if (bracketSplit.length < 2) {\n    return null;\n  }\n\n  const [beforeBracket, afterBracket] = bracketSplit;\n\n  if (bracketSplit.length > 2 && beforeBracket.includes('blipuid')) {\n    return afterBracket.split(SPACE).join('');\n  }\n\n  const spaceSplit = beforeBracket.split(SPACE);\n\n  if (spaceSplit.length < 2) {\n    return null;\n  }\n\n  return spaceSplit.slice(1).join('');\n};\n","export const getRtfImageMimeType = (imageData: string): string | null => {\n  const [bliptagMeta] = imageData.split('bliptag');\n\n  if (bliptagMeta.includes('pngblip')) {\n    return 'image/png';\n  }\n\n  if (bliptagMeta.includes('jpegblip')) {\n    return 'image/jpeg';\n  }\n\n  return null;\n};\n","import { CARRIAGE_RETURN, LINE_FEED, SPACE } from '../constants';\n\nconst END_OF_ID_SEQUENCE_CHARACTERS = [\n  '\\\\',\n  '{',\n  CARRIAGE_RETURN,\n  LINE_FEED,\n  SPACE,\n];\n\nexport const getRtfImageSpid = (\n  imageData: string,\n  spidPrefix: string\n): string | null => {\n  const indexes = END_OF_ID_SEQUENCE_CHARACTERS.map((character) =>\n    imageData.indexOf(character)\n  );\n  const foundIndexes = indexes.filter((index) => index !== -1);\n  const idLength = Math.min(imageData.length, ...foundIndexes);\n  const id = imageData.substring(0, idLength);\n  return id ? `${spidPrefix}${id}` : null;\n};\n","import { RtfImage } from '../types';\nimport { getRtfImageHex } from './getRtfImageHex';\nimport { getRtfImageMimeType } from './getRtfImageMimeType';\nimport { getRtfImageSpid } from './getRtfImageSpid';\n\nexport const getRtfImagesByType = (\n  rtf: string,\n  spidPrefix: string,\n  type: string\n): RtfImage[] => {\n  const [, ...images] = rtf.split(type);\n\n  return images.reduce<RtfImage[]>((rtfImages, image) => {\n    const [, imageData = ''] = image.split('shplid');\n    const spid = getRtfImageSpid(imageData, spidPrefix);\n    const mimeType = getRtfImageMimeType(imageData);\n    const hex = getRtfImageHex(imageData);\n\n    if (spid && mimeType && hex) {\n      rtfImages.push({ hex, mimeType, spid });\n    }\n\n    return rtfImages;\n  }, []);\n};\n","import { RtfImagesMap } from '../types';\nimport { getRtfImagesByType } from './getRtfImagesByType';\n\nexport const getRtfImagesMap = (rtf: string): RtfImagesMap => {\n  const rtfImagesMap: RtfImagesMap = {};\n\n  const shppictRtfImages = getRtfImagesByType(rtf, 'i', '\\\\shppict');\n  for (const shppictRtfImage of shppictRtfImages) {\n    rtfImagesMap[shppictRtfImage.spid] = shppictRtfImage;\n  }\n\n  const shpRtfImages = getRtfImagesByType(rtf, 's', '\\\\shp');\n  for (const shpRtfImage of shpRtfImages) {\n    rtfImagesMap[shpRtfImage.spid] = shpRtfImage;\n  }\n\n  return rtfImagesMap;\n};\n","const acceptNode = () => NodeFilter.FILTER_ACCEPT;\n\nexport const getHtmlComments = (node: Node): string[] => {\n  const comments: string[] = [];\n  const iterator = document.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {\n    acceptNode,\n  });\n  let currentNode = iterator.nextNode();\n\n  while (currentNode) {\n    if (currentNode.nodeValue) {\n      comments.push(currentNode.nodeValue);\n    }\n\n    currentNode = iterator.nextNode();\n  }\n\n  return comments;\n};\n","import { getHtmlComments } from './getHtmlComments';\n\nexport const getVShapes = (document: Document): Record<string, string> => {\n  const comments = getHtmlComments(document);\n\n  return comments.reduce<Record<string, string>>((vShapesMap, comment) => {\n    try {\n      const xmlDocument = new DOMParser().parseFromString(comment, 'text/html');\n      const vShapes = Array.from(xmlDocument.getElementsByTagName('V:SHAPE'));\n\n      vShapes.forEach((vShape) => {\n        const { id } = vShape;\n        const spid = vShape.getAttribute('o:spid');\n\n        if (typeof id === 'string' && typeof spid === 'string') {\n          vShapesMap[id] = spid;\n        }\n      });\n    } catch (error) {\n      // Cannot parse as XML, we're not interested in this comment\n    }\n\n    return vShapesMap;\n  }, {});\n};\n","import { getVShapes } from './getVShapes';\n\nconst normalizeSpid = (spid: string): string => {\n  const [, , id] = spid.split('_');\n  return id;\n};\n\nexport const getVShapeSpid = (\n  document: Document,\n  element: Element\n): string | null => {\n  if (element.tagName === 'IMG') {\n    const vShapeId = element.getAttribute('v:shapes');\n    const vShapes = getVShapes(document);\n\n    if (!vShapeId) {\n      return null;\n    }\n\n    const vShapeSpid = vShapes[vShapeId];\n\n    if (vShapeSpid) {\n      return normalizeSpid(vShapeSpid);\n    }\n\n    if (\n      element.parentElement &&\n      element.parentElement.parentElement &&\n      element.parentElement.parentElement.innerHTML.indexOf('msEquation') >= 0\n    ) {\n      return null;\n    }\n\n    return normalizeSpid(vShapeId);\n  }\n\n  if (!element.parentElement) {\n    return null;\n  }\n\n  const spid = element.parentElement.getAttribute('o:spid');\n\n  if (spid) {\n    return normalizeSpid(spid);\n  }\n\n  return spid;\n};\n","export const hexToBase64 = (hex: string): string => {\n  const hexPairs = hex.match(/\\w{2}/g) || [];\n  const binary = hexPairs.map((hexPair) =>\n    String.fromCharCode(parseInt(hexPair, 16))\n  );\n  return btoa(binary.join(''));\n};\n","import isURL from 'validator/lib/isURL';\nimport { getRtfImagesMap } from './getRtfImagesMap';\nimport { getVShapeSpid } from './getVShapeSpid';\nimport { hexToBase64 } from './hexToBase64';\nimport { traverseHtmlElements } from './traverseHtmlElements';\n\n/**\n * Clean docx image elements.\n */\nexport const cleanDocxImageElements = (\n  document: Document,\n  rtf: string,\n  rootNode: Node\n): void => {\n  if (!rtf) {\n    return;\n  }\n\n  traverseHtmlElements(rootNode, (element) => {\n    if (!['IMG', 'V:IMAGEDATA'].includes(element.tagName)) {\n      return true;\n    }\n\n    if (element.tagName === 'IMG') {\n      const src = element.getAttribute('src');\n\n      if (!src || !src.startsWith('file://')) {\n        return true;\n      }\n\n      const alt = element.getAttribute('alt');\n\n      if (typeof alt === 'string' && isURL(alt, { require_protocol: true })) {\n        element.setAttribute('src', alt);\n        return true;\n      }\n    }\n\n    const vShapeSpid = getVShapeSpid(document, element);\n\n    if (!vShapeSpid) {\n      return true;\n    }\n\n    const rtfImagesMap = getRtfImagesMap(rtf);\n    const rtfImage = rtfImagesMap[vShapeSpid];\n\n    if (!rtfImage) {\n      // We fould some kind of vshape (perhaps a drawing) that we don't know\n      // how to recover from RTF. So we just skip it.\n      element.remove();\n      return true;\n    }\n\n    const dataUri = `data:${rtfImage.mimeType};base64,${hexToBase64(\n      rtfImage.hex\n    )}`;\n\n    if (element.tagName === 'IMG') {\n      element.setAttribute('src', dataUri);\n    } else if (element.parentNode && element.parentNode.parentNode) {\n      const imageElement = document.createElement('img');\n      imageElement.setAttribute('src', dataUri);\n      element.parentNode.parentNode.replaceChild(\n        imageElement,\n        element.parentNode\n      );\n    }\n    return true;\n  });\n};\n","import { traverseHtmlElements } from './traverseHtmlElements';\n\n/**\n * Clean elements style mso-list to mso-list:Ignore\n */\nexport const cleanDocxListElements = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    const styleAttribute = element.getAttribute('style');\n\n    if (styleAttribute) {\n      element.setAttribute(\n        'style',\n        styleAttribute.replace(/mso-list:\\s*Ignore/gim, 'mso-list:Ignore')\n      );\n    }\n\n    return true;\n  });\n};\n","import { removeHtmlNodesBetweenComments } from './removeHtmlNodesBetweenComments';\nimport { traverseHtmlElements } from './traverseHtmlElements';\n\nexport const getDocxListContentHtml = (rootElement: Element): string => {\n  const clonedElement = rootElement.cloneNode(true) as Element;\n\n  removeHtmlNodesBetweenComments(\n    clonedElement,\n    '[if !supportLists]',\n    '[endif]'\n  );\n\n  traverseHtmlElements(clonedElement, (element) => {\n    const styleAttribute = element.getAttribute('style');\n\n    if (styleAttribute === 'mso-list:Ignore') {\n      element.remove();\n    }\n\n    return true;\n  });\n\n  return clonedElement.innerHTML;\n};\n","export const getDocxListIndent = (element: Element): number => {\n  const styleAttribute = element.getAttribute('style') || '';\n  const matches = styleAttribute.match(/level(\\d+)/im);\n\n  if (matches && matches.length >= 1) {\n    const [, level] = matches;\n    return parseInt(level, 10);\n  }\n\n  return 1;\n};\n","export const isDocxBookmark = (element: Element): boolean => {\n  const styleAttribute = element.getAttribute('style');\n  return (\n    (styleAttribute || '').startsWith('mso-bookmark') && !element.textContent\n  );\n};\n","export const isDocxList = (element: Element): boolean => {\n  const styleAttribute = element.getAttribute('style');\n\n  if (!styleAttribute) {\n    return false;\n  }\n\n  const hasMsoListInStyle = /mso-list:\\s*l/gim.test(styleAttribute);\n\n  if (!hasMsoListInStyle) {\n    return false;\n  }\n\n  const hasMsoListIgnoreChild = Boolean(\n    element.querySelector('[style=\"mso-list:Ignore\"]')\n  );\n\n  if (hasMsoListIgnoreChild) {\n    return true;\n  }\n\n  return element.outerHTML.includes('<!--[if !supportLists]-->');\n};\n","export const getDocxListNode = (element: Element): Node | null => {\n  return (\n    element.querySelector('[style=\"mso-list:Ignore\"]') ||\n    element.querySelector('span[lang]')\n  );\n};\n","export const isOlSymbol = (symbol: string): boolean => {\n  return /[0-9a-np-z]\\S/g.test(symbol.toLowerCase());\n};\n","import { getDocxListNode } from './getDocxListNode';\nimport { isOlSymbol } from './isOlSymbol';\n\nexport const isDocxOl = (element: Element): boolean => {\n  const listNode = getDocxListNode(element);\n\n  if (!listNode) {\n    return false;\n  }\n\n  return isOlSymbol(listNode.textContent || '');\n};\n","import { parseHtmlElement } from '@udecode/plate-core';\nimport { getDocxListContentHtml } from './getDocxListContentHtml';\nimport { getDocxListIndent } from './getDocxListIndent';\nimport { isDocxBookmark } from './isDocxBookmark';\nimport { isDocxList } from './isDocxList';\nimport { isDocxOl } from './isDocxOl';\n\ninterface Result {\n  list: Element | null;\n  nextSibling: Element | null;\n}\n\nexport const docxListToList = (element: Element): Result => {\n  const listLevel = getDocxListIndent(element);\n  let listHtml = '';\n  let nextSibling: Element | null = element;\n\n  while (nextSibling) {\n    if (isDocxBookmark(nextSibling)) {\n      nextSibling = nextSibling.nextElementSibling;\n      continue;\n    }\n\n    if (!isDocxList(nextSibling)) {\n      break;\n    }\n\n    const nextListLevel = getDocxListIndent(nextSibling);\n\n    if (nextListLevel < listLevel) {\n      // Lower level found. Current list is done.\n      break;\n    }\n\n    if (nextListLevel > listLevel) {\n      const nestedList = docxListToList(nextSibling);\n\n      if (nestedList.list) {\n        listHtml += nestedList.list.outerHTML;\n      }\n\n      nextSibling = nestedList.nextSibling;\n      continue;\n    }\n\n    listHtml += `<li>${getDocxListContentHtml(nextSibling)}</li>`;\n    const currentElement = nextSibling;\n    nextSibling = currentElement.nextElementSibling;\n    currentElement.remove();\n  }\n\n  const listTagName = isDocxOl(element) ? 'ol' : 'ul';\n  const list = parseHtmlElement(`<${listTagName}>${listHtml}</${listTagName}>`);\n\n  return { list, nextSibling };\n};\n","import { docxListToList } from './docxListToList';\nimport { isDocxList } from './isDocxList';\nimport { traverseHtmlElements } from './traverseHtmlElements';\n\nexport const cleanDocxListElementsToList = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    const styleAttribute = element.getAttribute('style');\n\n    if (styleAttribute) {\n      element.setAttribute(\n        'style',\n        styleAttribute.replace(/mso-list:\\s*Ignore/gim, 'mso-list:Ignore')\n      );\n    }\n\n    return true;\n  });\n\n  traverseHtmlElements(rootNode, (element) => {\n    if (!isDocxList(element)) {\n      return true;\n    }\n\n    const { parentElement, previousSibling } = element;\n\n    if (!parentElement) {\n      return true;\n    }\n\n    const { list } = docxListToList(element);\n\n    if (!list) {\n      return true;\n    }\n\n    const beforeElement = previousSibling\n      ? previousSibling.nextSibling\n      : parentElement.firstChild;\n\n    if (beforeElement) {\n      parentElement.insertBefore(list, beforeElement);\n    } else {\n      parentElement.appendChild(list);\n    }\n\n    return false;\n  });\n};\n","/**\n * Replace `element` tag name by `tagName`.\n * Attributes, innerHTML and parent relationship is kept.\n */\nexport const replaceTagName = (element: Element, tagName: string): Element => {\n  const newElement = document.createElement(tagName);\n\n  newElement.innerHTML = element.innerHTML;\n\n  for (const { name } of element.attributes) {\n    const value = element.getAttribute(name);\n\n    if (value) {\n      newElement.setAttribute(name, value);\n    }\n  }\n\n  if (element.parentNode) {\n    element.parentNode.replaceChild(newElement, element);\n  }\n\n  return newElement;\n};\n","import { replaceTagName } from './replaceTagName';\nimport { traverseHtmlElements } from './traverseHtmlElements';\n\n/**\n * Replace p.MsoQuote elements with blockquote.\n */\nexport const cleanDocxQuotes = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (\n      element.parentNode &&\n      element.tagName === 'P' &&\n      element.classList.contains('MsoQuote')\n    ) {\n      replaceTagName(element, 'blockquote');\n    }\n\n    return true;\n  });\n};\n","import { SPACE, TAB } from '../constants';\n\nexport const generateSpaces = (count: number): string =>\n  Array.from({ length: count }, () => SPACE).join('');\n\nexport const generateTabs = (count: number): string =>\n  Array.from({ length: count }, () => TAB).join('');\n","import { generateSpaces } from './generateSpaces';\n\n/**\n * Replace the element with spaces if its style includes 'mso-spacerun: yes'.\n */\nexport const cleanDocxSpacerun = (element: Element): void => {\n  const styleAttribute = element.getAttribute('style');\n\n  if (\n    !(\n      styleAttribute &&\n      ['mso-spacerun:yes', 'mso-spacerun: yes'].includes(styleAttribute)\n    )\n  ) {\n    return;\n  }\n\n  const spacesCount = (element.textContent || '').length;\n  const replacementNode = document.createTextNode(generateSpaces(spacesCount));\n\n  if (element.parentNode) {\n    element.parentNode.replaceChild(replacementNode, element);\n  }\n};\n","import { generateTabs } from './generateSpaces';\n\n/**\n * Replace element with tabs if its style starts with 'mso-tab-count'.\n */\nexport const cleanDocxTabCount = (element: Element): void => {\n  const styleAttribute = element.getAttribute('style') || '';\n\n  if (!styleAttribute.startsWith('mso-tab-count:')) {\n    return;\n  }\n\n  const [, countString] = styleAttribute.split(':');\n  const count = parseInt(countString, 10);\n  const replacementNode = document.createTextNode(generateTabs(count));\n\n  if (element.parentNode) {\n    element.parentNode.replaceChild(replacementNode, element);\n  }\n};\n","import { cleanDocxSpacerun } from './cleanDocxSpacerun';\nimport { cleanDocxTabCount } from './cleanDocxTabCount';\nimport { traverseHtmlElements } from './traverseHtmlElements';\n\n/**\n * Clean docx spaceruns and tab counts.\n */\nexport const cleanDocxSpans = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.nodeName !== 'SPAN') {\n      return true;\n    }\n\n    cleanDocxSpacerun(element);\n    cleanDocxTabCount(element);\n\n    return true;\n  });\n};\n","import { LINE_FEED } from '../constants';\nimport { traverseHtmlElements } from './traverseHtmlElements';\n\n/**\n * Replace BR elements with line feeds.\n */\nexport const cleanHtmlBrElements = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.tagName !== 'BR') {\n      return true;\n    }\n\n    const replacementTextNode = document.createTextNode(LINE_FEED);\n\n    if (element.parentElement) {\n      element.parentElement.replaceChild(replacementTextNode, element);\n    }\n\n    return false;\n  });\n};\n","/**\n * Replace \\r\\n and \\r with \\n\n */\nexport const cleanHtmlCrLf = (html: string): string => {\n  return html.replace(/(\\r\\n|\\r)/gm, '\\n');\n};\n","import { traverseHtmlElements } from './traverseHtmlElements';\n\nconst ALLOWED_EMPTY_ELEMENTS = ['BR', 'IMG'];\n\nconst isEmpty = (element: Element): boolean => {\n  return (\n    !ALLOWED_EMPTY_ELEMENTS.includes(element.nodeName) &&\n    !element.innerHTML.trim()\n  );\n};\n\nconst removeIfEmpty = (element: Element): void => {\n  if (isEmpty(element)) {\n    const { parentElement } = element;\n\n    element.remove();\n\n    if (parentElement) {\n      removeIfEmpty(parentElement);\n    }\n  }\n};\n\n/**\n * Remove empty elements from rootNode.\n * Allowed empty elements: BR, IMG.\n */\nexport const cleanHtmlEmptyElements = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    removeIfEmpty(element);\n    return true;\n  });\n};\n","import { replaceTagName } from './replaceTagName';\nimport { traverseHtmlElements } from './traverseHtmlElements';\n\n/**\n * Replace FONT elements with SPAN elements if there is textContent (remove otherwise).\n */\nexport const cleanHtmlFontElements = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.tagName === 'FONT') {\n      if (element.textContent) {\n        replaceTagName(element, 'span');\n      } else {\n        element.remove();\n      }\n    }\n\n    return true;\n  });\n};\n","/**\n * If href starts with '#'.\n */\nexport const isHtmlFragmentHref = (href: string): boolean =>\n  href.startsWith('#');\n","/**\n * Unwrap the given HTML element.\n */\nexport const unwrapHtmlElement = (element: Element): void => {\n  element.outerHTML = element.innerHTML;\n};\n","import { isHtmlFragmentHref } from './isHtmlFragmentHref';\nimport { traverseHtmlElements } from './traverseHtmlElements';\nimport { unwrapHtmlElement } from './unwrapHtmlElement';\n\n/**\n * Remove fragment hrefs and spans without inner text.\n */\nexport const cleanHtmlLinkElements = (rootNode: Node): void => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.tagName !== 'A') {\n      return true;\n    }\n\n    const href = element.getAttribute('href');\n\n    if (!href || isHtmlFragmentHref(href)) {\n      unwrapHtmlElement(element);\n    }\n\n    if (href && element.querySelector('img')) {\n      for (const span of element.querySelectorAll('span')) {\n        if (!span.innerText) {\n          unwrapHtmlElement(span);\n        }\n      }\n    }\n\n    return true;\n  });\n};\n","import { isHtmlText } from '@udecode/plate-core';\nimport { traverseHtmlNode } from './traverseHtmlNode';\n\ntype Callback = (node: Text) => boolean;\n\nexport const traverseHtmlTexts = (rootNode: Node, callback: Callback): void => {\n  traverseHtmlNode(rootNode, (node) => {\n    if (!isHtmlText(node)) {\n      return true;\n    }\n\n    return callback(node);\n  });\n};\n","import {\n  CARRIAGE_RETURN,\n  LINE_FEED,\n  NO_BREAK_SPACE,\n  SPACE,\n} from '../constants';\nimport { traverseHtmlTexts } from './traverseHtmlTexts';\n\nexport const cleanHtmlTextNodes = (rootNode: Node): void => {\n  traverseHtmlTexts(rootNode, (textNode) => {\n    if (\n      /^\\n\\s*$/.test(textNode.data) &&\n      (textNode.previousElementSibling || textNode.nextElementSibling)\n    ) {\n      textNode.remove();\n\n      return true;\n    }\n\n    textNode.data = textNode.data.replace(/\\n\\s*/g, '\\n');\n\n    if (\n      textNode.data.includes(CARRIAGE_RETURN) ||\n      textNode.data.includes(LINE_FEED) ||\n      textNode.data.includes(NO_BREAK_SPACE)\n    ) {\n      const hasSpace = textNode.data.includes(SPACE);\n      const hasNonWhitespace = /\\S/.test(textNode.data);\n      const hasLineFeed = textNode.data.includes(LINE_FEED);\n\n      if (!(hasSpace || hasNonWhitespace) && !hasLineFeed) {\n        if (textNode.data === NO_BREAK_SPACE) {\n          textNode.data = SPACE;\n          return true;\n        }\n\n        textNode.remove();\n\n        return true;\n      }\n\n      if (\n        textNode.previousSibling &&\n        textNode.previousSibling.nodeName === 'BR' &&\n        textNode.parentElement\n      ) {\n        textNode.parentElement.removeChild(textNode.previousSibling);\n\n        const matches = textNode.data.match(/^[\\r\\n]+/);\n        const offset = matches ? matches[0].length : 0;\n\n        textNode.data = textNode.data\n          .substring(offset)\n          .replace(new RegExp(LINE_FEED, 'g'), SPACE)\n          .replace(new RegExp(CARRIAGE_RETURN, 'g'), SPACE);\n        textNode.data = `\\n${textNode.data}`;\n      } else {\n        textNode.data = textNode.data\n          .replace(new RegExp(LINE_FEED, 'g'), SPACE)\n          .replace(new RegExp(CARRIAGE_RETURN, 'g'), SPACE);\n      }\n    }\n\n    return true;\n  });\n};\n","const DOCX_INDENT_STEP = 32;\n\nexport const getDocxIndent = (\n  element: Element,\n  indentStep = DOCX_INDENT_STEP\n): number => {\n  const el = element as HTMLElement;\n  const { marginLeft } = el.style;\n\n  const marginLeftNumber = parseInt(marginLeft, 10);\n\n  if (!marginLeftNumber) return 0;\n\n  return Math.round(marginLeftNumber / indentStep);\n};\n","import { ListStyleType } from '@udecode/plate-indent-list';\n\nexport const getTextListStyleType = (\n  text: string\n): ListStyleType | undefined => {\n  // text.match(/^\\d+\\s*[-\\\\.)]?\\s+/)?.[0];\n  if (text.match(/^\\d+[\\\\.]/)?.[0]) {\n    return ListStyleType.Decimal;\n  }\n\n  if (text.match(/^[a-z]+\\./)?.[0]) {\n    return ListStyleType.LowerAlpha;\n  }\n};\n","import { traverseHtmlElements } from './traverseHtmlElements';\n\n/**\n * Check if the element contains docx content.\n * True if one element has:\n * - style including 'mso-'\n * - className including 'Mso'\n */\nexport const isDocxContent = (body: HTMLElement): boolean => {\n  let result = false;\n\n  traverseHtmlElements(body, (element) => {\n    const styleAttribute = element.getAttribute('style') || '';\n    const classList = Array.from(element.classList);\n\n    const isMsoElement =\n      styleAttribute.includes('mso-') ||\n      classList.some((className) => className.startsWith('Mso'));\n\n    result = result || isMsoElement;\n\n    return !result;\n  });\n\n  return result;\n};\n","import { ZERO_WIDTH_SPACE } from '../constants';\n\n/**\n * Trim the html and remove zero width spaces,\n * then wrap it with a body element.\n */\nexport const postCleanHtml = (html: string): string => {\n  const cleanHtml = html.trim().replace(new RegExp(ZERO_WIDTH_SPACE, 'g'), '');\n\n  return `<body>${cleanHtml}</body>`;\n};\n","/**\n * Remove string before <html\n */\nconst removeBeforeHtml = (html: string): string => {\n  const index = html.indexOf('<html');\n  if (index === -1) {\n    return html;\n  }\n  return html.substring(index);\n};\n\n/**\n * Remove string after </html>\n */\nconst removeAfterHtml = (html: string): string => {\n  const index = html.lastIndexOf('</html>');\n  if (index === -1) {\n    return html;\n  }\n  return html.substring(0, index + '</html>'.length);\n};\n\n/**\n * Remove string before <html and after </html>\n */\nexport const removeHtmlSurroundings = (html: string): string => {\n  return removeBeforeHtml(removeAfterHtml(html));\n};\n","import { cleanHtmlCrLf } from './cleanHtmlCrLf';\nimport { removeHtmlSurroundings } from './removeHtmlSurroundings';\n\nconst cleaners = [removeHtmlSurroundings, cleanHtmlCrLf];\n\n/**\n * Remove HTML surroundings and clean HTML from CR/LF\n */\nexport const preCleanHtml = (html: string): string => {\n  return cleaners.reduce((result, clean) => clean(result), html);\n};\n","import { copyBlockMarksToSpanChild } from './utils/copyBlockMarksToSpanChild';\nimport {\n  cleanDocxBrComments,\n  cleanDocxEmptyParagraphs,\n  cleanDocxFootnotes,\n  cleanDocxImageElements,\n  cleanDocxListElements,\n  cleanDocxQuotes,\n  cleanDocxSpans,\n  cleanHtmlBrElements,\n  cleanHtmlEmptyElements,\n  cleanHtmlFontElements,\n  cleanHtmlLinkElements,\n  cleanHtmlTextNodes,\n  isDocxContent,\n  postCleanHtml,\n  preCleanHtml,\n} from './utils';\n\nexport const cleanDocx = (html: string, rtf: string): string => {\n  const document = new DOMParser().parseFromString(\n    preCleanHtml(html),\n    'text/html'\n  );\n  const { body } = document;\n\n  if (!rtf && !isDocxContent(body)) {\n    return html;\n  }\n\n  cleanDocxFootnotes(body);\n  cleanDocxImageElements(document, rtf, body);\n  cleanHtmlEmptyElements(body);\n  cleanDocxEmptyParagraphs(body);\n  cleanDocxQuotes(body);\n  cleanDocxSpans(body);\n  cleanHtmlTextNodes(body);\n  cleanDocxBrComments(body);\n  cleanHtmlBrElements(body);\n  cleanHtmlLinkElements(body);\n  cleanHtmlFontElements(body);\n  cleanDocxListElements(body);\n  copyBlockMarksToSpanChild(body);\n\n  return postCleanHtml(body.innerHTML);\n};\n","import { KEY_ALIGN } from '@udecode/plate-alignment';\nimport { MARK_BOLD, MARK_ITALIC } from '@udecode/plate-basic-marks';\nimport {\n  deserializeHtmlCodeBlock,\n  ELEMENT_CODE_BLOCK,\n} from '@udecode/plate-code-block';\nimport {\n  createPluginFactory,\n  DeserializeHtml,\n  KEY_DESERIALIZE_HTML,\n} from '@udecode/plate-core';\nimport { ELEMENT_H1, ELEMENT_H2, ELEMENT_H3 } from '@udecode/plate-heading';\nimport { ELEMENT_IMAGE } from '@udecode/plate-image';\nimport { KEY_INDENT } from '@udecode/plate-indent';\nimport { KEY_LIST_STYLE_TYPE, ListStyleType } from '@udecode/plate-indent-list';\nimport { ELEMENT_PARAGRAPH } from '@udecode/plate-paragraph';\nimport { cleanDocx } from '../docx-cleaner/cleanDocx';\nimport { getDocxIndent } from '../docx-cleaner/utils/getDocxIndent';\nimport { getDocxListContentHtml } from '../docx-cleaner/utils/getDocxListContentHtml';\nimport { getDocxListIndent } from '../docx-cleaner/utils/getDocxListIndent';\nimport { getTextListStyleType } from '../docx-cleaner/utils/getTextListStyleType';\nimport { isDocxContent } from '../docx-cleaner/utils/isDocxContent';\nimport { isDocxList } from '../docx-cleaner/utils/isDocxList';\n\nexport const KEY_DESERIALIZE_DOCX = 'deserializeDocx';\n\nconst getListNode = (type: string): DeserializeHtml['getNode'] => (element) => {\n  const node: any = { type };\n\n  if (element.style.textAlign) {\n    node[KEY_ALIGN] = element.style.textAlign;\n  }\n\n  if (element.style.lineHeight) {\n    node.lineHeight = element.style.lineHeight;\n  }\n\n  if (isDocxList(element)) {\n    node[KEY_INDENT] = getDocxListIndent(element);\n\n    const text = element.textContent ?? '';\n\n    node[KEY_LIST_STYLE_TYPE] =\n      getTextListStyleType(text) ?? ListStyleType.Disc;\n\n    element.innerHTML = getDocxListContentHtml(element);\n  } else {\n    const indent = getDocxIndent(element);\n\n    if (indent) {\n      node[KEY_INDENT] = indent;\n    }\n  }\n\n  return node;\n};\n\nexport const createDeserializeDocxPlugin = createPluginFactory({\n  key: KEY_DESERIALIZE_DOCX,\n  inject: {\n    pluginsByKey: {\n      [KEY_DESERIALIZE_HTML]: {\n        editor: {\n          insertData: {\n            transformData: (data, { dataTransfer }) => {\n              const rtf = dataTransfer.getData('text/rtf');\n\n              return cleanDocx(data, rtf);\n            },\n          },\n        },\n      },\n    },\n  },\n  overrideByKey: {\n    [ELEMENT_PARAGRAPH]: {\n      then: (editor, { type }) => ({\n        deserializeHtml: {\n          query: (el) => {\n            return !el.classList.contains('SourceCode');\n          },\n          getNode: getListNode(type),\n        },\n      }),\n    },\n    [ELEMENT_H1]: {\n      then: (editor, { type }) => ({\n        deserializeHtml: {\n          getNode: getListNode(type),\n        },\n      }),\n    },\n    [ELEMENT_H2]: {\n      then: (editor, { type }) => ({\n        deserializeHtml: {\n          getNode: getListNode(type),\n        },\n      }),\n    },\n    [ELEMENT_H3]: {\n      then: (editor, { type }) => ({\n        deserializeHtml: {\n          getNode: getListNode(type),\n        },\n      }),\n    },\n    [ELEMENT_CODE_BLOCK]: {\n      deserializeHtml: [\n        {\n          validNodeName: 'PRE',\n          ...deserializeHtmlCodeBlock,\n        },\n        {\n          validClassName: 'SourceCode',\n          ...deserializeHtmlCodeBlock,\n        },\n      ],\n    },\n    // [ELEMENT_TABLE]: {\n    //   deserializeHtml:\n    // },\n    [ELEMENT_IMAGE]: {\n      editor: {\n        insertData: {\n          query: ({ dataTransfer }) => {\n            const data = dataTransfer.getData('text/html');\n            const { body } = new DOMParser().parseFromString(data, 'text/html');\n\n            return !isDocxContent(body);\n          },\n        },\n      },\n    },\n    [MARK_BOLD]: {\n      deserializeHtml: [\n        {\n          validNodeName: ['STRONG', 'B'],\n          query: (el) => {\n            return !(\n              (el.children[0] as HTMLElement)?.style.fontWeight === 'normal'\n            );\n          },\n        },\n        {\n          validStyle: {\n            fontWeight: ['600', '700', 'bold'],\n          },\n        },\n      ],\n    },\n    [MARK_ITALIC]: {\n      deserializeHtml: [\n        {\n          validNodeName: ['EM', 'I'],\n          query: (el) => {\n            return !(\n              el.nodeName === 'EM' &&\n              (el.children[0] as HTMLElement)?.style.fontStyle === 'normal'\n            );\n          },\n        },\n        {\n          validStyle: {\n            fontStyle: 'italic',\n          },\n        },\n      ],\n    },\n  },\n});\n"]},"metadata":{},"sourceType":"module"}