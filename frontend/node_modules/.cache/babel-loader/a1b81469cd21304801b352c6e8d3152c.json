{"ast":null,"code":"import { getPlugin, getPluginType, ELEMENT_DEFAULT, createPluginFactory } from '@udecode/plate-core';\nimport { ELEMENT_TABLE, ELEMENT_TH, ELEMENT_TR, ELEMENT_TD } from '@udecode/plate-table';\nimport { parse } from 'papaparse';\n\nconst isValidCsv = (data, errors, errorTolerance) => {\n  if (errorTolerance < 0) errorTolerance = 0;\n  return !(!data || data.length < 2 || data[0].length < 2 || data[1].length < 2 || errors.length && errors.length > errorTolerance * data.length);\n};\n\nconst deserializeCsv = (editor, {\n  data,\n  header = false\n}) => {\n  const {\n    options: {\n      errorTolerance\n    }\n  } = getPlugin(editor, KEY_DESERIALIZE_CSV); // Verify it's a csv string\n\n  const testCsv = parse(data, {\n    preview: 2\n  });\n\n  if (testCsv.errors.length === 0) {\n    const csv = parse(data, {\n      header\n    });\n    if (!isValidCsv(csv.data, csv.errors, errorTolerance)) return;\n    const paragraph = getPluginType(editor, ELEMENT_DEFAULT);\n    const table = getPluginType(editor, ELEMENT_TABLE);\n    const th = getPluginType(editor, ELEMENT_TH);\n    const tr = getPluginType(editor, ELEMENT_TR);\n    const td = getPluginType(editor, ELEMENT_TD);\n    const ast = {\n      type: table,\n      children: []\n    };\n\n    if (csv.meta.fields) {\n      // csv file has headers, data structure is an array of objects keyed on the heading title\n      ast.children.push({\n        type: tr,\n        children: csv.meta.fields.map(field => ({\n          type: th,\n          children: [{\n            type: paragraph,\n            children: [{\n              text: field\n            }]\n          }]\n        }))\n      });\n\n      for (const row of csv.data) {\n        ast.children.push({\n          type: tr,\n          children: csv.meta.fields.map(field => ({\n            type: td,\n            children: [{\n              type: paragraph,\n              children: [{\n                text: row[field] || ''\n              }]\n            }]\n          }))\n        });\n      }\n    } else {\n      // csv is an array of arrays\n      for (const row of csv.data) {\n        ast.children.push({\n          type: tr,\n          children: []\n        });\n\n        for (const cell of row) {\n          ast.children[ast.children.length - 1].children.push({\n            type: td,\n            children: [{\n              type: paragraph,\n              children: [{\n                text: cell\n              }]\n            }]\n          });\n        }\n      }\n    }\n\n    return [{\n      type: paragraph,\n      children: [{\n        text: ''\n      }]\n    }, ast, {\n      type: paragraph,\n      children: [{\n        text: ''\n      }]\n    }];\n  }\n};\n\nconst KEY_DESERIALIZE_CSV = 'deserializeCsv';\n/**\n * Enables support for deserializing content\n * from CSV format to Slate format.\n */\n\nconst createDeserializeCsvPlugin = createPluginFactory({\n  key: KEY_DESERIALIZE_CSV,\n  options: {\n    errorTolerance: 0.25\n  },\n  then: editor => ({\n    editor: {\n      insertData: {\n        format: 'text/plain',\n        getFragment: ({\n          data\n        }) => deserializeCsv(editor, {\n          data,\n          header: true\n        })\n      }\n    }\n  })\n});\nexport { KEY_DESERIALIZE_CSV, createDeserializeCsvPlugin, deserializeCsv };","map":{"version":3,"sources":["../src/deserializer/utils/deserializeCsv.ts","../src/deserializer/createDeserializeCsvPlugin.ts"],"names":["isValidCsv","errorTolerance","data","errors","deserializeCsv","header","options","getPlugin","testCsv","parse","preview","csv","paragraph","getPluginType","table","th","tr","td","ast","type","children","field","text","row","cell","KEY_DESERIALIZE_CSV","createDeserializeCsvPlugin","createPluginFactory","key","then","editor","insertData","format","getFragment"],"mappings":"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","sourcesContent":["import {\n  ELEMENT_DEFAULT,\n  getPlugin,\n  getPluginType,\n  PlateEditor,\n  TDescendant,\n  TElement,\n  TNode,\n} from '@udecode/plate-core';\nimport {\n  ELEMENT_TABLE,\n  ELEMENT_TD,\n  ELEMENT_TH,\n  ELEMENT_TR,\n} from '@udecode/plate-table';\nimport { parse } from 'papaparse';\nimport { KEY_DESERIALIZE_CSV } from '../createDeserializeCsvPlugin';\nimport { DeserializeCsvPlugin } from '../types';\n\nconst isValidCsv = (\n  data: Record<string, string>[][],\n  errors: Record<string, string>[][],\n  errorTolerance: number\n) => {\n  if (errorTolerance < 0) errorTolerance = 0;\n  return !(\n    !data ||\n    data.length < 2 ||\n    data[0].length < 2 ||\n    data[1].length < 2 ||\n    (errors.length && errors.length > errorTolerance * data.length)\n  );\n};\n\nexport const deserializeCsv = <T = {}>(\n  editor: PlateEditor<T>,\n  {\n    data,\n    header = false,\n  }: {\n    data: string;\n    header?: boolean;\n  }\n): TDescendant[] | undefined => {\n  const {\n    options: { errorTolerance },\n  } = getPlugin<DeserializeCsvPlugin, T>(editor, KEY_DESERIALIZE_CSV);\n\n  // Verify it's a csv string\n  const testCsv = parse(data, { preview: 2 });\n\n  if (testCsv.errors.length === 0) {\n    const csv = parse(data, { header });\n\n    if (\n      !isValidCsv(\n        csv.data as Record<string, string>[][],\n        (csv.errors as unknown) as Record<string, string>[][],\n        errorTolerance!\n      )\n    )\n      return;\n\n    const paragraph = getPluginType(editor, ELEMENT_DEFAULT);\n    const table = getPluginType(editor, ELEMENT_TABLE);\n    const th = getPluginType(editor, ELEMENT_TH);\n    const tr = getPluginType(editor, ELEMENT_TR);\n    const td = getPluginType(editor, ELEMENT_TD);\n\n    const ast: TNode = {\n      type: table,\n      children: [],\n    };\n\n    if (csv.meta.fields) {\n      // csv file has headers, data structure is an array of objects keyed on the heading title\n      ast.children.push({\n        type: tr,\n        children: csv.meta.fields.map((field: string) => ({\n          type: th,\n          children: [{ type: paragraph, children: [{ text: field }] }],\n        })),\n      });\n      for (const row of csv.data as Record<string, string>[]) {\n        ast.children.push({\n          type: tr,\n          children: csv.meta.fields.map((field: string) => ({\n            type: td,\n            children: [\n              { type: paragraph, children: [{ text: row[field] || '' }] },\n            ],\n          })),\n        });\n      }\n    } else {\n      // csv is an array of arrays\n      for (const row of csv.data as [string[]]) {\n        ast.children.push({\n          type: tr,\n          children: [],\n        });\n        for (const cell of row) {\n          (ast.children[ast.children.length - 1] as TElement).children.push({\n            type: td,\n            children: [{ type: paragraph, children: [{ text: cell }] }],\n          });\n        }\n      }\n    }\n    return [\n      {\n        type: paragraph,\n        children: [{ text: '' }],\n      },\n      ast,\n      {\n        type: paragraph,\n        children: [{ text: '' }],\n      },\n    ];\n  }\n};\n","import { createPluginFactory } from '@udecode/plate-core';\nimport { DeserializeCsvPlugin } from './types';\nimport { deserializeCsv } from './utils';\n\nexport const KEY_DESERIALIZE_CSV = 'deserializeCsv';\n\n/**\n * Enables support for deserializing content\n * from CSV format to Slate format.\n */\nexport const createDeserializeCsvPlugin = createPluginFactory<DeserializeCsvPlugin>(\n  {\n    key: KEY_DESERIALIZE_CSV,\n    options: {\n      errorTolerance: 0.25,\n    },\n    then: (editor) => ({\n      editor: {\n        insertData: {\n          format: 'text/plain',\n          getFragment: ({ data }) =>\n            deserializeCsv(editor, { data, header: true }),\n        },\n      },\n    }),\n  }\n);\n"]},"metadata":{},"sourceType":"module"}