{"ast":null,"code":"import { createPluginFactory, findNode, isExpanded, useEditorRef, createNodesWithHOC, getNodes, unhangRange } from '@udecode/plate-core';\nimport { createStyles } from '@udecode/plate-styled-components';\nimport _styled, { css } from 'styled-components';\nimport React, { useState, useRef, forwardRef, useMemo } from 'react';\nimport useMergedRef from '@react-hook/merged-ref';\nimport { getEmptyImage } from 'react-dnd-html5-backend';\nimport { useDrag, useDrop } from 'react-dnd';\nimport { Path, Transforms, Editor } from 'slate';\nimport { ReactEditor, useReadOnly } from 'slate-react';\nconst KEY_DND = 'dnd';\nconst createDndPlugin = createPluginFactory({\n  key: KEY_DND,\n  handlers: {\n    onDrop: editor => () => editor.isDragging\n  }\n});\n\nconst getDraggableStyles = props => createStyles({\n  prefixClassNames: 'Draggable',\n  ...props\n}, {\n  root: [{\n    \"position\": \"relative\"\n  }, props.isDragging && {\n    \"opacity\": \"0.5\"\n  }, props.selected && {\n    \"backgroundColor\": \"rgb(181, 215, 255)\"\n  }, css([\":hover .slate-Draggable-gutterLeft{\", \"}\"], {\n    \"opacity\": \"1\"\n  })],\n  block: {\n    \"overflow\": \"auto\"\n  },\n  gutterLeft: [{\n    \"position\": \"absolute\",\n    \"top\": \"0px\",\n    \"display\": \"flex\",\n    \"height\": \"100%\",\n    \"opacity\": \"0\"\n  }, css([\"transform:translateX(-100%);\"])],\n  blockToolbarWrapper: {\n    \"display\": \"flex\",\n    \"height\": \"1.5em\"\n  },\n  blockToolbar: {\n    \"display\": \"flex\",\n    \"alignItems\": \"center\",\n    \"marginRight\": \"0.25rem\",\n    \"pointerEvents\": \"auto\"\n  },\n  dragHandle: [{\n    \"padding\": \"0px\",\n    \"backgroundColor\": \"transparent\",\n    \"backgroundRepeat\": \"no-repeat\",\n    \"cursor\": \"pointer\",\n    \"overflow\": \"hidden\",\n    \"outline\": \"2px solid transparent\",\n    \"outlineOffset\": \"2px\",\n    \"borderStyle\": \"none\"\n  }, {\n    \"minWidth\": \"18px\",\n    \"height\": \"18px\"\n  }],\n  dropLine: [{\n    \"position\": \"absolute\",\n    \"left\": \"0px\",\n    \"right\": \"0px\",\n    \"height\": \"0.125rem\",\n    \"opacity\": \"1\"\n  }, {\n    \"background\": \"#B4D5FF\"\n  }, props.direction === 'top' && {\n    \"top\": \"-1px\"\n  }, props.direction === 'bottom' && {\n    \"bottom\": \"-1px\"\n  }]\n});\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nconst useDragBlock = (editor, id) => {\n  return useDrag(() => ({\n    type: 'block',\n\n    item() {\n      editor.isDragging = true;\n      document.body.classList.add('dragging');\n      return {\n        id\n      };\n    },\n\n    collect: monitor => ({\n      isDragging: monitor.isDragging()\n    }),\n    end: () => {\n      editor.isDragging = false;\n      document.body.classList.remove('dragging');\n    }\n  }), []);\n};\n/**\r\n * If dragging a block A over another block B:\r\n * get the direction of block A relative to block B.\r\n */\n\n\nconst getHoverDirection = (dragItem, monitor, ref, hoverId) => {\n  var _ref$current;\n\n  if (!ref.current) return;\n  const dragId = dragItem.id; // Don't replace items with themselves\n\n  if (dragId === hoverId) return; // Determine rectangle on screen\n\n  const hoverBoundingRect = (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.getBoundingClientRect(); // Get vertical middle\n\n  const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2; // Determine mouse position\n\n  const clientOffset = monitor.getClientOffset();\n  if (!clientOffset) return; // Get pixels to the top\n\n  const hoverClientY = clientOffset.y - hoverBoundingRect.top; // Only perform the move when the mouse has crossed half of the items height\n  // When dragging downwards, only move when the cursor is below 50%\n  // When dragging upwards, only move when the cursor is above 50%\n  // Dragging downwards\n  // if (dragId < hoverId && hoverClientY < hoverMiddleY) {\n\n  if (hoverClientY < hoverMiddleY) {\n    return 'top';\n  } // Dragging upwards\n  // if (dragId > hoverId && hoverClientY > hoverMiddleY) {\n\n\n  if (hoverClientY >= hoverMiddleY) {\n    return 'bottom';\n  }\n};\n/**\r\n * Get new direction if updated\r\n */\n\n\nconst getNewDirection = (previousDir, dir) => {\n  if (!dir && previousDir) {\n    return '';\n  }\n\n  if (dir === 'top' && previousDir !== 'top') {\n    return 'top';\n  }\n\n  if (dir === 'bottom' && previousDir !== 'bottom') {\n    return 'bottom';\n  }\n};\n\nconst useDropBlockOnEditor = (editor, {\n  blockRef,\n  id,\n  dropLine,\n  setDropLine\n}) => {\n  return useDrop({\n    accept: 'block',\n    drop: (dragItem, monitor) => {\n      const direction = getHoverDirection(dragItem, monitor, blockRef, id);\n      if (!direction) return;\n      const dragEntry = findNode(editor, {\n        at: [],\n        match: {\n          id: dragItem.id\n        }\n      });\n      if (!dragEntry) return;\n      const [, dragPath] = dragEntry;\n      ReactEditor.focus(editor);\n      let dropPath;\n\n      if (direction === 'bottom') {\n        var _findNode;\n\n        dropPath = (_findNode = findNode(editor, {\n          at: [],\n          match: {\n            id\n          }\n        })) === null || _findNode === void 0 ? void 0 : _findNode[1];\n        if (!dropPath) return;\n        if (Path.equals(dragPath, Path.next(dropPath))) return;\n      }\n\n      if (direction === 'top') {\n        var _findNode2;\n\n        const nodePath = (_findNode2 = findNode(editor, {\n          at: [],\n          match: {\n            id\n          }\n        })) === null || _findNode2 === void 0 ? void 0 : _findNode2[1];\n        if (!nodePath) return;\n        dropPath = [...nodePath.slice(0, -1), nodePath[nodePath.length - 1] - 1];\n        if (Path.equals(dragPath, dropPath)) return;\n      }\n\n      if (direction) {\n        const _dropPath = dropPath;\n        const before = Path.isBefore(dragPath, _dropPath) && Path.isSibling(dragPath, _dropPath);\n        const to = before ? _dropPath : Path.next(_dropPath);\n        Transforms.moveNodes(editor, {\n          at: dragPath,\n          to\n        });\n      }\n    },\n    collect: monitor => ({\n      isOver: monitor.isOver()\n    }),\n\n    hover(item, monitor) {\n      const direction = getHoverDirection(item, monitor, blockRef, id);\n      const dropLineDir = getNewDirection(dropLine, direction);\n      if (dropLineDir) setDropLine(dropLineDir);\n\n      if (direction && isExpanded(editor.selection)) {\n        ReactEditor.focus(editor);\n        Transforms.collapse(editor);\n      }\n    }\n\n  });\n};\n\nconst useDndBlock = ({\n  id,\n  blockRef,\n  removePreview\n}) => {\n  const editor = useEditorRef();\n  const [dropLine, setDropLine] = useState('');\n  const [{\n    isDragging\n  }, dragRef, preview] = useDragBlock(editor, id);\n  const [{\n    isOver\n  }, drop] = useDropBlockOnEditor(editor, {\n    id,\n    blockRef,\n    dropLine,\n    setDropLine\n  }); // TODO: previewElement option\n\n  if (removePreview) {\n    drop(blockRef);\n    preview(getEmptyImage(), {\n      captureDraggingState: true\n    });\n  } else {\n    preview(drop(blockRef));\n  }\n\n  if (!isOver && dropLine) {\n    setDropLine('');\n  }\n\n  return {\n    isDragging,\n    dropLine,\n    dragRef\n  };\n};\n\nconst DefaultDragHandle = ({\n  styles,\n  ...props\n}) => /*#__PURE__*/React.createElement(_StyledButton, _extends({\n  type: \"button\"\n}, props, {\n  $_css: styles\n}));\n\nconst Draggable = props => {\n  var _styles$blockAndGutte, _styles$blockAndGutte2, _styles$block$css, _styles$block, _styles$dropLine, _styles$dropLine2, _styles$gutterLeft, _styles$blockAndGutte3, _styles$blockAndGutte4, _styles$gutterLeft$cs, _styles$gutterLeft2, _styles$blockToolbarW, _styles$blockToolbarW2, _styles$blockToolbar, _styles$blockToolbar2, _styles$dragHandle, _styles$dragHandle2;\n\n  const {\n    children,\n    element,\n    componentRef,\n    onRenderDragHandle\n  } = props;\n  const DragHandle = onRenderDragHandle !== null && onRenderDragHandle !== void 0 ? onRenderDragHandle : DefaultDragHandle;\n  const blockRef = useRef(null);\n  const rootRef = useRef(null);\n  const dragWrapperRef = useRef(null);\n  const multiRootRef = useMergedRef(componentRef, rootRef);\n  const {\n    dropLine,\n    dragRef,\n    isDragging\n  } = useDndBlock({\n    id: element.id,\n    blockRef: rootRef\n  });\n  const multiDragRef = useMergedRef(dragRef, dragWrapperRef);\n  const styles = getDraggableStyles({ ...props,\n    direction: dropLine,\n    isDragging\n  });\n  return /*#__PURE__*/React.createElement(_StyledDiv, {\n    className: styles.root.className,\n    ref: multiRootRef,\n    $_css2: styles.root.css\n  }, /*#__PURE__*/React.createElement(_StyledDiv2, {\n    ref: blockRef,\n    $_css3: [...((_styles$blockAndGutte = (_styles$blockAndGutte2 = styles.blockAndGutter) === null || _styles$blockAndGutte2 === void 0 ? void 0 : _styles$blockAndGutte2.css) !== null && _styles$blockAndGutte !== void 0 ? _styles$blockAndGutte : []), ...((_styles$block$css = (_styles$block = styles.block) === null || _styles$block === void 0 ? void 0 : _styles$block.css) !== null && _styles$block$css !== void 0 ? _styles$block$css : [])]\n  }, children, !!dropLine && /*#__PURE__*/React.createElement(_StyledDiv3, {\n    className: (_styles$dropLine = styles.dropLine) === null || _styles$dropLine === void 0 ? void 0 : _styles$dropLine.className,\n    contentEditable: false,\n    $_css4: (_styles$dropLine2 = styles.dropLine) === null || _styles$dropLine2 === void 0 ? void 0 : _styles$dropLine2.css\n  })), /*#__PURE__*/React.createElement(_StyledDiv4, {\n    className: (_styles$gutterLeft = styles.gutterLeft) === null || _styles$gutterLeft === void 0 ? void 0 : _styles$gutterLeft.className,\n    contentEditable: false,\n    $_css5: [...((_styles$blockAndGutte3 = (_styles$blockAndGutte4 = styles.blockAndGutter) === null || _styles$blockAndGutte4 === void 0 ? void 0 : _styles$blockAndGutte4.css) !== null && _styles$blockAndGutte3 !== void 0 ? _styles$blockAndGutte3 : []), ...((_styles$gutterLeft$cs = (_styles$gutterLeft2 = styles.gutterLeft) === null || _styles$gutterLeft2 === void 0 ? void 0 : _styles$gutterLeft2.css) !== null && _styles$gutterLeft$cs !== void 0 ? _styles$gutterLeft$cs : [])]\n  }, /*#__PURE__*/React.createElement(_StyledDiv5, {\n    className: (_styles$blockToolbarW = styles.blockToolbarWrapper) === null || _styles$blockToolbarW === void 0 ? void 0 : _styles$blockToolbarW.className,\n    $_css6: (_styles$blockToolbarW2 = styles.blockToolbarWrapper) === null || _styles$blockToolbarW2 === void 0 ? void 0 : _styles$blockToolbarW2.css\n  }, /*#__PURE__*/React.createElement(_StyledDiv6, {\n    className: (_styles$blockToolbar = styles.blockToolbar) === null || _styles$blockToolbar === void 0 ? void 0 : _styles$blockToolbar.className,\n    ref: multiDragRef,\n    $_css7: (_styles$blockToolbar2 = styles.blockToolbar) === null || _styles$blockToolbar2 === void 0 ? void 0 : _styles$blockToolbar2.css\n  }, /*#__PURE__*/React.createElement(DragHandle, {\n    element: element,\n    styles: (_styles$dragHandle = styles.dragHandle) === null || _styles$dragHandle === void 0 ? void 0 : _styles$dragHandle.css,\n    className: (_styles$dragHandle2 = styles.dragHandle) === null || _styles$dragHandle2 === void 0 ? void 0 : _styles$dragHandle2.className,\n    onMouseDown: e => e.stopPropagation()\n  })))));\n};\n\nvar _StyledButton = _styled(\"button\").withConfig({\n  displayName: \"Draggable___StyledButton\",\n  componentId: \"sc-1c1pto8-0\"\n})([\"\", \"\"], p => p.$_css);\n\nvar _StyledDiv = _styled(\"div\").withConfig({\n  displayName: \"Draggable___StyledDiv\",\n  componentId: \"sc-1c1pto8-1\"\n})([\"\", \"\"], p => p.$_css2);\n\nvar _StyledDiv2 = _styled(\"div\").withConfig({\n  displayName: \"Draggable___StyledDiv2\",\n  componentId: \"sc-1c1pto8-2\"\n})([\"\", \"\"], p => p.$_css3);\n\nvar _StyledDiv3 = _styled(\"div\").withConfig({\n  displayName: \"Draggable___StyledDiv3\",\n  componentId: \"sc-1c1pto8-3\"\n})([\"\", \"\"], p => p.$_css4);\n\nvar _StyledDiv4 = _styled(\"div\").withConfig({\n  displayName: \"Draggable___StyledDiv4\",\n  componentId: \"sc-1c1pto8-4\"\n})([\"\", \"\"], p => p.$_css5);\n\nvar _StyledDiv5 = _styled(\"div\").withConfig({\n  displayName: \"Draggable___StyledDiv5\",\n  componentId: \"sc-1c1pto8-5\"\n})([\"\", \"\"], p => p.$_css6);\n\nvar _StyledDiv6 = _styled(\"div\").withConfig({\n  displayName: \"Draggable___StyledDiv6\",\n  componentId: \"sc-1c1pto8-6\"\n})([\"\", \"\"], p => p.$_css7);\n\nconst GrabberTooltipContent = () => /*#__PURE__*/React.createElement(\"div\", {\n  style: {\n    fontSize: 12\n  }\n}, /*#__PURE__*/React.createElement(\"div\", null, \"Drag \", /*#__PURE__*/React.createElement(\"span\", {\n  style: {\n    color: 'rgba(255, 255, 255, 0.45)'\n  }\n}, \"to move\")));\n\nconst grabberTooltipProps = {\n  content: /*#__PURE__*/React.createElement(GrabberTooltipContent, null),\n  placement: 'bottom',\n  arrow: false,\n  offset: [0, 0],\n  delay: [300, 0],\n  duration: [0, 0],\n  hideOnClick: true,\n  theme: 'small'\n};\n\nconst withDraggable = (Component, {\n  styles,\n  level,\n  filter,\n  allowReadOnly = false,\n  onRenderDragHandle\n} = {}) => {\n  return /*#__PURE__*/forwardRef((props, ref) => {\n    const {\n      attributes,\n      element,\n      editor\n    } = props;\n    const readOnly = useReadOnly();\n    const path = useMemo(() => ReactEditor.findPath(editor, element), [editor, element]);\n    const filteredOut = useMemo(() => Number.isInteger(level) && level !== path.length - 1 || filter && filter(editor, path), [path, editor]);\n\n    if (filteredOut || !allowReadOnly && readOnly) {\n      return /*#__PURE__*/React.createElement(Component, props);\n    }\n\n    return /*#__PURE__*/React.createElement(Draggable, {\n      editor: editor,\n      attributes: attributes,\n      element: element,\n      componentRef: ref,\n      styles: styles,\n      onRenderDragHandle: onRenderDragHandle\n    }, /*#__PURE__*/React.createElement(Component, props));\n  });\n};\n\nconst withDraggables = createNodesWithHOC(withDraggable);\n/**\r\n * Select the start of a block by id and focus the editor.\r\n */\n\nconst focusBlockStartById = (editor, id) => {\n  var _findNode;\n\n  const path = (_findNode = findNode(editor, {\n    at: [],\n    match: {\n      id\n    }\n  })) === null || _findNode === void 0 ? void 0 : _findNode[1];\n  if (!path) return;\n  Transforms.select(editor, Editor.start(editor, path));\n  ReactEditor.focus(editor);\n};\n/**\r\n * Get blocks with an id\r\n */\n\n\nconst getBlocksWithId = (editor, options) => {\n  return [...getNodes(editor, {\n    match: n => Editor.isBlock(editor, n) && !!n.id,\n    ...options\n  })];\n};\n/**\r\n * Get node entries range.\r\n */\n\n\nconst getNodesRange = (editor, nodeEntries) => {\n  if (!nodeEntries.length) return;\n  const firstBlockPath = nodeEntries[0][1];\n  const lastBlockPath = nodeEntries[nodeEntries.length - 1][1];\n  return Editor.range(editor, firstBlockPath, lastBlockPath);\n};\n/**\r\n * Remove blocks with an id and focus the editor.\r\n */\n\n\nconst removeBlocksAndFocus = (editor, options) => {\n  unhangRange(editor, options);\n  const nodeEntries = getBlocksWithId(editor, options);\n  Transforms.removeNodes(editor, {\n    at: getNodesRange(editor, nodeEntries)\n  });\n  ReactEditor.focus(editor);\n};\n/**\r\n * Select the block above the selection by id and focus the editor.\r\n */\n\n\nconst selectBlockById = (editor, id) => {\n  var _findNode;\n\n  const path = (_findNode = findNode(editor, {\n    at: [],\n    match: {\n      id\n    }\n  })) === null || _findNode === void 0 ? void 0 : _findNode[1];\n  if (!path) return;\n  Transforms.select(editor, Editor.range(editor, path));\n  ReactEditor.focus(editor);\n};\n/**\r\n * Select blocks by selection or by id.\r\n * If the block with id is not selected, select the block with id.\r\n * Else, select the blocks above the selection.\r\n */\n\n\nconst selectBlocksBySelectionOrId = (editor, id) => {\n  if (!editor.selection) return;\n  const blockEntries = getBlocksWithId(editor, {\n    at: editor.selection\n  });\n  const isBlockSelected = blockEntries.some(blockEntry => blockEntry[0].id === id);\n\n  if (isBlockSelected) {\n    Transforms.select(editor, getNodesRange(editor, blockEntries));\n    ReactEditor.focus(editor);\n  } else {\n    selectBlockById(editor, id);\n  }\n};\n\nexport { Draggable, KEY_DND, createDndPlugin, focusBlockStartById, getBlocksWithId, getDraggableStyles, getHoverDirection, getNewDirection, getNodesRange, grabberTooltipProps, removeBlocksAndFocus, selectBlockById, selectBlocksBySelectionOrId, useDndBlock, useDragBlock, useDropBlockOnEditor, withDraggable, withDraggables };","map":{"version":3,"sources":["../src/createDndPlugin.ts","../src/components/Draggable.styles.ts","../src/hooks/useDragBlock.ts","../src/utils/getHoverDirection.ts","../src/utils/getNewDirection.ts","../src/hooks/useDropBlockOnEditor.ts","../src/hooks/useDndBlock.ts","../src/components/Draggable.tsx","../src/components/grabberTooltipProps.tsx","../src/components/withDraggable.tsx","../src/utils/focusBlockStartById.ts","../src/utils/getBlocksWithId.ts","../src/utils/getNodesRange.ts","../src/utils/removeBlocksAndFocus.ts","../src/utils/selectBlockById.ts","../src/utils/selectBlocksBySelectionOrId.ts"],"names":["KEY_DND","createDndPlugin","createPluginFactory","key","handlers","onDrop","editor","isDragging","getDraggableStyles","props","createStyles","prefixClassNames","root","css","block","gutterLeft","blockToolbarWrapper","blockToolbar","dragHandle","dropLine","useDragBlock","useDrag","type","item","document","id","collect","monitor","end","getHoverDirection","ref","dragId","dragItem","hoverBoundingRect","hoverMiddleY","clientOffset","hoverClientY","getNewDirection","dir","previousDir","useDropBlockOnEditor","setDropLine","useDrop","accept","drop","direction","dragEntry","findNode","at","match","ReactEditor","dropPath","Path","nodePath","_dropPath","before","to","Transforms","isOver","hover","dropLineDir","isExpanded","useDndBlock","removePreview","useEditorRef","useState","preview","getEmptyImage","captureDraggingState","dragRef","DefaultDragHandle","styles","Draggable","onRenderDragHandle","DragHandle","blockRef","useRef","rootRef","dragWrapperRef","multiRootRef","useMergedRef","element","multiDragRef","e","GrabberTooltipContent","fontSize","color","grabberTooltipProps","content","placement","arrow","offset","delay","duration","hideOnClick","theme","withDraggable","allowReadOnly","forwardRef","readOnly","useReadOnly","path","useMemo","filteredOut","Number","level","filter","withDraggables","createNodesWithHOC","focusBlockStartById","Editor","getBlocksWithId","getNodes","n","options","getNodesRange","nodeEntries","firstBlockPath","lastBlockPath","removeBlocksAndFocus","unhangRange","selectBlockById","selectBlocksBySelectionOrId","blockEntries","selection","isBlockSelected","blockEntry"],"mappings":"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","sourcesContent":["import { createPluginFactory } from '@udecode/plate-core';\n\nexport const KEY_DND = 'dnd';\n\nexport const createDndPlugin = createPluginFactory({\n  key: KEY_DND,\n  handlers: {\n    onDrop: (editor) => () => editor.isDragging,\n  },\n});\n","import { createStyles } from '@udecode/plate-styled-components';\nimport { css } from 'styled-components';\nimport tw from 'twin.macro';\nimport { DraggableStyleProps } from './Draggable.types';\n\nexport const getDraggableStyles = (props: DraggableStyleProps) =>\n  createStyles(\n    { prefixClassNames: 'Draggable', ...props },\n    {\n      root: [\n        tw`relative`,\n        props.isDragging && tw`opacity-50`,\n        props.selected && tw`backgroundColor[rgb(181, 215, 255)]`,\n        css`\n          :hover .slate-Draggable-gutterLeft {\n            ${tw`opacity-100`}\n          }\n        `,\n      ],\n\n      block: tw`overflow-auto`,\n      gutterLeft: [\n        tw`absolute top-0 flex h-full opacity-0`,\n        css`\n          transform: translateX(-100%);\n        `,\n      ],\n\n      blockToolbarWrapper: tw`flex height[1.5em]`,\n      blockToolbar: tw`flex items-center mr-1 pointer-events-auto`,\n      dragHandle: [\n        tw`p-0 bg-transparent bg-no-repeat cursor-pointer overflow-hidden outline-none border-none`,\n        tw`minWidth[18px] height[18px]`,\n      ],\n      dropLine: [\n        tw`absolute left-0 right-0 h-0.5 opacity-100`,\n        tw`background[#B4D5FF]`,\n        props.direction === 'top' && tw`-top-px`,\n        props.direction === 'bottom' && tw`-bottom-px`,\n      ],\n    }\n  );\n","import { useDrag } from 'react-dnd';\nimport { TEditor } from '@udecode/plate-core';\n\nexport const useDragBlock = (editor: TEditor, id: string) => {\n  return useDrag(\n    () => ({\n      type: 'block',\n      item() {\n        editor.isDragging = true;\n        document.body.classList.add('dragging');\n        return { id };\n      },\n      collect: (monitor) => ({\n        isDragging: monitor.isDragging(),\n      }),\n      end: () => {\n        editor.isDragging = false;\n        document.body.classList.remove('dragging');\n      },\n    }),\n    []\n  );\n};\n","import { DropTargetMonitor, XYCoord } from 'react-dnd';\nimport { DragItemBlock, DropDirection } from '../types';\n\n/**\n * If dragging a block A over another block B:\n * get the direction of block A relative to block B.\n */\nexport const getHoverDirection = (\n  dragItem: DragItemBlock,\n  monitor: DropTargetMonitor,\n  ref: any,\n  hoverId: string\n): DropDirection => {\n  if (!ref.current) return;\n\n  const dragId = dragItem.id;\n\n  // Don't replace items with themselves\n  if (dragId === hoverId) return;\n\n  // Determine rectangle on screen\n  const hoverBoundingRect = ref.current?.getBoundingClientRect();\n\n  // Get vertical middle\n  const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;\n\n  // Determine mouse position\n  const clientOffset = monitor.getClientOffset();\n  if (!clientOffset) return;\n\n  // Get pixels to the top\n  const hoverClientY = (clientOffset as XYCoord).y - hoverBoundingRect.top;\n\n  // Only perform the move when the mouse has crossed half of the items height\n  // When dragging downwards, only move when the cursor is below 50%\n  // When dragging upwards, only move when the cursor is above 50%\n\n  // Dragging downwards\n  // if (dragId < hoverId && hoverClientY < hoverMiddleY) {\n  if (hoverClientY < hoverMiddleY) {\n    return 'top';\n  }\n\n  // Dragging upwards\n  // if (dragId > hoverId && hoverClientY > hoverMiddleY) {\n  if (hoverClientY >= hoverMiddleY) {\n    return 'bottom';\n  }\n};\n","/**\n * Get new direction if updated\n */\nexport const getNewDirection = (previousDir: string, dir?: string) => {\n  if (!dir && previousDir) {\n    return '';\n  }\n\n  if (dir === 'top' && previousDir !== 'top') {\n    return 'top';\n  }\n\n  if (dir === 'bottom' && previousDir !== 'bottom') {\n    return 'bottom';\n  }\n};\n","import { DropTargetMonitor, useDrop } from 'react-dnd';\nimport { findNode, isExpanded } from '@udecode/plate-core';\nimport { Path, Transforms } from 'slate';\nimport { ReactEditor } from 'slate-react';\nimport { DragItemBlock } from '../types';\nimport { getHoverDirection } from '../utils/getHoverDirection';\nimport { getNewDirection } from '../utils/getNewDirection';\n\nexport const useDropBlockOnEditor = (\n  editor: ReactEditor,\n  {\n    blockRef,\n    id,\n    dropLine,\n    setDropLine,\n  }: {\n    blockRef: any;\n    id: string;\n    dropLine: string;\n    setDropLine: Function;\n  }\n) => {\n  return useDrop({\n    accept: 'block',\n    drop: (dragItem: DragItemBlock, monitor: DropTargetMonitor) => {\n      const direction = getHoverDirection(dragItem, monitor, blockRef, id);\n      if (!direction) return;\n\n      const dragEntry = findNode(editor, {\n        at: [],\n        match: { id: dragItem.id },\n      });\n      if (!dragEntry) return;\n      const [, dragPath] = dragEntry;\n\n      ReactEditor.focus(editor);\n\n      let dropPath: Path | undefined;\n      if (direction === 'bottom') {\n        dropPath = findNode(editor, { at: [], match: { id } })?.[1];\n        if (!dropPath) return;\n\n        if (Path.equals(dragPath, Path.next(dropPath))) return;\n      }\n\n      if (direction === 'top') {\n        const nodePath = findNode(editor, { at: [], match: { id } })?.[1];\n\n        if (!nodePath) return;\n        dropPath = [\n          ...nodePath.slice(0, -1),\n          nodePath[nodePath.length - 1] - 1,\n        ];\n\n        if (Path.equals(dragPath, dropPath)) return;\n      }\n\n      if (direction) {\n        const _dropPath = dropPath as Path;\n\n        const before =\n          Path.isBefore(dragPath, _dropPath) &&\n          Path.isSibling(dragPath, _dropPath);\n        const to = before ? _dropPath : Path.next(_dropPath);\n\n        Transforms.moveNodes(editor, {\n          at: dragPath,\n          to,\n        });\n      }\n    },\n    collect: (monitor) => ({\n      isOver: monitor.isOver(),\n    }),\n    hover(item: DragItemBlock, monitor: DropTargetMonitor) {\n      const direction = getHoverDirection(item, monitor, blockRef, id);\n      const dropLineDir = getNewDirection(dropLine, direction);\n      if (dropLineDir) setDropLine(dropLineDir);\n\n      if (direction && isExpanded(editor.selection)) {\n        ReactEditor.focus(editor);\n        Transforms.collapse(editor);\n      }\n    },\n  });\n};\n","import { useState } from 'react';\nimport { getEmptyImage } from 'react-dnd-html5-backend';\nimport { useEditorRef } from '@udecode/plate-core';\nimport { useDragBlock } from './useDragBlock';\nimport { useDropBlockOnEditor } from './useDropBlockOnEditor';\n\nexport const useDndBlock = ({\n  id,\n  blockRef,\n  removePreview,\n}: {\n  id: string;\n  blockRef: any;\n  removePreview?: boolean;\n}) => {\n  const editor = useEditorRef();\n\n  const [dropLine, setDropLine] = useState<'' | 'top' | 'bottom'>('');\n\n  const [{ isDragging }, dragRef, preview] = useDragBlock(editor, id);\n  const [{ isOver }, drop] = useDropBlockOnEditor(editor, {\n    id,\n    blockRef,\n    dropLine,\n    setDropLine,\n  });\n\n  // TODO: previewElement option\n  if (removePreview) {\n    drop(blockRef);\n    preview(getEmptyImage(), { captureDraggingState: true });\n  } else {\n    preview(drop(blockRef));\n  }\n\n  if (!isOver && dropLine) {\n    setDropLine('');\n  }\n\n  return {\n    isDragging,\n    dropLine,\n    dragRef,\n  };\n};\n","import React, { useRef } from 'react';\nimport useMergedRef from '@react-hook/merged-ref';\nimport { useDndBlock } from '../hooks/useDndBlock';\nimport { getDraggableStyles } from './Draggable.styles';\nimport { DraggableProps, DragHandleProps } from './Draggable.types';\n\nconst DefaultDragHandle = ({ styles, ...props }: DragHandleProps) => (\n  <button type=\"button\" {...props} css={styles} />\n);\n\nexport const Draggable = (props: DraggableProps) => {\n  const { children, element, componentRef, onRenderDragHandle } = props;\n\n  const DragHandle = onRenderDragHandle ?? DefaultDragHandle;\n\n  const blockRef = useRef<HTMLDivElement>(null);\n  const rootRef = useRef<HTMLDivElement>(null);\n  const dragWrapperRef = useRef(null);\n  const multiRootRef = useMergedRef(componentRef, rootRef);\n\n  const { dropLine, dragRef, isDragging } = useDndBlock({\n    id: element.id,\n    blockRef: rootRef,\n  });\n\n  const multiDragRef = useMergedRef(dragRef, dragWrapperRef);\n\n  const styles = getDraggableStyles({\n    ...props,\n    direction: dropLine,\n    isDragging,\n  });\n\n  return (\n    <div\n      css={styles.root.css}\n      className={styles.root.className}\n      ref={multiRootRef}\n    >\n      <div\n        ref={blockRef}\n        css={[\n          ...(styles.blockAndGutter?.css ?? []),\n          ...(styles.block?.css ?? []),\n        ]}\n      >\n        {children}\n\n        {!!dropLine && (\n          <div\n            css={styles.dropLine?.css}\n            className={styles.dropLine?.className}\n            contentEditable={false}\n          />\n        )}\n      </div>\n\n      <div\n        css={[\n          ...(styles.blockAndGutter?.css ?? []),\n          ...(styles.gutterLeft?.css ?? []),\n        ]}\n        className={styles.gutterLeft?.className}\n        contentEditable={false}\n      >\n        <div\n          css={styles.blockToolbarWrapper?.css}\n          className={styles.blockToolbarWrapper?.className}\n        >\n          <div\n            css={styles.blockToolbar?.css}\n            className={styles.blockToolbar?.className}\n            ref={multiDragRef}\n          >\n            <DragHandle\n              element={element}\n              styles={styles.dragHandle?.css}\n              className={styles.dragHandle?.className}\n              onMouseDown={(e: any) => e.stopPropagation()}\n            />\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n","import React from 'react';\nimport { TippyProps } from '@tippyjs/react';\n\nconst GrabberTooltipContent = () => (\n  <div style={{ fontSize: 12 }}>\n    <div>\n      Drag <span style={{ color: 'rgba(255, 255, 255, 0.45)' }}>to move</span>\n    </div>\n  </div>\n);\nexport const grabberTooltipProps: TippyProps = {\n  content: <GrabberTooltipContent />,\n  placement: 'bottom',\n  arrow: false,\n  offset: [0, 0],\n  delay: [300, 0],\n  duration: [0, 0],\n  hideOnClick: true,\n  theme: 'small',\n};\n","import React, { forwardRef, useMemo } from 'react';\nimport {\n  createNodesWithHOC,\n  PlateRenderElementProps,\n  TEditor,\n} from '@udecode/plate-core';\nimport { Path } from 'slate';\nimport { ReactEditor, useReadOnly } from 'slate-react';\nimport { Draggable } from './Draggable';\nimport { DraggableProps } from './Draggable.types';\n\nexport interface WithDraggableOptions\n  extends Pick<DraggableProps, 'onRenderDragHandle' | 'styles'> {\n  level?: number;\n  filter?: (editor: TEditor, path: Path) => boolean;\n  allowReadOnly?: boolean;\n}\n\nexport const withDraggable = (\n  Component: any,\n  {\n    styles,\n    level,\n    filter,\n    allowReadOnly = false,\n    onRenderDragHandle,\n  }: WithDraggableOptions = {}\n) => {\n  return forwardRef((props: PlateRenderElementProps, ref) => {\n    const { attributes, element, editor } = props;\n    const readOnly = useReadOnly();\n    const path = useMemo(() => ReactEditor.findPath(editor, element), [\n      editor,\n      element,\n    ]);\n\n    const filteredOut = useMemo(\n      () =>\n        (Number.isInteger(level) && level !== path.length - 1) ||\n        (filter && filter(editor, path)),\n      [path, editor]\n    );\n\n    if (filteredOut || (!allowReadOnly && readOnly)) {\n      return <Component {...props} />;\n    }\n\n    return (\n      <Draggable\n        editor={editor}\n        attributes={attributes}\n        element={element}\n        componentRef={ref}\n        styles={styles}\n        onRenderDragHandle={onRenderDragHandle}\n      >\n        <Component {...props} />\n      </Draggable>\n    );\n  });\n};\n\nexport const withDraggables = createNodesWithHOC(withDraggable);\n","import { findNode } from '@udecode/plate-core';\nimport { Editor, Transforms } from 'slate';\nimport { ReactEditor } from 'slate-react';\n\n/**\n * Select the start of a block by id and focus the editor.\n */\nexport const focusBlockStartById = (editor: ReactEditor, id: string) => {\n  const path = findNode(editor, { at: [], match: { id } })?.[1];\n  if (!path) return;\n\n  Transforms.select(editor, Editor.start(editor, path));\n  ReactEditor.focus(editor);\n};\n","import { EditorNodesOptions, getNodes, TEditor } from '@udecode/plate-core';\nimport { Editor } from 'slate';\n\n/**\n * Get blocks with an id\n */\nexport const getBlocksWithId = (\n  editor: TEditor,\n  options: EditorNodesOptions\n) => {\n  return [\n    ...getNodes(editor, {\n      match: (n) => Editor.isBlock(editor, n) && !!n.id,\n      ...options,\n    }),\n  ];\n};\n","import { TEditor } from '@udecode/plate-core';\nimport { Editor, NodeEntry } from 'slate';\n\n/**\n * Get node entries range.\n */\nexport const getNodesRange = (editor: TEditor, nodeEntries: NodeEntry[]) => {\n  if (!nodeEntries.length) return;\n\n  const firstBlockPath = nodeEntries[0][1];\n  const lastBlockPath = nodeEntries[nodeEntries.length - 1][1];\n\n  return Editor.range(editor, firstBlockPath, lastBlockPath);\n};\n","import { EditorNodesOptions, unhangRange } from '@udecode/plate-core';\nimport { Transforms } from 'slate';\nimport { ReactEditor } from 'slate-react';\nimport { getBlocksWithId } from './getBlocksWithId';\nimport { getNodesRange } from './getNodesRange';\n\n/**\n * Remove blocks with an id and focus the editor.\n */\nexport const removeBlocksAndFocus = (\n  editor: ReactEditor,\n  options: EditorNodesOptions\n) => {\n  unhangRange(editor, options);\n\n  const nodeEntries = getBlocksWithId(editor, options);\n\n  Transforms.removeNodes(editor, { at: getNodesRange(editor, nodeEntries) });\n  ReactEditor.focus(editor);\n};\n","import { findNode } from '@udecode/plate-core';\nimport { Editor, Transforms } from 'slate';\nimport { ReactEditor } from 'slate-react';\n\n/**\n * Select the block above the selection by id and focus the editor.\n */\nexport const selectBlockById = (editor: ReactEditor, id: string) => {\n  const path = findNode(editor, { at: [], match: { id } })?.[1];\n  if (!path) return;\n\n  Transforms.select(editor, Editor.range(editor, path));\n  ReactEditor.focus(editor);\n};\n","import { Range, Transforms } from 'slate';\nimport { ReactEditor } from 'slate-react';\nimport { getBlocksWithId } from './getBlocksWithId';\nimport { getNodesRange } from './getNodesRange';\nimport { selectBlockById } from './selectBlockById';\n\n/**\n * Select blocks by selection or by id.\n * If the block with id is not selected, select the block with id.\n * Else, select the blocks above the selection.\n */\nexport const selectBlocksBySelectionOrId = (\n  editor: ReactEditor,\n  id: string\n) => {\n  if (!editor.selection) return;\n\n  const blockEntries = getBlocksWithId(editor, { at: editor.selection });\n  const isBlockSelected = blockEntries.some(\n    (blockEntry) => blockEntry[0].id === id\n  );\n\n  if (isBlockSelected) {\n    Transforms.select(editor, getNodesRange(editor, blockEntries) as Range);\n    ReactEditor.focus(editor);\n  } else {\n    selectBlockById(editor, id);\n  }\n};\n"]},"metadata":{},"sourceType":"module"}